/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */

/**
 * Delete a node from the system.  To delete a node, the data is first
 * distributed from the deleted node to all the other nodes.  Then the node is
 * taken out of service.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminDeleteNodeResponse adminDeleteNode( const AdminDeleteNodeRequest& request_ ) const;

/**
 * Delete a node from the system.  To delete a node, the data is first
 * distributed from the deleted node to all the other nodes.  Then the node is
 * taken out of service.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminDeleteNodeResponse& adminDeleteNode( const AdminDeleteNodeRequest& request_,
                                          AdminDeleteNodeResponse& response_ ) const;

/**
 * Delete a node from the system.  To delete a node, the data is first
 * distributed from the deleted node to all the other nodes.  Then the node is
 * taken out of service.
 * 
 * @param rank  Rank number of the node being removed from the system.
 * @param authorization  The password that GPUdb is configured with during
 *                       startup. Incorrect or missing authorization code will
 *                       result in an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminDeleteNodeResponse adminDeleteNode( const int32_t rank,
                                         const std::string& authorization,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Delete a node from the system.  To delete a node, the data is first
 * distributed from the deleted node to all the other nodes.  Then the node is
 * taken out of service.
 * 
 * @param rank  Rank number of the node being removed from the system.
 * @param authorization  The password that GPUdb is configured with during
 *                       startup. Incorrect or missing authorization code will
 *                       result in an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminDeleteNodeResponse& adminDeleteNode( const int32_t rank,
                                          const std::string& authorization,
                                          const std::map<std::string, std::string>& options,
                                          AdminDeleteNodeResponse& response_ ) const;

/**
 * Returns the list of shards and the corresponding rank and tom containing the
 * shard.  The response message contains arrays of 16384 (total number of
 * shards in the system) rank and tom numbers corresponding to each shard.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminGetShardAssignmentsResponse adminGetShardAssignments( const AdminGetShardAssignmentsRequest& request_ ) const;

/**
 * Returns the list of shards and the corresponding rank and tom containing the
 * shard.  The response message contains arrays of 16384 (total number of
 * shards in the system) rank and tom numbers corresponding to each shard.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminGetShardAssignmentsResponse& adminGetShardAssignments( const AdminGetShardAssignmentsRequest& request_,
                                                            AdminGetShardAssignmentsResponse& response_ ) const;

/**
 * Returns the list of shards and the corresponding rank and tom containing the
 * shard.  The response message contains arrays of 16384 (total number of
 * shards in the system) rank and tom numbers corresponding to each shard.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminGetShardAssignmentsResponse adminGetShardAssignments( const std::map<std::string, std::string>& options ) const;

/**
 * Returns the list of shards and the corresponding rank and tom containing the
 * shard.  The response message contains arrays of 16384 (total number of
 * shards in the system) rank and tom numbers corresponding to each shard.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminGetShardAssignmentsResponse& adminGetShardAssignments( const std::map<std::string, std::string>& options,
                                                            AdminGetShardAssignmentsResponse& response_ ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse adminOffline( const AdminOfflineRequest& request_ ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& adminOffline( const AdminOfflineRequest& request_,
                                    AdminOfflineResponse& response_ ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse adminOffline( const bool offline,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& adminOffline( const bool offline,
                                    const std::map<std::string, std::string>& options,
                                    AdminOfflineResponse& response_ ) const;

/**
 * Rebalance the database such that all the nodes contain approximately equal
 * number of records.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse adminRebalance( const AdminRebalanceRequest& request_ ) const;

/**
 * Rebalance the database such that all the nodes contain approximately equal
 * number of records.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& adminRebalance( const AdminRebalanceRequest& request_,
                                        AdminRebalanceResponse& response_ ) const;

/**
 * Rebalance the database such that all the nodes contain approximately equal
 * number of records.
 * 
 * @param tableNames  Names of the tables to be rebalanced.  If array is empty,
 *                    all tables will be rebalanced.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse adminRebalance( const std::vector<std::string>& tableNames,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Rebalance the database such that all the nodes contain approximately equal
 * number of records.
 * 
 * @param tableNames  Names of the tables to be rebalanced.  If array is empty,
 *                    all tables will be rebalanced.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& adminRebalance( const std::vector<std::string>& tableNames,
                                        const std::map<std::string, std::string>& options,
                                        AdminRebalanceResponse& response_ ) const;

/**
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminSetShardAssignmentsResponse adminSetShardAssignments( const AdminSetShardAssignmentsRequest& request_ ) const;

/**
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminSetShardAssignmentsResponse& adminSetShardAssignments( const AdminSetShardAssignmentsRequest& request_,
                                                            AdminSetShardAssignmentsResponse& response_ ) const;

/**
 * 
 * @param version
 * @param partialReassignment
 * @param shardAssignmentsRank
 * @param shardAssignmentsTom
 * @param assignmentIndex
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminSetShardAssignmentsResponse adminSetShardAssignments( const int64_t version,
                                                           const bool partialReassignment,
                                                           const std::vector<int32_t>& shardAssignmentsRank,
                                                           const std::vector<int32_t>& shardAssignmentsTom,
                                                           const std::vector<int32_t>& assignmentIndex,
                                                           const std::map<std::string, std::string>& options ) const;

/**
 * 
 * @param version
 * @param partialReassignment
 * @param shardAssignmentsRank
 * @param shardAssignmentsTom
 * @param assignmentIndex
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminSetShardAssignmentsResponse& adminSetShardAssignments( const int64_t version,
                                                            const bool partialReassignment,
                                                            const std::vector<int32_t>& shardAssignmentsRank,
                                                            const std::vector<int32_t>& shardAssignmentsTom,
                                                            const std::vector<int32_t>& assignmentIndex,
                                                            const std::map<std::string, std::string>& options,
                                                            AdminSetShardAssignmentsResponse& response_ ) const;

/**
 * Exits the GPUdb server application. A authorization code is required (chosen
 * at the time of GPUdb configuration) to successfully complete this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse adminShutdown( const AdminShutdownRequest& request_ ) const;

/**
 * Exits the GPUdb server application. A authorization code is required (chosen
 * at the time of GPUdb configuration) to successfully complete this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& adminShutdown( const AdminShutdownRequest& request_,
                                      AdminShutdownResponse& response_ ) const;

/**
 * Exits the GPUdb server application. A authorization code is required (chosen
 * at the time of GPUdb configuration) to successfully complete this request.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  The password that GPUdb is configured with during
 *                       startup. Incorrect or missing authorization code will
 *                       result in an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse adminShutdown( const std::string& exitType,
                                     const std::string& authorization,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Exits the GPUdb server application. A authorization code is required (chosen
 * at the time of GPUdb configuration) to successfully complete this request.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  The password that GPUdb is configured with during
 *                       startup. Incorrect or missing authorization code will
 *                       result in an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& adminShutdown( const std::string& exitType,
                                      const std::string& authorization,
                                      const std::map<std::string, std::string>& options,
                                      AdminShutdownResponse& response_ ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse adminVerifyDb( const AdminVerifyDbRequest& request_ ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& adminVerifyDb( const AdminVerifyDbRequest& request_,
                                      AdminVerifyDbResponse& response_ ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse adminVerifyDb( const std::map<std::string, std::string>& options ) const;

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& adminVerifyDb( const std::map<std::string, std::string>& options,
                                      AdminVerifyDbResponse& response_ ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse aggregateConvexHull( const AggregateConvexHullRequest& request_ ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& aggregateConvexHull( const AggregateConvexHullRequest& request_,
                                                  AggregateConvexHullResponse& response_ ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of Table on which the operation will be performed.
 *                   Must be a valid table in GPUdb.  It can not be a
 *                   collection.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse aggregateConvexHull( const std::string& tableName,
                                                 const std::string& xColumnName,
                                                 const std::string& yColumnName,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of Table on which the operation will be performed.
 *                   Must be a valid table in GPUdb.  It can not be a
 *                   collection.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& aggregateConvexHull( const std::string& tableName,
                                                  const std::string& xColumnName,
                                                  const std::string& yColumnName,
                                                  const std::map<std::string, std::string>& options,
                                                  AggregateConvexHullResponse& response_ ) const;

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateGroupByResponse aggregateGroupByRaw( const AggregateGroupByRequest& request_ ) const;

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateGroupByResponse& aggregateGroupByRaw( const AggregateGroupByRequest& request_,
                                                  RawAggregateGroupByResponse& response_ ) const;

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse aggregateGroupBy( const AggregateGroupByRequest& request_ ) const;

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& aggregateGroupBy( const AggregateGroupByRequest& request_,
                                            AggregateGroupByResponse& response_ ) const;

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table/view/collection in GPUdb.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions. Must include at least one
 *                     'grouping' column or expression.  If no aggregate is
 *                     included, count(*) will be computed as a default.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 1000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse aggregateGroupBy( const std::string& tableName,
                                           const std::vector<std::string>& columnNames,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table/view/collection in GPUdb.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions. Must include at least one
 *                     'grouping' column or expression.  If no aggregate is
 *                     included, count(*) will be computed as a default.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 1000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& aggregateGroupBy( const std::string& tableName,
                                            const std::vector<std::string>& columnNames,
                                            const int64_t offset,
                                            const int64_t limit,
                                            const std::map<std::string, std::string>& options,
                                            AggregateGroupByResponse& response_ ) const;

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is exclusive--
 * except for the very last bin for which the end value is also inclusive.  The
 * value returned for each bin is the number of records in it, except when a
 * column name is provided as a *value_column* in @a options.  In this latter
 * case the sum of the values corresponding to the *value_column* is used as
 * the result instead.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse aggregateHistogram( const AggregateHistogramRequest& request_ ) const;

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is exclusive--
 * except for the very last bin for which the end value is also inclusive.  The
 * value returned for each bin is the number of records in it, except when a
 * column name is provided as a *value_column* in @a options.  In this latter
 * case the sum of the values corresponding to the *value_column* is used as
 * the result instead.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& aggregateHistogram( const AggregateHistogramRequest& request_,
                                                AggregateHistogramResponse& response_ ) const;

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is exclusive--
 * except for the very last bin for which the end value is also inclusive.  The
 * value returned for each bin is the number of records in it, except when a
 * column name is provided as a *value_column* in @a options.  In this latter
 * case the sum of the values corresponding to the *value_column* is used as
 * the result instead.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse aggregateHistogram( const std::string& tableName,
                                               const std::string& columnName,
                                               const double start,
                                               const double end,
                                               const double interval,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is exclusive--
 * except for the very last bin for which the end value is also inclusive.  The
 * value returned for each bin is the number of records in it, except when a
 * column name is provided as a *value_column* in @a options.  In this latter
 * case the sum of the values corresponding to the *value_column* is used as
 * the result instead.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& aggregateHistogram( const std::string& tableName,
                                                const std::string& columnName,
                                                const double start,
                                                const double end,
                                                const double interval,
                                                const std::map<std::string, std::string>& options,
                                                AggregateHistogramResponse& response_ ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse aggregateKMeans( const AggregateKMeansRequest& request_ ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& aggregateKMeans( const AggregateKMeansRequest& request_,
                                          AggregateKMeansResponse& response_ ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse aggregateKMeans( const std::string& tableName,
                                         const std::vector<std::string>& columnNames,
                                         const int32_t k,
                                         const double tolerance,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& aggregateKMeans( const std::string& tableName,
                                          const std::vector<std::string>& columnNames,
                                          const int32_t k,
                                          const double tolerance,
                                          const std::map<std::string, std::string>& options,
                                          AggregateKMeansResponse& response_ ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse aggregateMinMax( const AggregateMinMaxRequest& request_ ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& aggregateMinMax( const AggregateMinMaxRequest& request_,
                                          AggregateMinMaxResponse& response_ ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse aggregateMinMax( const std::string& tableName,
                                         const std::string& columnName,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& aggregateMinMax( const std::string& tableName,
                                          const std::string& columnName,
                                          const std::map<std::string, std::string>& options,
                                          AggregateMinMaxResponse& response_ ) const;

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse aggregateStatistics( const AggregateStatisticsRequest& request_ ) const;

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& aggregateStatistics( const AggregateStatisticsRequest& request_,
                                                  AggregateStatisticsResponse& response_ ) const;

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed.
 * @param columnName  Name of the column for which the statistics are to be
 *                    calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean".
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse aggregateStatistics( const std::string& tableName,
                                                 const std::string& columnName,
                                                 const std::string& stats,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed.
 * @param columnName  Name of the column for which the statistics are to be
 *                    calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean".
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& aggregateStatistics( const std::string& tableName,
                                                  const std::string& columnName,
                                                  const std::string& stats,
                                                  const std::map<std::string, std::string>& options,
                                                  AggregateStatisticsResponse& response_ ) const;

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of (max-
 * min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_ ) const;

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of (max-
 * min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_,
                                                                AggregateStatisticsByRangeResponse& response_ ) const;

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of (max-
 * min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.  Default value is an empty
 *                          string.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval``*``i,
 *                  start+interval``*``(i+1)).
 * @param options  Map of optional parameters:  Default value is an empty
 *                 std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse aggregateStatisticsByRange( const std::string& tableName,
                                                               const std::string& selectExpression,
                                                               const std::string& columnName,
                                                               const std::string& valueColumnName,
                                                               const std::string& stats,
                                                               const double start,
                                                               const double end,
                                                               const double interval,
                                                               const std::map<std::string, std::string>& options ) const;

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of (max-
 * min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.  Default value is an empty
 *                          string.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval``*``i,
 *                  start+interval``*``(i+1)).
 * @param options  Map of optional parameters:  Default value is an empty
 *                 std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& aggregateStatisticsByRange( const std::string& tableName,
                                                                const std::string& selectExpression,
                                                                const std::string& columnName,
                                                                const std::string& valueColumnName,
                                                                const std::string& stats,
                                                                const double start,
                                                                const double end,
                                                                const double interval,
                                                                const std::map<std::string, std::string>& options,
                                                                AggregateStatisticsByRangeResponse& response_ ) const;

/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateUniqueResponse aggregateUniqueRaw( const AggregateUniqueRequest& request_ ) const;

/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateUniqueResponse& aggregateUniqueRaw( const AggregateUniqueRequest& request_,
                                                RawAggregateUniqueResponse& response_ ) const;

/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse aggregateUnique( const AggregateUniqueRequest& request_ ) const;

/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& aggregateUnique( const AggregateUniqueRequest& request_,
                                          AggregateUniqueResponse& response_ ) const;

/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse aggregateUnique( const std::string& tableName,
                                         const std::string& columnName,
                                         const int64_t offset,
                                         const int64_t limit,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& aggregateUnique( const std::string& tableName,
                                          const std::string& columnName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options,
                                          AggregateUniqueResponse& response_ ) const;

/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of gpudb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse alterSystemProperties( const AlterSystemPropertiesRequest& request_ ) const;

/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of gpudb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& alterSystemProperties( const AlterSystemPropertiesRequest& request_,
                                                      AlterSystemPropertiesResponse& response_ ) const;

/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of gpudb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of gpudb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                      const std::map<std::string, std::string>& options,
                                                      AlterSystemPropertiesResponse& response_ ) const;

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Cereating or deleting an index on a particular column. This can speed
 * up certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&) const}, {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}, {@link
 * #updateRecordsRaw(const RawUpdateRecordsRequest&) const}) when using
 * expressions containing equality or relational operators on indexed columns.
 * This only applies to child tables.
 * <p>
 *      Making a table protected or not. Protected tables need the admin
 * password to be sent in a {@link
 * #clearTable(const ClearTableRequest&) const} to delete the table. This
 * can be applied to child tables or collections or views.
 * <p>
 *      Setting the ttl (time-to-live). This can be applied to child tables or
 * collections or views.
 * <p>
 *      Allowing homogeneous child tables. This only applies to collections.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse alterTable( const AlterTableRequest& request_ ) const;

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Cereating or deleting an index on a particular column. This can speed
 * up certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&,RawGetRecordsResponse&) const},
 * {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const},
 * {@link
 * #updateRecordsRaw(const RawUpdateRecordsRequest&,UpdateRecordsResponse&) const})
 * when using expressions containing equality or relational operators on
 * indexed columns. This only applies to child tables.
 * <p>
 *      Making a table protected or not. Protected tables need the admin
 * password to be sent in a {@link
 * #clearTable(const ClearTableRequest&,ClearTableResponse&) const} to
 * delete the table. This can be applied to child tables or collections or
 * views.
 * <p>
 *      Setting the ttl (time-to-live). This can be applied to child tables or
 * collections or views.
 * <p>
 *      Allowing homogeneous child tables. This only applies to collections.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& alterTable( const AlterTableRequest& request_,
                                AlterTableResponse& response_ ) const;

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Cereating or deleting an index on a particular column. This can speed
 * up certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&) const}, {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const},
 * {@link #updateRecordsRaw(const RawUpdateRecordsRequest&) const}) when
 * using expressions containing equality or relational operators on indexed
 * columns. This only applies to child tables.
 * <p>
 *      Making a table protected or not. Protected tables need the admin
 * password to be sent in a {@link
 * #clearTable(const std::string&,const std::string&,const std::map<std::string, std::string>&) const}
 * to delete the table. This can be applied to child tables or collections or
 * views.
 * <p>
 *      Setting the ttl (time-to-live). This can be applied to child tables or
 * collections or views.
 * <p>
 *      Allowing homogeneous child tables. This only applies to collections.
 * 
 * @param tableName  Table on which the operation will be performed. Must be a
 *                   valid table or collection in GPUdb.
 * @param action  Modification operation to be applied to the table or
 *                collection
 * @param value  The value of the modification. May be a column name, 'true' or
 *               'false', or a time-to-live depending on @a action.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse alterTable( const std::string& tableName,
                               const std::string& action,
                               const std::string& value,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Cereating or deleting an index on a particular column. This can speed
 * up certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&) const}, {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&,DeleteRecordsResponse&) const},
 * {@link #updateRecordsRaw(const RawUpdateRecordsRequest&) const}) when
 * using expressions containing equality or relational operators on indexed
 * columns. This only applies to child tables.
 * <p>
 *      Making a table protected or not. Protected tables need the admin
 * password to be sent in a {@link
 * #clearTable(const std::string&,const std::string&,const std::map<std::string, std::string>&,ClearTableResponse&) const}
 * to delete the table. This can be applied to child tables or collections or
 * views.
 * <p>
 *      Setting the ttl (time-to-live). This can be applied to child tables or
 * collections or views.
 * <p>
 *      Allowing homogeneous child tables. This only applies to collections.
 * 
 * @param tableName  Table on which the operation will be performed. Must be a
 *                   valid table or collection in GPUdb.
 * @param action  Modification operation to be applied to the table or
 *                collection
 * @param value  The value of the modification. May be a column name, 'true' or
 *               'false', or a time-to-live depending on @a action.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& alterTable( const std::string& tableName,
                                const std::string& action,
                                const std::string& value,
                                const std::map<std::string, std::string>& options,
                                AlterTableResponse& response_ ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse alterTableMetadata( const AlterTableMetadataRequest& request_ ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& alterTableMetadata( const AlterTableMetadataRequest& request_,
                                                AlterTableMetadataResponse& response_ ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated. All
 *                    specified tables must exist in GPUdb, or GPUdb will
 *                    return an error.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse alterTableMetadata( const std::vector<std::string>& tableNames,
                                               const std::map<std::string, std::string>& metadataMap,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated. All
 *                    specified tables must exist in GPUdb, or GPUdb will
 *                    return an error.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& alterTableMetadata( const std::vector<std::string>& tableNames,
                                                const std::map<std::string, std::string>& metadataMap,
                                                const std::map<std::string, std::string>& options,
                                                AlterTableMetadataResponse& response_ ) const;

/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared. For protected tables, this function
 * requires an administrator password without which the operation will fail.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse clearTable( const ClearTableRequest& request_ ) const;

/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared. For protected tables, this function
 * requires an administrator password without which the operation will fail.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& clearTable( const ClearTableRequest& request_,
                                ClearTableResponse& response_ ) const;

/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared. For protected tables, this function
 * requires an administrator password without which the operation will fail.
 * 
 * @param tableName  Name of the table to be cleared. Must be an existing GPUdb
 *                   table. Empty string clears all available tables in GPUdb.
 *                   Default value is an empty string.
 * @param authorization  Administrator password needed for clearing protected
 *                       tables. For unprotected tables the string can be left
 *                       blank.  Default value is an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse clearTable( const std::string& tableName,
                               const std::string& authorization,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared. For protected tables, this function
 * requires an administrator password without which the operation will fail.
 * 
 * @param tableName  Name of the table to be cleared. Must be an existing GPUdb
 *                   table. Empty string clears all available tables in GPUdb.
 *                   Default value is an empty string.
 * @param authorization  Administrator password needed for clearing protected
 *                       tables. For unprotected tables the string can be left
 *                       blank.  Default value is an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& clearTable( const std::string& tableName,
                                const std::string& authorization,
                                const std::map<std::string, std::string>& options,
                                ClearTableResponse& response_ ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse clearTableMonitor( const ClearTableMonitorRequest& request_ ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&,CreateTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& clearTableMonitor( const ClearTableMonitorRequest& request_,
                                              ClearTableMonitorResponse& response_ ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse clearTableMonitor( const std::string& topicId,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&,CreateTableMonitorResponse&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& clearTableMonitor( const std::string& topicId,
                                              const std::map<std::string, std::string>& options,
                                              ClearTableMonitorResponse& response_ ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse clearTrigger( const ClearTriggerRequest& request_ ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& clearTrigger( const ClearTriggerRequest& request_,
                                    ClearTriggerResponse& response_ ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse clearTrigger( const std::string& triggerId,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& clearTrigger( const std::string& triggerId,
                                    const std::map<std::string, std::string>& options,
                                    ClearTriggerResponse& response_ ) const;

/**
 * Creates a joint_table which is a list of tables and aliases for those
 * tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse createJoinTable( const CreateJoinTableRequest& request_ ) const;

/**
 * Creates a joint_table which is a list of tables and aliases for those
 * tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& createJoinTable( const CreateJoinTableRequest& request_,
                                          CreateJoinTableResponse& response_ ) const;

/**
 * Creates a joint_table which is a list of tables and aliases for those
 * tables.
 * 
 * @param joinTableName  Name of the join_table to be created. Must not be the
 *                       name of a currently existing GPUdb table or
 *                       join_table. Cannot be an empty string.
 * @param tableNames  The list of table names making up the joined set.
 *                    Corresponds to SQL statement from clause
 * @param aliases  The list of aliases for each of the corresponding tables.
 * @param expression  An optional expression GPUdb uses to filter the join-
 *                    table being created.  Corresponds to SQL select statement
 *                    where clause. For details see <a
 *                    href="../../concepts/index.html#expressions"
 *                    target="_top">concepts</a>.  Default value is an empty
 *                    string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse createJoinTable( const std::string& joinTableName,
                                         const std::vector<std::string>& tableNames,
                                         const std::vector<std::string>& aliases,
                                         const std::string& expression,
                                         const std::map<std::string, std::string>& options ) const;

/**
 * Creates a joint_table which is a list of tables and aliases for those
 * tables.
 * 
 * @param joinTableName  Name of the join_table to be created. Must not be the
 *                       name of a currently existing GPUdb table or
 *                       join_table. Cannot be an empty string.
 * @param tableNames  The list of table names making up the joined set.
 *                    Corresponds to SQL statement from clause
 * @param aliases  The list of aliases for each of the corresponding tables.
 * @param expression  An optional expression GPUdb uses to filter the join-
 *                    table being created.  Corresponds to SQL select statement
 *                    where clause. For details see <a
 *                    href="../../concepts/index.html#expressions"
 *                    target="_top">concepts</a>.  Default value is an empty
 *                    string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& createJoinTable( const std::string& joinTableName,
                                          const std::vector<std::string>& tableNames,
                                          const std::vector<std::string>& aliases,
                                          const std::string& expression,
                                          const std::map<std::string, std::string>& options,
                                          CreateJoinTableResponse& response_ ) const;

/**
 * Creates a new table or collection in GPUdb. If a new table is being created
 * then type of the table is given by @a typeId which must the be the type id
 * of a currently registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&) const}). The table will be created
 * inside a collection if the option *collection_name* is specified. If that
 * collection does not already exist then it will be created. To create a new,
 * empty collection specify the collection name in @a tableName, leave @a
 * typeId blank, and set the *is_collection* option to 'true'.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse createTable( const CreateTableRequest& request_ ) const;

/**
 * Creates a new table or collection in GPUdb. If a new table is being created
 * then type of the table is given by @a typeId which must the be the type id
 * of a currently registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&,CreateTypeResponse&) const}). The
 * table will be created inside a collection if the option *collection_name* is
 * specified. If that collection does not already exist then it will be
 * created. To create a new, empty collection specify the collection name in @a
 * tableName, leave @a typeId blank, and set the *is_collection* option to
 * 'true'.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& createTable( const CreateTableRequest& request_,
                                  CreateTableResponse& response_ ) const;

/**
 * Creates a new table or collection in GPUdb. If a new table is being created
 * then type of the table is given by @a typeId which must the be the type id
 * of a currently registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const}).
 * The table will be created inside a collection if the option
 * *collection_name* is specified. If that collection does not already exist
 * then it will be created. To create a new, empty collection specify the
 * collection name in @a tableName, leave @a typeId blank, and set the
 * *is_collection* option to 'true'.
 * 
 * @param tableName  Name of the table to be created. Must not be the name of a
 *                   currently existing GPUdb table of a different type.  Error
 *                   for requests with existing table of the same name and type
 *                   id may be suppressed by using the @a no_error_if_exists
 *                   option.  Cannot be an empty string.  Valid characters are
 *                   'A-Za-z0-9_-(){}[] .:' (excluding the single quote), with
 *                   the first character being one of 'A-Za-z0-9_'.  The
 *                   maximum length is 256 characters.
 * @param typeId  ID of a currently registered type in GPUdb. All objects added
 *                to the newly created table will be of this type.  Must be an
 *                empty string if the *is_collection* is 'true'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse createTable( const std::string& tableName,
                                 const std::string& typeId,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new table or collection in GPUdb. If a new table is being created
 * then type of the table is given by @a typeId which must the be the type id
 * of a currently registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,CreateTypeResponse&) const}).
 * The table will be created inside a collection if the option
 * *collection_name* is specified. If that collection does not already exist
 * then it will be created. To create a new, empty collection specify the
 * collection name in @a tableName, leave @a typeId blank, and set the
 * *is_collection* option to 'true'.
 * 
 * @param tableName  Name of the table to be created. Must not be the name of a
 *                   currently existing GPUdb table of a different type.  Error
 *                   for requests with existing table of the same name and type
 *                   id may be suppressed by using the @a no_error_if_exists
 *                   option.  Cannot be an empty string.  Valid characters are
 *                   'A-Za-z0-9_-(){}[] .:' (excluding the single quote), with
 *                   the first character being one of 'A-Za-z0-9_'.  The
 *                   maximum length is 256 characters.
 * @param typeId  ID of a currently registered type in GPUdb. All objects added
 *                to the newly created table will be of this type.  Must be an
 *                empty string if the *is_collection* is 'true'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& createTable( const std::string& tableName,
                                  const std::string& typeId,
                                  const std::map<std::string, std::string>& options,
                                  CreateTableResponse& response_ ) const;

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const ClearTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse createTableMonitor( const CreateTableMonitorRequest& request_ ) const;

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const ClearTableMonitorRequest&,ClearTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& createTableMonitor( const CreateTableMonitorRequest& request_,
                                                CreateTableMonitorResponse& response_ ) const;

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param tableName  Name of the table to monitor. Must not refer to a
 *                   collection.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse createTableMonitor( const std::string& tableName,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&,ClearTableMonitorResponse&) const}.
 * 
 * @param tableName  Name of the table to monitor. Must not refer to a
 *                   collection.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& createTableMonitor( const std::string& tableName,
                                                const std::map<std::string, std::string>& options,
                                                CreateTableMonitorResponse& response_ ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&) const}.) Once
 * the trigger has been activated, any record added to the listed tables(s) via
 * {@link #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&) const}-for any
 * listening client to collect. Active triggers can be cancelled by using the
 * {@link #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse createTriggerByArea( const CreateTriggerByAreaRequest& request_ ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the chosen columns' values falling within the specified region will
 * trip the trigger. All such records will be queued at GPUdb's trigger port-by
 * default '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& createTriggerByArea( const CreateTriggerByAreaRequest& request_,
                                                  CreateTriggerByAreaResponse& response_ ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * columns' values falling within the specified region will trip the trigger.
 * All such records will be queued at GPUdb's trigger port-by default '9001'
 * but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger to be activated.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse createTriggerByArea( const std::string& requestId,
                                                 const std::vector<std::string>& tableNames,
                                                 const std::string& xColumnName,
                                                 const std::vector<double>& xVector,
                                                 const std::string& yColumnName,
                                                 const std::vector<double>& yVector,
                                                 const std::map<std::string, std::string>& options ) const;

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * columns' values falling within the specified region will trip the trigger.
 * All such records will be queued at GPUdb's trigger port-by default '9001'
 * but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger to be activated.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& createTriggerByArea( const std::string& requestId,
                                                  const std::vector<std::string>& tableNames,
                                                  const std::string& xColumnName,
                                                  const std::vector<double>& xVector,
                                                  const std::string& yColumnName,
                                                  const std::vector<double>& yVector,
                                                  const std::map<std::string, std::string>& options,
                                                  CreateTriggerByAreaResponse& response_ ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&) const}-for any
 * listening client to collect. Active triggers can be cancelled by using the
 * {@link #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse createTriggerByRange( const CreateTriggerByRangeRequest& request_ ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the chosen column_name's value falling within the specified range will
 * trip the trigger. All such records will be queued at GPUdb's trigger port-by
 * default '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& createTriggerByRange( const CreateTriggerByRangeRequest& request_,
                                                    CreateTriggerByRangeResponse& response_ ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger request.
 * @param tableNames  Tables on which the trigger will be active.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse createTriggerByRange( const std::string& requestId,
                                                   const std::vector<std::string>& tableNames,
                                                   const std::string& columnName,
                                                   const double min,
                                                   const double max,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger request.
 * @param tableNames  Tables on which the trigger will be active.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& createTriggerByRange( const std::string& requestId,
                                                    const std::vector<std::string>& tableNames,
                                                    const std::string& columnName,
                                                    const double min,
                                                    const double max,
                                                    const std::map<std::string, std::string>& options,
                                                    CreateTriggerByRangeResponse& response_ ) const;

/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary keys that match existing objects will either
 * overwrite (i.e. update) the existing object or will be skipped and not added
 * into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse createType( const CreateTypeRequest& request_ ) const;

/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const
 * inserting} data into a table with a primary key, depending on the parameters
 * in the request, incoming objects with primary keys that match existing
 * objects will either overwrite (i.e. update) the existing object or will be
 * skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& createType( const CreateTypeRequest& request_,
                                CreateTypeResponse& response_ ) const;

/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary keys that match existing objects will either
 * overwrite (i.e. update) the existing object or will be skipped and not added
 * into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).  Default value is an empty std::map.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse createType( const std::string& typeDefinition,
                               const std::string& label,
                               const std::map<std::string, std::vector<std::string> >& properties,
                               const std::map<std::string, std::string>& options ) const;

/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary keys that match existing objects will either
 * overwrite (i.e. update) the existing object or will be skipped and not added
 * into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).  Default value is an empty std::map.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& createType( const std::string& typeDefinition,
                                const std::string& label,
                                const std::map<std::string, std::vector<std::string> >& properties,
                                const std::map<std::string, std::string>& options,
                                CreateTypeResponse& response_ ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * optiona.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse deleteRecords( const DeleteRecordsRequest& request_ ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * optiona.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& deleteRecords( const DeleteRecordsRequest& request_,
                                      DeleteRecordsResponse& response_ ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * optiona.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records. The set
 *                   must be a currently existing table and not a collection or
 *                   a view.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided /filter.
 *                     Specifying one or more @a expressions is mutually
 *                     exclusive to specifying @a record_id in the @a options.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse deleteRecords( const std::string& tableName,
                                     const std::vector<std::string>& expressions,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * optiona.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records. The set
 *                   must be a currently existing table and not a collection or
 *                   a view.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided /filter.
 *                     Specifying one or more @a expressions is mutually
 *                     exclusive to specifying @a record_id in the @a options.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& deleteRecords( const std::string& tableName,
                                      const std::vector<std::string>& expressions,
                                      const std::map<std::string, std::string>& options,
                                      DeleteRecordsResponse& response_ ) const;

/**
 * Executes a proc in the GPUdb Node.js proc server.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse executeProc( const ExecuteProcRequest& request_ ) const;

/**
 * Executes a proc in the GPUdb Node.js proc server.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& executeProc( const ExecuteProcRequest& request_,
                                  ExecuteProcResponse& response_ ) const;

/**
 * Executes a proc in the GPUdb Node.js proc server.
 * 
 * @param name  Name of the proc to execute.
 * @param params  A map containing string parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.
 * @param binParams  A map containing binary parameters to pass to the proc.
 *                   Each key/value pair specifies the name of a parameter and
 *                   its value.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse executeProc( const std::string& name,
                                 const std::map<std::string, std::string>& params,
                                 const std::map<std::string, std::vector<uint8_t> >& binParams,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Executes a proc in the GPUdb Node.js proc server.
 * 
 * @param name  Name of the proc to execute.
 * @param params  A map containing string parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.
 * @param binParams  A map containing binary parameters to pass to the proc.
 *                   Each key/value pair specifies the name of a parameter and
 *                   its value.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& executeProc( const std::string& name,
                                  const std::map<std::string, std::string>& params,
                                  const std::map<std::string, std::vector<uint8_t> >& binParams,
                                  const std::map<std::string, std::string>& options,
                                  ExecuteProcResponse& response_ ) const;

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse filter( const FilterRequest& request_ ) const;

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& filter( const FilterRequest& request_,
                        FilterResponse& response_ ) const;

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view .  Default value is an empty
 *                  string.
 * @param expression  The select expression GPUdb uses to filter the specified
 *                    table.  For details see <a
 *                    href="../../concepts/index.html#expressions"
 *                    target="_top">concepts</a>.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse filter( const std::string& tableName,
                       const std::string& viewName,
                       const std::string& expression,
                       const std::map<std::string, std::string>& options ) const;

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view .  Default value is an empty
 *                  string.
 * @param expression  The select expression GPUdb uses to filter the specified
 *                    table.  For details see <a
 *                    href="../../concepts/index.html#expressions"
 *                    target="_top">concepts</a>.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& filter( const std::string& tableName,
                        const std::string& viewName,
                        const std::string& expression,
                        const std::map<std::string, std::string>& options,
                        FilterResponse& response_ ) const;

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse filterByArea( const FilterByAreaRequest& request_ ) const;

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& filterByArea( const FilterByAreaRequest& request_,
                                    FilterByAreaResponse& response_ ) const;

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table or a view (when chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse filterByArea( const std::string& tableName,
                                   const std::string& viewName,
                                   const std::string& xColumnName,
                                   const std::vector<double>& xVector,
                                   const std::string& yColumnName,
                                   const std::vector<double>& yVector,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table or a view (when chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& filterByArea( const std::string& tableName,
                                    const std::string& viewName,
                                    const std::string& xColumnName,
                                    const std::vector<double>& xVector,
                                    const std::string& yColumnName,
                                    const std::vector<double>& yVector,
                                    const std::map<std::string, std::string>& options,
                                    FilterByAreaResponse& response_ ) const;

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse filterByBox( const FilterByBoxRequest& request_ ) const;

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& filterByBox( const FilterByBoxRequest& request_,
                                  FilterByBoxResponse& response_ ) const;

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be a valid table in GPUdb.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Must not be an already
 *                  existing collection, table or view in GPUdb.  Default value
 *                  is an empty string.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse filterByBox( const std::string& tableName,
                                 const std::string& viewName,
                                 const std::string& xColumnName,
                                 const double minX,
                                 const double maxX,
                                 const std::string& yColumnName,
                                 const double minY,
                                 const double maxY,
                                 const std::map<std::string, std::string>& options ) const;

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be a valid table in GPUdb.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Must not be an already
 *                  existing collection, table or view in GPUdb.  Default value
 *                  is an empty string.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& filterByBox( const std::string& tableName,
                                  const std::string& viewName,
                                  const std::string& xColumnName,
                                  const double minX,
                                  const double maxX,
                                  const std::string& yColumnName,
                                  const double minY,
                                  const double maxY,
                                  const std::map<std::string, std::string>& options,
                                  FilterByBoxResponse& response_ ) const;

/**
 * Applies a geometry filter against a spatial column in a given table,
 * collection or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse filterByGeometry( const FilterByGeometryRequest& request_ ) const;

/**
 * Applies a geometry filter against a spatial column in a given table,
 * collection or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& filterByGeometry( const FilterByGeometryRequest& request_,
                                            FilterByGeometryResponse& response_ ) const;

/**
 * Applies a geometry filter against a spatial column in a given table,
 * collection or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by spatial operation
 *                   will be performed.  Must be an existing table, collection
 *                   or view in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column to be used in the filter. Must be a
 *                    spatial column. Typically this will be 'WKT'
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName  Default value is an empty string.
 * @param operation  The geometric filtering operation to perform
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse filterByGeometry( const std::string& tableName,
                                           const std::string& viewName,
                                           const std::string& columnName,
                                           const std::string& inputWkt,
                                           const std::string& operation,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Applies a geometry filter against a spatial column in a given table,
 * collection or view. The filtering geometry is provided by @a inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by spatial operation
 *                   will be performed.  Must be an existing table, collection
 *                   or view in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column to be used in the filter. Must be a
 *                    spatial column. Typically this will be 'WKT'
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName  Default value is an empty string.
 * @param operation  The geometric filtering operation to perform
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& filterByGeometry( const std::string& tableName,
                                            const std::string& viewName,
                                            const std::string& columnName,
                                            const std::string& inputWkt,
                                            const std::string& operation,
                                            const std::map<std::string, std::string>& options,
                                            FilterByGeometryResponse& response_ ) const;

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse filterByList( const FilterByListRequest& request_ ) const;

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& filterByList( const FilterByListRequest& request_,
                                    FilterByListResponse& response_ ) const;

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse filterByList( const std::string& tableName,
                                   const std::string& viewName,
                                   const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& filterByList( const std::string& tableName,
                                    const std::string& viewName,
                                    const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                    const std::map<std::string, std::string>& options,
                                    FilterByListResponse& response_ ) const;

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse filterByRadius( const FilterByRadiusRequest& request_ ) const;

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& filterByRadius( const FilterByRadiusRequest& request_,
                                        FilterByRadiusResponse& response_ ) const;

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse filterByRadius( const std::string& tableName,
                                       const std::string& viewName,
                                       const std::string& xColumnName,
                                       const double xCenter,
                                       const std::string& yColumnName,
                                       const double yCenter,
                                       const double radius,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& filterByRadius( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& xColumnName,
                                        const double xCenter,
                                        const std::string& yColumnName,
                                        const double yCenter,
                                        const double radius,
                                        const std::map<std::string, std::string>& options,
                                        FilterByRadiusResponse& response_ ) const;

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse filterByRange( const FilterByRangeRequest& request_ ) const;

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& filterByRange( const FilterByRangeRequest& request_,
                                      FilterByRangeResponse& response_ ) const;

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed.  Must be a valid GPUdb table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse filterByRange( const std::string& tableName,
                                     const std::string& viewName,
                                     const std::string& columnName,
                                     const double lowerBound,
                                     const double upperBound,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed.  Must be a valid GPUdb table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& filterByRange( const std::string& tableName,
                                      const std::string& viewName,
                                      const std::string& columnName,
                                      const double lowerBound,
                                      const double upperBound,
                                      const std::map<std::string, std::string>& options,
                                      FilterByRangeResponse& response_ ) const;

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and temporal-
 * of all points of the given track. Additionally, the user can specify another
 * track to see if the two intersect (or go close to each other within the
 * specified ranges). The user also has the flexibility of using different
 * metrics for the spatial distance calculation: Euclidean (flat geometry) or
 * Great Circle (spherical geometry to approximate the Earth's surface
 * distances). The filtered points are stored in a newly created result set.
 * The return value of the function is the number of points in the resultant
 * set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse filterBySeries( const FilterBySeriesRequest& request_ ) const;

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and temporal-
 * of all points of the given track. Additionally, the user can specify another
 * track to see if the two intersect (or go close to each other within the
 * specified ranges). The user also has the flexibility of using different
 * metrics for the spatial distance calculation: Euclidean (flat geometry) or
 * Great Circle (spherical geometry to approximate the Earth's surface
 * distances). The filtered points are stored in a newly created result set.
 * The return value of the function is the number of points in the resultant
 * set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& filterBySeries( const FilterBySeriesRequest& request_,
                                        FilterBySeriesResponse& response_ ) const;

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and temporal-
 * of all points of the given track. Additionally, the user can specify another
 * track to see if the two intersect (or go close to each other within the
 * specified ranges). The user also has the flexibility of using different
 * metrics for the spatial distance calculation: Euclidean (flat geometry) or
 * Great Circle (spherical geometry to approximate the Earth's surface
 * distances). The filtered points are stored in a newly created result set.
 * The return value of the function is the number of points in the resultant
 * set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed. Must be a currently existing table with
 *                   track semantic type.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse filterBySeries( const std::string& tableName,
                                       const std::string& viewName,
                                       const std::string& trackId,
                                       const std::vector<std::string>& targetTrackIds,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and temporal-
 * of all points of the given track. Additionally, the user can specify another
 * track to see if the two intersect (or go close to each other within the
 * specified ranges). The user also has the flexibility of using different
 * metrics for the spatial distance calculation: Euclidean (flat geometry) or
 * Great Circle (spherical geometry to approximate the Earth's surface
 * distances). The filtered points are stored in a newly created result set.
 * The return value of the function is the number of points in the resultant
 * set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed. Must be a currently existing table with
 *                   track semantic type.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& filterBySeries( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& trackId,
                                        const std::vector<std::string>& targetTrackIds,
                                        const std::map<std::string, std::string>& options,
                                        FilterBySeriesResponse& response_ ) const;

/**
 * Calculates which objects from a table, collection or view match a string
 * expression for the given string columns. The 'mode' may be:
 * <p>
 *     'search' for full text search query with wildcards and boolean
 * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no
 * column can be specified in @a columnNames; GPUdb will search through all
 * string columns of the table that have text search enabled. Also, the first
 * character of the regular expression cannot be a wildcard (* or ?).
 * <p>
 * * 'equals' for an exact whole-string match
 * * 'contains' for a partial substring match (not accelerated)
 * * 'starts_with' to find strings that start with the given expression (not
 * accelerated)
 * * 'regex' - to use a full regular expression search (not accelerated)
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse filterByString( const FilterByStringRequest& request_ ) const;

/**
 * Calculates which objects from a table, collection or view match a string
 * expression for the given string columns. The 'mode' may be:
 * <p>
 *     'search' for full text search query with wildcards and boolean
 * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no
 * column can be specified in @a columnNames; GPUdb will search through all
 * string columns of the table that have text search enabled. Also, the first
 * character of the regular expression cannot be a wildcard (* or ?).
 * <p>
 * * 'equals' for an exact whole-string match
 * * 'contains' for a partial substring match (not accelerated)
 * * 'starts_with' to find strings that start with the given expression (not
 * accelerated)
 * * 'regex' - to use a full regular expression search (not accelerated)
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& filterByString( const FilterByStringRequest& request_,
                                        FilterByStringResponse& response_ ) const;

/**
 * Calculates which objects from a table, collection or view match a string
 * expression for the given string columns. The 'mode' may be:
 * <p>
 *     'search' for full text search query with wildcards and boolean
 * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no
 * column can be specified in @a columnNames; GPUdb will search through all
 * string columns of the table that have text search enabled. Also, the first
 * character of the regular expression cannot be a wildcard (* or ?).
 * <p>
 * * 'equals' for an exact whole-string match
 * * 'contains' for a partial substring match (not accelerated)
 * * 'starts_with' to find strings that start with the given expression (not
 * accelerated)
 * * 'regex' - to use a full regular expression search (not accelerated)
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed.  Must be a valid GPUdb table, collection or
 *                   view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See above for details.
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for 'search' mode.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse filterByString( const std::string& tableName,
                                       const std::string& viewName,
                                       const std::string& expression,
                                       const std::string& mode,
                                       const std::vector<std::string>& columnNames,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table, collection or view match a string
 * expression for the given string columns. The 'mode' may be:
 * <p>
 *     'search' for full text search query with wildcards and boolean
 * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no
 * column can be specified in @a columnNames; GPUdb will search through all
 * string columns of the table that have text search enabled. Also, the first
 * character of the regular expression cannot be a wildcard (* or ?).
 * <p>
 * * 'equals' for an exact whole-string match
 * * 'contains' for a partial substring match (not accelerated)
 * * 'starts_with' to find strings that start with the given expression (not
 * accelerated)
 * * 'regex' - to use a full regular expression search (not accelerated)
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed.  Must be a valid GPUdb table, collection or
 *                   view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See above for details.
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for 'search' mode.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& filterByString( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& expression,
                                        const std::string& mode,
                                        const std::vector<std::string>& columnNames,
                                        const std::map<std::string, std::string>& options,
                                        FilterByStringResponse& response_ ) const;

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse filterByTable( const FilterByTableRequest& request_ ) const;

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& filterByTable( const FilterByTableRequest& request_,
                                      FilterByTableResponse& response_ ) const;

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param tableName  Name of the table whose data will be filtered. Must be an
 *                   existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName. Must be an
 *                         existing table in GPUdb.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must match the type of the
 *                               @a columnName.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse filterByTable( const std::string& tableName,
                                     const std::string& viewName,
                                     const std::string& columnName,
                                     const std::string& sourceTableName,
                                     const std::string& sourceTableColumnName,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param tableName  Name of the table whose data will be filtered. Must be an
 *                   existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName. Must be an
 *                         existing table in GPUdb.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must match the type of the
 *                               @a columnName.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& filterByTable( const std::string& tableName,
                                      const std::string& viewName,
                                      const std::string& columnName,
                                      const std::string& sourceTableName,
                                      const std::string& sourceTableColumnName,
                                      const std::map<std::string, std::string>& options,
                                      FilterByTableResponse& response_ ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse filterByValue( const FilterByValueRequest& request_ ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& filterByValue( const FilterByValueRequest& request_,
                                      FilterByValueResponse& response_ ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param tableName  Name of an existing GPUdb table on which to perform the
 *                   calculation.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.  Default value is 0.
 * @param valueStr  The string value to search for.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the filter by value would be applied.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse filterByValue( const std::string& tableName,
                                     const std::string& viewName,
                                     const bool isString,
                                     const double value,
                                     const std::string& valueStr,
                                     const std::string& columnName,
                                     const std::map<std::string, std::string>& options ) const;

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param tableName  Name of an existing GPUdb table on which to perform the
 *                   calculation.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.  Default value is 0.
 * @param valueStr  The string value to search for.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the filter by value would be applied.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& filterByValue( const std::string& tableName,
                                      const std::string& viewName,
                                      const bool isString,
                                      const double value,
                                      const std::string& valueStr,
                                      const std::string& columnName,
                                      const std::map<std::string, std::string>& options,
                                      FilterByValueResponse& response_ ) const;

/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsResponse getRecordsRaw( const GetRecordsRequest& request_ ) const;

/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsResponse& getRecordsRaw( const GetRecordsRequest& request_,
                                      RawGetRecordsResponse& response_ ) const;

/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const GetRecordsRequest& request_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const GetRecordsRequest& request_,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const std::string& tableName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const std::string& tableName,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const ::avro::ValidSchema& schema_,
                                          const GetRecordsRequest& request_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const Type& type_,
                                          const GetRecordsRequest& request_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const ::avro::ValidSchema& schema_,
                                           const GetRecordsRequest& request_,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const Type& type_,
                                           const GetRecordsRequest& request_,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const ::avro::ValidSchema& schema_,
                                          const std::string& tableName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


template<typename TResponse> 
GetRecordsResponse<TResponse> getRecords( const Type& type_,
                                          const std::string& tableName,
                                          const int64_t offset,
                                          const int64_t limit,
                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const ::avro::ValidSchema& schema_,
                                           const std::string& tableName,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


template<typename TResponse> 
GetRecordsResponse<TResponse>& getRecords( const Type& type_,
                                           const std::string& tableName,
                                           const int64_t offset,
                                           const int64_t limit,
                                           const std::map<std::string, std::string>& options,
                                           GetRecordsResponse<TResponse>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsByColumnResponse getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_ ) const;

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsByColumnResponse& getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_,
                                                      RawGetRecordsByColumnResponse& response_ ) const;

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse getRecordsByColumn( const GetRecordsByColumnRequest& request_ ) const;

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& getRecordsByColumn( const GetRecordsByColumnRequest& request_,
                                                GetRecordsByColumnResponse& response_ ) const;

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which this operation will be
 *                   performed. The table cannot be a parent set.
 * @param columnNames  The list of column values to retrieve. Columns annotated
 *                     as store only cannot be retrieved.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000). Or
 *               END_OF_column (-9999) to indicate that the max number of
 *               results should be returned.
 * @param options  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse getRecordsByColumn( const std::string& tableName,
                                               const std::vector<std::string>& columnNames,
                                               const int64_t offset,
                                               const int64_t limit,
                                               const std::map<std::string, std::string>& options ) const;

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which this operation will be
 *                   performed. The table cannot be a parent set.
 * @param columnNames  The list of column values to retrieve. Columns annotated
 *                     as store only cannot be retrieved.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000). Or
 *               END_OF_column (-9999) to indicate that the max number of
 *               results should be returned.
 * @param options  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& getRecordsByColumn( const std::string& tableName,
                                                const std::vector<std::string>& columnNames,
                                                const int64_t offset,
                                                const int64_t limit,
                                                const std::map<std::string, std::string>& options,
                                                GetRecordsByColumnResponse& response_ ) const;

/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link #getRecordsRaw(const GetRecordsRequest&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsBySeriesResponse getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_ ) const;

/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecordsRaw(const GetRecordsRequest&,RawGetRecordsResponse&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsBySeriesResponse& getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_,
                                                      RawGetRecordsBySeriesResponse& response_ ) const;

/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link #getRecords(const GetRecordsRequest&) const} this
 * returns records grouped by series/track. So if @a offset is 0 and @a limit
 * is 5 this operation would return the first 5 series/tracks in @a tableName.
 * Each series/track will be returned sorted by their TIMESTAMP column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const GetRecordsBySeriesRequest& request_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const GetRecordsRequest&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const GetRecordsBySeriesRequest& request_,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  Default value is 0. The minimum allowed value is
 *                0. The maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 *               Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const std::string& tableName,
                                                          const std::string& worldTableName,
                                                          const int32_t offset,
                                                          const int32_t limit,
                                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  Default value is 0. The minimum allowed value is
 *                0. The maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 *               Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const std::string& tableName,
                                                           const std::string& worldTableName,
                                                           const int32_t offset,
                                                           const int32_t limit,
                                                           const std::map<std::string, std::string>& options,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse());
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const GetRecordsRequest&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                          const GetRecordsBySeriesRequest& request_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const Type& type_,
                                                          const GetRecordsBySeriesRequest& request_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const GetRecordsRequest&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                           const GetRecordsBySeriesRequest& request_,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const Type& type_,
                                                           const GetRecordsBySeriesRequest& request_,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  Default value is 0. The minimum allowed value is
 *                0. The maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 *               Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                          const std::string& tableName,
                                                          const std::string& worldTableName,
                                                          const int32_t offset,
                                                          const int32_t limit,
                                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse> getRecordsBySeries( const Type& type_,
                                                          const std::string& tableName,
                                                          const std::string& worldTableName,
                                                          const int32_t offset,
                                                          const int32_t limit,
                                                          const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<TResponse> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track informaton contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const ::avro::ValidSchema&,const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&,GetRecordsResponse<TResponse>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  Default value is 0. The minimum allowed value is
 *                0. The maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 *               Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const ::avro::ValidSchema& schema_,
                                                           const std::string& tableName,
                                                           const std::string& worldTableName,
                                                           const int32_t offset,
                                                           const int32_t limit,
                                                           const std::map<std::string, std::string>& options,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(schema_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


template<typename TResponse> 
GetRecordsBySeriesResponse<TResponse>& getRecordsBySeries( const Type& type_,
                                                           const std::string& tableName,
                                                           const std::string& worldTableName,
                                                           const int32_t offset,
                                                           const int32_t limit,
                                                           const std::map<std::string, std::string>& options,
                                                           GetRecordsBySeriesResponse<TResponse>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<TResponse>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        response_.data[i_].resize(actualResponse_.listRecordsBinary[i_].size(), TResponse(type_));
        avro::decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsFromCollectionResponse getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_ ) const;

/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsFromCollectionResponse& getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_,
                                                                  RawGetRecordsFromCollectionResponse& response_ ) const;

/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing GPUdb collection or
 *                   table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const std::string& tableName,
                                                                      const int64_t offset,
                                                                      const int64_t limit,
                                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing GPUdb collection or
 *                   table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const std::string& tableName,
                                                                       const int64_t offset,
                                                                       const int64_t limit,
                                                                       const std::map<std::string, std::string>& options,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse());
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                      const GetRecordsFromCollectionRequest& request_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const Type& type_,
                                                                      const GetRecordsFromCollectionRequest& request_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                       const GetRecordsFromCollectionRequest& request_,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const Type& type_,
                                                                       const GetRecordsFromCollectionRequest& request_,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing GPUdb collection or
 *                   table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                      const std::string& tableName,
                                                                      const int64_t offset,
                                                                      const int64_t limit,
                                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection( const Type& type_,
                                                                      const std::string& tableName,
                                                                      const int64_t offset,
                                                                      const int64_t limit,
                                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<TResponse> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @tparam <TResponse>  The type of object being retrieved.
 * 
 * @param[in] schema_  Avro schema object used for decoding returned objects.
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing GPUdb collection or
 *                   table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const ::avro::ValidSchema& schema_,
                                                                       const std::string& tableName,
                                                                       const int64_t offset,
                                                                       const int64_t limit,
                                                                       const std::map<std::string, std::string>& options,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(schema_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


template<typename TResponse> 
GetRecordsFromCollectionResponse<TResponse>& getRecordsFromCollection( const Type& type_,
                                                                       const std::string& tableName,
                                                                       const int64_t offset,
                                                                       const int64_t limit,
                                                                       const std::map<std::string, std::string>& options,
                                                                       GetRecordsFromCollectionResponse<TResponse>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;
    response_.data.resize(actualResponse_.recordsBinary.size(), TResponse(type_));
    avro::decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse hasTable( const HasTableRequest& request_ ) const;

/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& hasTable( const HasTableRequest& request_,
                            HasTableResponse& response_ ) const;

/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param tableName  Name of the table to check for existence.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse hasTable( const std::string& tableName,
                           const std::map<std::string, std::string>& options ) const;

/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param tableName  Name of the table to check for existence.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& hasTable( const std::string& tableName,
                            const std::map<std::string, std::string>& options,
                            HasTableResponse& response_ ) const;

/**
 * Check the existence of a type in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse hasType( const HasTypeRequest& request_ ) const;

/**
 * Check the existence of a type in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& hasType( const HasTypeRequest& request_,
                          HasTypeResponse& response_ ) const;

/**
 * Check the existence of a type in GPUdb.
 * 
 * @param typeId  Id of the type returned by GPUdb in response to /create/type
 *                request.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse hasType( const std::string& typeId,
                         const std::map<std::string, std::string>& options ) const;

/**
 * Check the existence of a type in GPUdb.
 * 
 * @param typeId  Id of the type returned by GPUdb in response to /create/type
 *                request.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& hasType( const std::string& typeId,
                          const std::map<std::string, std::string>& options,
                          HasTypeResponse& response_ ) const;

/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * @a options can be used to customize this function's behavior. The only
 * parameter available is @a update_on_existing_pk. The value can be either
 * 'true' or 'false'. If the table has a {@link
 * #createType(const CreateTypeRequest&) const primary key} and if @a
 * update_on_existing_pk is 'true' then if any of the records being added have
 * the same primary key as existing records, the existing records are replaced
 * (i.e. *updated*) with the given records. If @a update_on_existing_pk is
 * false and if the records being added have the same primary key as existing
 * records, the given records with existing primary keys are ignored (the
 * existing records are left unchanged). It is quite possible that in this case
 * some of the given records will be inserted and some (those having existing
 * primary keys) will be ignored (or updated). If the specified table does not
 * have a primary key column then the @a update_on_existing_pk option is
 * ignored.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsResponse insertRecordsRaw( const RawInsertRecordsRequest& request_ ) const;

/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * @a options can be used to customize this function's behavior. The only
 * parameter available is @a update_on_existing_pk. The value can be either
 * 'true' or 'false'. If the table has a {@link
 * #createType(const CreateTypeRequest&,CreateTypeResponse&) const primary
 * key} and if @a update_on_existing_pk is 'true' then if any of the records
 * being added have the same primary key as existing records, the existing
 * records are replaced (i.e. *updated*) with the given records. If @a
 * update_on_existing_pk is false and if the records being added have the same
 * primary key as existing records, the given records with existing primary
 * keys are ignored (the existing records are left unchanged). It is quite
 * possible that in this case some of the given records will be inserted and
 * some (those having existing primary keys) will be ignored (or updated). If
 * the specified table does not have a primary key column then the @a
 * update_on_existing_pk option is ignored.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsResponse& insertRecordsRaw( const RawInsertRecordsRequest& request_,
                                         InsertRecordsResponse& response_ ) const;

/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * @a options can be used to customize this function's behavior. The only
 * parameter available is @a update_on_existing_pk. The value can be either
 * 'true' or 'false'. If the table has a {@link
 * #createType(const CreateTypeRequest&) const primary key} and if @a
 * update_on_existing_pk is 'true' then if any of the records being added have
 * the same primary key as existing records, the existing records are replaced
 * (i.e. *updated*) with the given records. If @a update_on_existing_pk is
 * false and if the records being added have the same primary key as existing
 * records, the given records with existing primary keys are ignored (the
 * existing records are left unchanged). It is quite possible that in this case
 * some of the given records will be inserted and some (those having existing
 * primary keys) will be ignored (or updated). If the specified table does not
 * have a primary key column then the @a update_on_existing_pk option is
 * ignored.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
InsertRecordsResponse insertRecords( const InsertRecordsRequest<TRequest>& request_ ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    avro::encode(actualRequest_.list, request_.data, this->threadCount, this->executor);
    actualRequest_.options = request_.options;
    InsertRecordsResponse actualResponse_;
    submitRequest("/insert/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * @a options can be used to customize this function's behavior. The only
 * parameter available is @a update_on_existing_pk. The value can be either
 * 'true' or 'false'. If the table has a {@link
 * #createType(const CreateTypeRequest&,CreateTypeResponse&) const primary
 * key} and if @a update_on_existing_pk is 'true' then if any of the records
 * being added have the same primary key as existing records, the existing
 * records are replaced (i.e. *updated*) with the given records. If @a
 * update_on_existing_pk is false and if the records being added have the same
 * primary key as existing records, the given records with existing primary
 * keys are ignored (the existing records are left unchanged). It is quite
 * possible that in this case some of the given records will be inserted and
 * some (those having existing primary keys) will be ignored (or updated). If
 * the specified table does not have a primary key column then the @a
 * update_on_existing_pk option is ignored.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
InsertRecordsResponse& insertRecords( const InsertRecordsRequest<TRequest>& request_,
                                      InsertRecordsResponse& response_ ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    avro::encode(actualRequest_.list, request_.data, this->threadCount, this->executor);
    actualRequest_.options = request_.options;
    submitRequest("/insert/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * @a options can be used to customize this function's behavior. The only
 * parameter available is @a update_on_existing_pk. The value can be either
 * 'true' or 'false'. If the table has a {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const
 * primary key} and if @a update_on_existing_pk is 'true' then if any of the
 * records being added have the same primary key as existing records, the
 * existing records are replaced (i.e. *updated*) with the given records. If @a
 * update_on_existing_pk is false and if the records being added have the same
 * primary key as existing records, the given records with existing primary
 * keys are ignored (the existing records are left unchanged). It is quite
 * possible that in this case some of the given records will be inserted and
 * some (those having existing primary keys) will be ignored (or updated). If
 * the specified table does not have a primary key column then the @a
 * update_on_existing_pk option is ignored.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Table to which the records are to be added. Must be an
 *                   existing table.
 * @param data  An array of binary-encoded data for the records to be added.
 *              All records must be of the same type as that of the table.
 *              Empty array if @a listEncoding is @a json.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
InsertRecordsResponse insertRecords( const std::string& tableName,
                                     const std::vector<TRequest>& data,
                                     const std::map<std::string, std::string>& options ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    avro::encode(actualRequest_.list, data, this->threadCount, this->executor);
    actualRequest_.options = options;
    InsertRecordsResponse actualResponse_;
    submitRequest("/insert/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * @a options can be used to customize this function's behavior. The only
 * parameter available is @a update_on_existing_pk. The value can be either
 * 'true' or 'false'. If the table has a {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,CreateTypeResponse&) const
 * primary key} and if @a update_on_existing_pk is 'true' then if any of the
 * records being added have the same primary key as existing records, the
 * existing records are replaced (i.e. *updated*) with the given records. If @a
 * update_on_existing_pk is false and if the records being added have the same
 * primary key as existing records, the given records with existing primary
 * keys are ignored (the existing records are left unchanged). It is quite
 * possible that in this case some of the given records will be inserted and
 * some (those having existing primary keys) will be ignored (or updated). If
 * the specified table does not have a primary key column then the @a
 * update_on_existing_pk option is ignored.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Table to which the records are to be added. Must be an
 *                   existing table.
 * @param data  An array of binary-encoded data for the records to be added.
 *              All records must be of the same type as that of the table.
 *              Empty array if @a listEncoding is @a json.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
InsertRecordsResponse& insertRecords( const std::string& tableName,
                                      const std::vector<TRequest>& data,
                                      const std::map<std::string, std::string>& options,
                                      InsertRecordsResponse& response_ ) const
{
    RawInsertRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    avro::encode(actualRequest_.list, data, this->threadCount, this->executor);
    actualRequest_.options = options;
    submitRequest("/insert/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse insertRecordsRandom( const InsertRecordsRandomRequest& request_ ) const;

/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& insertRecordsRandom( const InsertRecordsRandomRequest& request_,
                                                  InsertRecordsRandomResponse& response_ ) const;

/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param tableName  Table to which random records will be added. Must be an
 *                   existing table.  Also, must be an individual table, not a
 *                   collection of tables, nor a view of a table.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  The parameters that can be
 *                 specified are: *min*, *max*, and *interval*.  These
 *                 parameters take on different meanings depending on the type
 *                 of the column.  Below follows a more detailed description of
 *                 the map:  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse insertRecordsRandom( const std::string& tableName,
                                                 const int64_t count,
                                                 const std::map<std::string, std::map<std::string, double> >& options ) const;

/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param tableName  Table to which random records will be added. Must be an
 *                   existing table.  Also, must be an individual table, not a
 *                   collection of tables, nor a view of a table.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  The parameters that can be
 *                 specified are: *min*, *max*, and *interval*.  These
 *                 parameters take on different meanings depending on the type
 *                 of the column.  Below follows a more detailed description of
 *                 the map:  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& insertRecordsRandom( const std::string& tableName,
                                                  const int64_t count,
                                                  const std::map<std::string, std::map<std::string, double> >& options,
                                                  InsertRecordsRandomResponse& response_ ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const VisualizeImageRequest&) const}) if the
 * 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse insertSymbol( const InsertSymbolRequest& request_ ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const VisualizeImageRequest&,VisualizeImageResponse&) const})
 * if the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& insertSymbol( const InsertSymbolRequest& request_,
                                    InsertSymbolResponse& response_ ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const std::vector<std::string>&,const std::vector<std::string>&,const std::string&,const std::string&,const std::vector<std::vector<std::string> >&,const double,const double,const double,const double,const int32_t,const int32_t,const std::string&,const int64_t,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const})
 * if the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'.
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse insertSymbol( const std::string& symbolId,
                                   const std::string& symbolFormat,
                                   const std::vector<uint8_t>& symbolData,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const std::vector<std::string>&,const std::vector<std::string>&,const std::string&,const std::string&,const std::vector<std::vector<std::string> >&,const double,const double,const double,const double,const int32_t,const int32_t,const std::string&,const int64_t,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,VisualizeImageResponse&) const})
 * if the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'.
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& insertSymbol( const std::string& symbolId,
                                    const std::string& symbolFormat,
                                    const std::vector<uint8_t>& symbolData,
                                    const std::map<std::string, std::string>& options,
                                    InsertSymbolResponse& response_ ) const;

/**
 * Locks a table.  By default a table has no locks and all operations are
 * permitted.  A user may request a read-only or a write-only lock, after which
 * only read or write operations are permitted on the table until the next
 * request.  When lock_type is disable then then no operations are permitted on
 * the table.  The lock status can be queried by passing an empty string for @a
 * lockType.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse lockTable( const LockTableRequest& request_ ) const;

/**
 * Locks a table.  By default a table has no locks and all operations are
 * permitted.  A user may request a read-only or a write-only lock, after which
 * only read or write operations are permitted on the table until the next
 * request.  When lock_type is disable then then no operations are permitted on
 * the table.  The lock status can be queried by passing an empty string for @a
 * lockType.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& lockTable( const LockTableRequest& request_,
                              LockTableResponse& response_ ) const;

/**
 * Locks a table.  By default a table has no locks and all operations are
 * permitted.  A user may request a read-only or a write-only lock, after which
 * only read or write operations are permitted on the table until the next
 * request.  When lock_type is disable then then no operations are permitted on
 * the table.  The lock status can be queried by passing an empty string for @a
 * lockType.
 * 
 * @param tableName  Name of the table to be locked. It must be a currently
 *                   existing table and not a collection or a view.
 * @param lockType  The type of lock being applied to the table or blank to
 *                  query. Empty string returns the lock status without change
 *                  the lock status of the table.  Default value is an empty
 *                  string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse lockTable( const std::string& tableName,
                             const std::string& lockType,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Locks a table.  By default a table has no locks and all operations are
 * permitted.  A user may request a read-only or a write-only lock, after which
 * only read or write operations are permitted on the table until the next
 * request.  When lock_type is disable then then no operations are permitted on
 * the table.  The lock status can be queried by passing an empty string for @a
 * lockType.
 * 
 * @param tableName  Name of the table to be locked. It must be a currently
 *                   existing table and not a collection or a view.
 * @param lockType  The type of lock being applied to the table or blank to
 *                  query. Empty string returns the lock status without change
 *                  the lock status of the table.  Default value is an empty
 *                  string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& lockTable( const std::string& tableName,
                              const std::string& lockType,
                              const std::map<std::string, std::string>& options,
                              LockTableResponse& response_ ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse showSystemProperties( const ShowSystemPropertiesRequest& request_ ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& showSystemProperties( const ShowSystemPropertiesRequest& request_,
                                                    ShowSystemPropertiesResponse& response_ ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse showSystemProperties( const std::map<std::string, std::string>& options ) const;

/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& showSystemProperties( const std::map<std::string, std::string>& options,
                                                    ShowSystemPropertiesResponse& response_ ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse showSystemStatus( const ShowSystemStatusRequest& request_ ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& showSystemStatus( const ShowSystemStatusRequest& request_,
                                            ShowSystemStatusResponse& response_ ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse showSystemStatus( const std::map<std::string, std::string>& options ) const;

/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& showSystemStatus( const std::map<std::string, std::string>& options,
                                            ShowSystemStatusResponse& response_ ) const;

/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse showSystemTiming( const ShowSystemTimingRequest& request_ ) const;

/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& showSystemTiming( const ShowSystemTimingRequest& request_,
                                            ShowSystemTimingResponse& response_ ) const;

/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse showSystemTiming( const std::map<std::string, std::string>& options ) const;

/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& showSystemTiming( const std::map<std::string, std::string>& options,
                                            ShowSystemTimingResponse& response_ ) const;

/**
 * Retrieves detailed information about a particular GPUdb table, specified in
 * @a tableName. If the supplied @a tableName is a collection, the call returns
 * a list of tables contained in the collection, and for each table it returns
 * the description, type id, schema, type label, type propertiess, and
 * additional information including TTL. If @a tableName is empty it will
 * return all top-level tables including all collections and top-level child
 * tables (i.e. tables with no parent).
 * <p>
 *     If the option 'get_sizes' is set to 'true' then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 *     If the option 'show_children' is set to 'false' then for a collection it
 * only returns information about the collection itself, not about the child
 * tables. If 'show_children' is set to 'true' then it will return information
 * about each of the children.
 * <p>
 *     Running with 'show_children' = 'true' on a child table will return an
 * error.
 * <p>
 *     Running with 'show_children' = 'false' with @a tableName empty will
 * return an error.
 * <p>
 * If the requested table is blank, then information is returned about all top-
 * level tables including collections.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse showTable( const ShowTableRequest& request_ ) const;

/**
 * Retrieves detailed information about a particular GPUdb table, specified in
 * @a tableName. If the supplied @a tableName is a collection, the call returns
 * a list of tables contained in the collection, and for each table it returns
 * the description, type id, schema, type label, type propertiess, and
 * additional information including TTL. If @a tableName is empty it will
 * return all top-level tables including all collections and top-level child
 * tables (i.e. tables with no parent).
 * <p>
 *     If the option 'get_sizes' is set to 'true' then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 *     If the option 'show_children' is set to 'false' then for a collection it
 * only returns information about the collection itself, not about the child
 * tables. If 'show_children' is set to 'true' then it will return information
 * about each of the children.
 * <p>
 *     Running with 'show_children' = 'true' on a child table will return an
 * error.
 * <p>
 *     Running with 'show_children' = 'false' with @a tableName empty will
 * return an error.
 * <p>
 * If the requested table is blank, then information is returned about all top-
 * level tables including collections.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& showTable( const ShowTableRequest& request_,
                              ShowTableResponse& response_ ) const;

/**
 * Retrieves detailed information about a particular GPUdb table, specified in
 * @a tableName. If the supplied @a tableName is a collection, the call returns
 * a list of tables contained in the collection, and for each table it returns
 * the description, type id, schema, type label, type propertiess, and
 * additional information including TTL. If @a tableName is empty it will
 * return all top-level tables including all collections and top-level child
 * tables (i.e. tables with no parent).
 * <p>
 *     If the option 'get_sizes' is set to 'true' then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 *     If the option 'show_children' is set to 'false' then for a collection it
 * only returns information about the collection itself, not about the child
 * tables. If 'show_children' is set to 'true' then it will return information
 * about each of the children.
 * <p>
 *     Running with 'show_children' = 'true' on a child table will return an
 * error.
 * <p>
 *     Running with 'show_children' = 'false' with @a tableName empty will
 * return an error.
 * <p>
 * If the requested table is blank, then information is returned about all top-
 * level tables including collections.
 * 
 * @param tableName  Name of the table for which to retrieve the information.
 *                   If blank then information about all collections and top-
 *                   level tables is returned.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse showTable( const std::string& tableName,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves detailed information about a particular GPUdb table, specified in
 * @a tableName. If the supplied @a tableName is a collection, the call returns
 * a list of tables contained in the collection, and for each table it returns
 * the description, type id, schema, type label, type propertiess, and
 * additional information including TTL. If @a tableName is empty it will
 * return all top-level tables including all collections and top-level child
 * tables (i.e. tables with no parent).
 * <p>
 *     If the option 'get_sizes' is set to 'true' then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 *     If the option 'show_children' is set to 'false' then for a collection it
 * only returns information about the collection itself, not about the child
 * tables. If 'show_children' is set to 'true' then it will return information
 * about each of the children.
 * <p>
 *     Running with 'show_children' = 'true' on a child table will return an
 * error.
 * <p>
 *     Running with 'show_children' = 'false' with @a tableName empty will
 * return an error.
 * <p>
 * If the requested table is blank, then information is returned about all top-
 * level tables including collections.
 * 
 * @param tableName  Name of the table for which to retrieve the information.
 *                   If blank then information about all collections and top-
 *                   level tables is returned.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& showTable( const std::string& tableName,
                              const std::map<std::string, std::string>& options,
                              ShowTableResponse& response_ ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse showTableMetadata( const ShowTableMetadataRequest& request_ ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& showTableMetadata( const ShowTableMetadataRequest& request_,
                                              ShowTableMetadataResponse& response_ ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist in GPUdb, or GPUdb returns an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse showTableMetadata( const std::vector<std::string>& tableNames,
                                             const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist in GPUdb, or GPUdb returns an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& showTableMetadata( const std::vector<std::string>& tableNames,
                                              const std::map<std::string, std::string>& options,
                                              ShowTableMetadataResponse& response_ ) const;

/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse showTablesByType( const ShowTablesByTypeRequest& request_ ) const;

/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& showTablesByType( const ShowTablesByTypeRequest& request_,
                                            ShowTablesByTypeResponse& response_ ) const;

/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse showTablesByType( const std::string& typeId,
                                           const std::string& label,
                                           const std::map<std::string, std::string>& options ) const;

/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& showTablesByType( const std::string& typeId,
                                            const std::string& label,
                                            const std::map<std::string, std::string>& options,
                                            ShowTablesByTypeResponse& response_ ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse showTriggers( const ShowTriggersRequest& request_ ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& showTriggers( const ShowTriggersRequest& request_,
                                    ShowTriggersResponse& response_ ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param triggerIds  List of IDs of the triggers whose information to be
 *                    retrieved. Empty list means retrieve information on all
 *                    active triggers.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse showTriggers( const std::vector<std::string>& triggerIds,
                                   const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param triggerIds  List of IDs of the triggers whose information to be
 *                    retrieved. Empty list means retrieve information on all
 *                    active triggers.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& showTriggers( const std::vector<std::string>& triggerIds,
                                    const std::map<std::string, std::string>& options,
                                    ShowTriggersResponse& response_ ) const;

/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse showTypes( const ShowTypesRequest& request_ ) const;

/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& showTypes( const ShowTypesRequest& request_,
                              ShowTypesResponse& response_ ) const;

/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse showTypes( const std::string& typeId,
                             const std::string& label,
                             const std::map<std::string, std::string>& options ) const;

/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& showTypes( const std::string& typeId,
                              const std::string& label,
                              const std::map<std::string, std::string>& options,
                              ShowTypesResponse& response_ ) const;

/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsResponse updateRecordsRaw( const RawUpdateRecordsRequest& request_ ) const;

/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsResponse& updateRecordsRaw( const RawUpdateRecordsRequest& request_,
                                         UpdateRecordsResponse& response_ ) const;

/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse updateRecords( const UpdateRecordsRequest<TRequest>& request_ ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    actualRequest_.expressions = request_.expressions;
    actualRequest_.newValuesMaps = request_.newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, request_.data, this->threadCount, this->executor);
    actualRequest_.options = request_.options;
    UpdateRecordsResponse actualResponse_;
    submitRequest("/update/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse& updateRecords( const UpdateRecordsRequest<TRequest>& request_,
                                      UpdateRecordsResponse& response_ ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = request_.tableName;
    actualRequest_.expressions = request_.expressions;
    actualRequest_.newValuesMaps = request_.newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, request_.data, this->threadCount, this->executor);
    actualRequest_.options = request_.options;
    submitRequest("/update/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Table to be updated. Must be a currently existing table
 *                   and not a collection or view.
 * @param expressions  A list of the actual predicates, one for each update;
 *                     format should follow the guidelines /filter.
 * @param newValuesMaps  List of new values for the matching records.  Each
 *                       element is a map with (key, value) pairs where the
 *                       keys are the names of the columns whose values are to
 *                       be updated; the values are the new values.  The number
 *                       of elements in the list should match the length of @a
 *                       expressions.
 * @param data  An *optional* list of new binary-avro encoded records to
 *              insert, one for each update.  If one of @a expressions does not
 *              yield a matching record to be updated, then the corresponding
 *              element from this list will be added to the table.  Default
 *              value is an empty std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse updateRecords( const std::string& tableName,
                                     const std::vector<std::string>& expressions,
                                     const std::vector<std::map<std::string, std::string> >& newValuesMaps,
                                     const std::vector<TRequest>& data,
                                     const std::map<std::string, std::string>& options ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.newValuesMaps = newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, data, this->threadCount, this->executor);
    actualRequest_.options = options;
    UpdateRecordsResponse actualResponse_;
    submitRequest("/update/records", actualRequest_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @tparam <TRequest>  The type of object being added.
 * 
 * @param tableName  Table to be updated. Must be a currently existing table
 *                   and not a collection or view.
 * @param expressions  A list of the actual predicates, one for each update;
 *                     format should follow the guidelines /filter.
 * @param newValuesMaps  List of new values for the matching records.  Each
 *                       element is a map with (key, value) pairs where the
 *                       keys are the names of the columns whose values are to
 *                       be updated; the values are the new values.  The number
 *                       of elements in the list should match the length of @a
 *                       expressions.
 * @param data  An *optional* list of new binary-avro encoded records to
 *              insert, one for each update.  If one of @a expressions does not
 *              yield a matching record to be updated, then the corresponding
 *              element from this list will be added to the table.  Default
 *              value is an empty std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<typename TRequest> 
UpdateRecordsResponse& updateRecords( const std::string& tableName,
                                      const std::vector<std::string>& expressions,
                                      const std::vector<std::map<std::string, std::string> >& newValuesMaps,
                                      const std::vector<TRequest>& data,
                                      const std::map<std::string, std::string>& options,
                                      UpdateRecordsResponse& response_ ) const
{
    RawUpdateRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.newValuesMaps = newValuesMaps;
    avro::encode(actualRequest_.recordsToInsert, data, this->threadCount, this->executor);
    actualRequest_.options = options;
    submitRequest("/update/records", actualRequest_, response_, true);
    return response_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_ ) const;

/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_,
                                                      UpdateRecordsBySeriesResponse& response_ ) const;

/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed. Must be a valid view in GPUdb.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information.
 * @param viewName  Optional name of the view containing the series (tracks)
 *                  which have to be updated.  Default value is an empty
 *                  string.
 * @param reserved  Default value is an empty std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse updateRecordsBySeries( const std::string& tableName,
                                                     const std::string& worldTableName,
                                                     const std::string& viewName,
                                                     const std::vector<std::string>& reserved,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed. Must be a valid view in GPUdb.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information.
 * @param viewName  Optional name of the view containing the series (tracks)
 *                  which have to be updated.  Default value is an empty
 *                  string.
 * @param reserved  Default value is an empty std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& updateRecordsBySeries( const std::string& tableName,
                                                      const std::string& worldTableName,
                                                      const std::string& viewName,
                                                      const std::vector<std::string>& reserved,
                                                      const std::map<std::string, std::string>& options,
                                                      UpdateRecordsBySeriesResponse& response_ ) const;

/**
 * Generates rasterized image tiles for an area of interest using the given
 * tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse visualizeImage( const VisualizeImageRequest& request_ ) const;

/**
 * Generates rasterized image tiles for an area of interest using the given
 * tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& visualizeImage( const VisualizeImageRequest& request_,
                                        VisualizeImageResponse& response_ ) const;

/**
 * Generates rasterized image tiles for an area of interest using the given
 * tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * 
 * @param tableNames  Name of the table containing the data for the various
 *                    layers to be rendered.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image
 * @param styleOptions  Styling options for the image.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse visualizeImage( const std::vector<std::string>& tableNames,
                                       const std::vector<std::string>& worldTableNames,
                                       const std::string& xColumnName,
                                       const std::string& yColumnName,
                                       const std::vector<std::vector<std::string> >& trackIds,
                                       const double minX,
                                       const double maxX,
                                       const double minY,
                                       const double maxY,
                                       const int32_t width,
                                       const int32_t height,
                                       const std::string& projection,
                                       const int64_t bgColor,
                                       const std::map<std::string, std::vector<std::string> >& styleOptions,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Generates rasterized image tiles for an area of interest using the given
 * tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * 
 * @param tableNames  Name of the table containing the data for the various
 *                    layers to be rendered.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image
 * @param styleOptions  Styling options for the image.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& visualizeImage( const std::vector<std::string>& tableNames,
                                        const std::vector<std::string>& worldTableNames,
                                        const std::string& xColumnName,
                                        const std::string& yColumnName,
                                        const std::vector<std::vector<std::string> >& trackIds,
                                        const double minX,
                                        const double maxX,
                                        const double minY,
                                        const double maxY,
                                        const int32_t width,
                                        const int32_t height,
                                        const std::string& projection,
                                        const int64_t bgColor,
                                        const std::map<std::string, std::vector<std::string> >& styleOptions,
                                        const std::map<std::string, std::string>& options,
                                        VisualizeImageResponse& response_ ) const;

/**
 * Generates 'class break' rasterized image tiles for an area of interest using
 * the given tables and the provided parameters.
 * <p>
 * A class break rendering is where data from one or more GPUdb tables is
 * rasterized with styling applied on a per-class basis. GPUdb supports class
 * breaks based on one or more data columns. Distinct values (for strings) or
 * ranges (for numeric attributes) must be provided in the
 * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
 * styling parameters must be specified for each class.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_ ) const;

/**
 * Generates 'class break' rasterized image tiles for an area of interest using
 * the given tables and the provided parameters.
 * <p>
 * A class break rendering is where data from one or more GPUdb tables is
 * rasterized with styling applied on a per-class basis. GPUdb supports class
 * breaks based on one or more data columns. Distinct values (for strings) or
 * ranges (for numeric attributes) must be provided in the
 * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
 * styling parameters must be specified for each class.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_,
                                                            VisualizeImageClassbreakResponse& response_ ) const;

/**
 * Generates 'class break' rasterized image tiles for an area of interest using
 * the given tables and the provided parameters.
 * <p>
 * A class break rendering is where data from one or more GPUdb tables is
 * rasterized with styling applied on a per-class basis. GPUdb supports class
 * breaks based on one or more data columns. Distinct values (for strings) or
 * ranges (for numeric attributes) must be provided in the
 * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
 * styling parameters must be specified for each class.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param tableNames  Name of the table containing the data for the various
 *                    layers to be rendered.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param cbColumnName1  Name of the column for the first class break.
 * @param cbVals1  Comma separated list of values or ranges (e.g.
 *                 '0:5,5:10,15:30').
 * @param cbColumnName2  Optional comma seperated list of valid column names.
 *                       An empty string implies not using more than one column
 *                       for the class break. For a non-empty list, there needs
 *                       to be as many entries in the list as there are classes
 *                       for the first column (@a cbColumnName1). However, the
 *                       column names can be empty to indicate that for the
 *                       corresponding class of the first attribute, no
 *                       secondary class break will be applied. All the column
 *                       names in this list must be different from the first
 *                       column @a cbColumnName1. For example,
 *                       'col2,col3,col2'.
 * @param cbVals2  Comma separated list of []-enclosed lists of values or
 *                 ranges; e.g. '[0:5,5:10],[of,on,so],[-50:-20]'. Each square
 *                 bracket enclosed list describes the secondary classes for
 *                 the respective attribute in @a cbColumnName2 and the
 *                 respective class in @a cbColumnName1 / @a cbVals1.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image.
 * @param styleOptions  Styling options for the image.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                           const std::vector<std::string>& worldTableNames,
                                                           const std::string& xColumnName,
                                                           const std::string& yColumnName,
                                                           const std::vector<std::vector<std::string> >& trackIds,
                                                           const std::string& cbColumnName1,
                                                           const std::vector<std::string>& cbVals1,
                                                           const std::vector<std::string>& cbColumnName2,
                                                           const std::vector<std::vector<std::string> >& cbVals2,
                                                           const double minX,
                                                           const double maxX,
                                                           const double minY,
                                                           const double maxY,
                                                           const int32_t width,
                                                           const int32_t height,
                                                           const std::string& projection,
                                                           const int64_t bgColor,
                                                           const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                           const std::map<std::string, std::string>& options ) const;

/**
 * Generates 'class break' rasterized image tiles for an area of interest using
 * the given tables and the provided parameters.
 * <p>
 * A class break rendering is where data from one or more GPUdb tables is
 * rasterized with styling applied on a per-class basis. GPUdb supports class
 * breaks based on one or more data columns. Distinct values (for strings) or
 * ranges (for numeric attributes) must be provided in the
 * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
 * styling parameters must be specified for each class.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param tableNames  Name of the table containing the data for the various
 *                    layers to be rendered.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param cbColumnName1  Name of the column for the first class break.
 * @param cbVals1  Comma separated list of values or ranges (e.g.
 *                 '0:5,5:10,15:30').
 * @param cbColumnName2  Optional comma seperated list of valid column names.
 *                       An empty string implies not using more than one column
 *                       for the class break. For a non-empty list, there needs
 *                       to be as many entries in the list as there are classes
 *                       for the first column (@a cbColumnName1). However, the
 *                       column names can be empty to indicate that for the
 *                       corresponding class of the first attribute, no
 *                       secondary class break will be applied. All the column
 *                       names in this list must be different from the first
 *                       column @a cbColumnName1. For example,
 *                       'col2,col3,col2'.
 * @param cbVals2  Comma separated list of []-enclosed lists of values or
 *                 ranges; e.g. '[0:5,5:10],[of,on,so],[-50:-20]'. Each square
 *                 bracket enclosed list describes the secondary classes for
 *                 the respective attribute in @a cbColumnName2 and the
 *                 respective class in @a cbColumnName1 / @a cbVals1.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image.
 * @param styleOptions  Styling options for the image.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                            const std::vector<std::string>& worldTableNames,
                                                            const std::string& xColumnName,
                                                            const std::string& yColumnName,
                                                            const std::vector<std::vector<std::string> >& trackIds,
                                                            const std::string& cbColumnName1,
                                                            const std::vector<std::string>& cbVals1,
                                                            const std::vector<std::string>& cbColumnName2,
                                                            const std::vector<std::vector<std::string> >& cbVals2,
                                                            const double minX,
                                                            const double maxX,
                                                            const double minY,
                                                            const double maxY,
                                                            const int32_t width,
                                                            const int32_t height,
                                                            const std::string& projection,
                                                            const int64_t bgColor,
                                                            const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                            const std::map<std::string, std::string>& options,
                                                            VisualizeImageClassbreakResponse& response_ ) const;

/**
 * Generates rasterized heatmap image tiles for an area of interest using the
 * given tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The heatmap image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_ ) const;

/**
 * Generates rasterized heatmap image tiles for an area of interest using the
 * given tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The heatmap image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_,
                                                      VisualizeImageHeatmapResponse& response_ ) const;

/**
 * Generates rasterized heatmap image tiles for an area of interest using the
 * given tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The heatmap image is contained in the @a imageData field.
 * 
 * @param tableNames  Name of the table containing the data for the various
 *                    layers to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param valueColumnName
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param styleOptions  Various style related options.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                     const std::string& xColumnName,
                                                     const std::string& yColumnName,
                                                     const std::string& valueColumnName,
                                                     const double minX,
                                                     const double maxX,
                                                     const double minY,
                                                     const double maxY,
                                                     const int32_t width,
                                                     const int32_t height,
                                                     const std::string& projection,
                                                     const std::map<std::string, std::string>& styleOptions,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * Generates rasterized heatmap image tiles for an area of interest using the
 * given tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The heatmap image is contained in the @a imageData field.
 * 
 * @param tableNames  Name of the table containing the data for the various
 *                    layers to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param valueColumnName
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param styleOptions  Various style related options.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                      const std::string& xColumnName,
                                                      const std::string& yColumnName,
                                                      const std::string& valueColumnName,
                                                      const double minX,
                                                      const double maxX,
                                                      const double minY,
                                                      const double maxY,
                                                      const int32_t width,
                                                      const int32_t height,
                                                      const std::string& projection,
                                                      const std::map<std::string, std::string>& styleOptions,
                                                      const std::map<std::string, std::string>& options,
                                                      VisualizeImageHeatmapResponse& response_ ) const;

/**
 * Generates a rasterized image tile containing text labels defined by data
 * contained in the given table, suitable for overlaying onto a feature image
 * tile covering the same area (for example one generated using {@link
 * #visualizeImage(const VisualizeImageRequest&) const}).
 * <p>
 * All color values must be integers encoded in the format RRGGBB or AARRGGBB
 * (to specify the alpha value) when represented in hexadecimal; although note
 * that literal color values must be specified in base 10, not hexadecimal.
 * <p>
 * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
 * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
 * list of words defining style, variant, weight, stretch, or gravity, and SIZE
 * is a decimal number (size in points) or optionally followed by the unit
 * modifier 'px' for absolute size. All three sub-fields are optional; default
 * values will be used for omitted sub-fields. (For example, 'Helvetica Bold
 * Italic 10' specifies Helvetica, Bold and Italic, 10 points.) A substitute
 * font will be used if a requested font is not installed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse visualizeImageLabels( const VisualizeImageLabelsRequest& request_ ) const;

/**
 * Generates a rasterized image tile containing text labels defined by data
 * contained in the given table, suitable for overlaying onto a feature image
 * tile covering the same area (for example one generated using {@link
 * #visualizeImage(const VisualizeImageRequest&,VisualizeImageResponse&) const}).
 * <p>
 * All color values must be integers encoded in the format RRGGBB or AARRGGBB
 * (to specify the alpha value) when represented in hexadecimal; although note
 * that literal color values must be specified in base 10, not hexadecimal.
 * <p>
 * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
 * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
 * list of words defining style, variant, weight, stretch, or gravity, and SIZE
 * is a decimal number (size in points) or optionally followed by the unit
 * modifier 'px' for absolute size. All three sub-fields are optional; default
 * values will be used for omitted sub-fields. (For example, 'Helvetica Bold
 * Italic 10' specifies Helvetica, Bold and Italic, 10 points.) A substitute
 * font will be used if a requested font is not installed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& visualizeImageLabels( const VisualizeImageLabelsRequest& request_,
                                                    VisualizeImageLabelsResponse& response_ ) const;

/**
 * Generates a rasterized image tile containing text labels defined by data
 * contained in the given table, suitable for overlaying onto a feature image
 * tile covering the same area (for example one generated using {@link
 * #visualizeImage(const std::vector<std::string>&,const std::vector<std::string>&,const std::string&,const std::string&,const std::vector<std::vector<std::string> >&,const double,const double,const double,const double,const int32_t,const int32_t,const std::string&,const int64_t,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const}).
 * <p>
 * All color values must be integers encoded in the format RRGGBB or AARRGGBB
 * (to specify the alpha value) when represented in hexadecimal; although note
 * that literal color values must be specified in base 10, not hexadecimal.
 * <p>
 * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
 * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
 * list of words defining style, variant, weight, stretch, or gravity, and SIZE
 * is a decimal number (size in points) or optionally followed by the unit
 * modifier 'px' for absolute size. All three sub-fields are optional; default
 * values will be used for omitted sub-fields. (For example, 'Helvetica Bold
 * Italic 10' specifies Helvetica, Bold and Italic, 10 points.) A substitute
 * font will be used if a requested font is not installed.
 * 
 * @param tableName  Name of the table containing the data defining the labels
 *                   to render.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     center points of the labels.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     center points of the labels.
 * @param xOffset  Either the name of an integer column, or a single literal
 *                 integer value, defining the number of output pixels by which
 *                 the labels will be offset horizontally from their specified
 *                 x coordinates. If blank, an offset of 0 will be used.
 * @param yOffset  Either the name of an integer column, or a single literal
 *                 integer value, defining the number of output pixels by which
 *                 the labels will be offset vertically from their specified y
 *                 coordinates. If blank, an offset of 0 will be used.
 * @param textString  Either the name of a string column, or a single literal
 *                    string value (enclosed in double quotes), defining the
 *                    text for the labels.
 * @param font  Either the name of a string column, or a single literal string
 *              value (enclosed in double quotes), defining the fonts for the
 *              labels.
 * @param textColor  Either the name of an integer column, or a single literal
 *                   integer value, defining the text color for the labels. If
 *                   blank, opaque black will be used.
 * @param textAngle  Either the name of a numeric column, or a single literal
 *                   numeric value, defining the angle of clockwise rotation
 *                   (in degrees) for the labels. If blank, an angle of 0 will
 *                   be used.
 * @param textScale  Either the name of a numeric column, or a single literal
 *                   numeric value, defining the scaling factor for the labels.
 *                   (1 is normal size, 0.5 is half size, 2 is double size,
 *                   etc.) If blank, a scaling factor of 1 will be used.
 * @param drawBox  Either the name of an integer column, or a single literal
 *                 integer value, defining a Boolean flag indicating whether
 *                 boxes will be drawn around the labels. If blank, no boxes
 *                 will be drawn.
 * @param drawLeader  Either the name of an integer column, or a single literal
 *                    integer value, defining a Boolean flag indicating whether
 *                    leader lines will be drawn from the labels to points
 *                    specified using @a leaderXColumnName and @a
 *                    leaderYColumnName. If blank, no leader lines will be
 *                    drawn.
 * @param lineWidth  Either the name of a numeric column, or a single literal
 *                   numeric value, defining the line width in output pixels
 *                   for the labels' boxes and leader lines. If blank, a line
 *                   width of 1 will be used.
 * @param lineColor  Either the name of an integer column, or a single literal
 *                   integer value, defining the line color for the labels'
 *                   boxes and leader lines. If blank, opaque black will be
 *                   used.
 * @param fillColor  Either the name of an integer column, or a single literal
 *                   integer value, defining the fill color for the labels'
 *                   boxes. If blank, the boxes will not be filled.
 * @param leaderXColumnName  Name of the column containing the x coordinates of
 *                           the points to which the labels' leader lines will
 *                           be drawn. May be left blank if no leader lines are
 *                           to be drawn.
 * @param leaderYColumnName  Name of the column containing the y coordinates of
 *                           the points to which the labels' leader lines will
 *                           be drawn. May be left blank if no leader lines are
 *                           to be drawn.
 * @param minX  Lower bound for the x coordinates of labels to include in the
 *              image.
 * @param maxX  Upper bound for the x coordinates of labels to include in the
 *              image.
 * @param minY  Lower bound for the y coordinates of labels to include in the
 *              image.
 * @param maxY  Upper bound for the y coordinates of labels to include in the
 *              image.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse visualizeImageLabels( const std::string& tableName,
                                                   const std::string& xColumnName,
                                                   const std::string& yColumnName,
                                                   const std::string& xOffset,
                                                   const std::string& yOffset,
                                                   const std::string& textString,
                                                   const std::string& font,
                                                   const std::string& textColor,
                                                   const std::string& textAngle,
                                                   const std::string& textScale,
                                                   const std::string& drawBox,
                                                   const std::string& drawLeader,
                                                   const std::string& lineWidth,
                                                   const std::string& lineColor,
                                                   const std::string& fillColor,
                                                   const std::string& leaderXColumnName,
                                                   const std::string& leaderYColumnName,
                                                   const double minX,
                                                   const double maxX,
                                                   const double minY,
                                                   const double maxY,
                                                   const int32_t width,
                                                   const int32_t height,
                                                   const std::string& projection,
                                                   const std::map<std::string, std::string>& options ) const;

/**
 * Generates a rasterized image tile containing text labels defined by data
 * contained in the given table, suitable for overlaying onto a feature image
 * tile covering the same area (for example one generated using {@link
 * #visualizeImage(const std::vector<std::string>&,const std::vector<std::string>&,const std::string&,const std::string&,const std::vector<std::vector<std::string> >&,const double,const double,const double,const double,const int32_t,const int32_t,const std::string&,const int64_t,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,VisualizeImageResponse&) const}).
 * <p>
 * All color values must be integers encoded in the format RRGGBB or AARRGGBB
 * (to specify the alpha value) when represented in hexadecimal; although note
 * that literal color values must be specified in base 10, not hexadecimal.
 * <p>
 * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
 * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
 * list of words defining style, variant, weight, stretch, or gravity, and SIZE
 * is a decimal number (size in points) or optionally followed by the unit
 * modifier 'px' for absolute size. All three sub-fields are optional; default
 * values will be used for omitted sub-fields. (For example, 'Helvetica Bold
 * Italic 10' specifies Helvetica, Bold and Italic, 10 points.) A substitute
 * font will be used if a requested font is not installed.
 * 
 * @param tableName  Name of the table containing the data defining the labels
 *                   to render.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     center points of the labels.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     center points of the labels.
 * @param xOffset  Either the name of an integer column, or a single literal
 *                 integer value, defining the number of output pixels by which
 *                 the labels will be offset horizontally from their specified
 *                 x coordinates. If blank, an offset of 0 will be used.
 * @param yOffset  Either the name of an integer column, or a single literal
 *                 integer value, defining the number of output pixels by which
 *                 the labels will be offset vertically from their specified y
 *                 coordinates. If blank, an offset of 0 will be used.
 * @param textString  Either the name of a string column, or a single literal
 *                    string value (enclosed in double quotes), defining the
 *                    text for the labels.
 * @param font  Either the name of a string column, or a single literal string
 *              value (enclosed in double quotes), defining the fonts for the
 *              labels.
 * @param textColor  Either the name of an integer column, or a single literal
 *                   integer value, defining the text color for the labels. If
 *                   blank, opaque black will be used.
 * @param textAngle  Either the name of a numeric column, or a single literal
 *                   numeric value, defining the angle of clockwise rotation
 *                   (in degrees) for the labels. If blank, an angle of 0 will
 *                   be used.
 * @param textScale  Either the name of a numeric column, or a single literal
 *                   numeric value, defining the scaling factor for the labels.
 *                   (1 is normal size, 0.5 is half size, 2 is double size,
 *                   etc.) If blank, a scaling factor of 1 will be used.
 * @param drawBox  Either the name of an integer column, or a single literal
 *                 integer value, defining a Boolean flag indicating whether
 *                 boxes will be drawn around the labels. If blank, no boxes
 *                 will be drawn.
 * @param drawLeader  Either the name of an integer column, or a single literal
 *                    integer value, defining a Boolean flag indicating whether
 *                    leader lines will be drawn from the labels to points
 *                    specified using @a leaderXColumnName and @a
 *                    leaderYColumnName. If blank, no leader lines will be
 *                    drawn.
 * @param lineWidth  Either the name of a numeric column, or a single literal
 *                   numeric value, defining the line width in output pixels
 *                   for the labels' boxes and leader lines. If blank, a line
 *                   width of 1 will be used.
 * @param lineColor  Either the name of an integer column, or a single literal
 *                   integer value, defining the line color for the labels'
 *                   boxes and leader lines. If blank, opaque black will be
 *                   used.
 * @param fillColor  Either the name of an integer column, or a single literal
 *                   integer value, defining the fill color for the labels'
 *                   boxes. If blank, the boxes will not be filled.
 * @param leaderXColumnName  Name of the column containing the x coordinates of
 *                           the points to which the labels' leader lines will
 *                           be drawn. May be left blank if no leader lines are
 *                           to be drawn.
 * @param leaderYColumnName  Name of the column containing the y coordinates of
 *                           the points to which the labels' leader lines will
 *                           be drawn. May be left blank if no leader lines are
 *                           to be drawn.
 * @param minX  Lower bound for the x coordinates of labels to include in the
 *              image.
 * @param maxX  Upper bound for the x coordinates of labels to include in the
 *              image.
 * @param minY  Lower bound for the y coordinates of labels to include in the
 *              image.
 * @param maxY  Upper bound for the y coordinates of labels to include in the
 *              image.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& visualizeImageLabels( const std::string& tableName,
                                                    const std::string& xColumnName,
                                                    const std::string& yColumnName,
                                                    const std::string& xOffset,
                                                    const std::string& yOffset,
                                                    const std::string& textString,
                                                    const std::string& font,
                                                    const std::string& textColor,
                                                    const std::string& textAngle,
                                                    const std::string& textScale,
                                                    const std::string& drawBox,
                                                    const std::string& drawLeader,
                                                    const std::string& lineWidth,
                                                    const std::string& lineColor,
                                                    const std::string& fillColor,
                                                    const std::string& leaderXColumnName,
                                                    const std::string& leaderYColumnName,
                                                    const double minX,
                                                    const double maxX,
                                                    const double minY,
                                                    const double maxY,
                                                    const int32_t width,
                                                    const int32_t height,
                                                    const std::string& projection,
                                                    const std::map<std::string, std::string>& options,
                                                    VisualizeImageLabelsResponse& response_ ) const;

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoResponse visualizeVideo( const VisualizeVideoRequest& request_ ) const;

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoResponse& visualizeVideo( const VisualizeVideoRequest& request_,
                                        VisualizeVideoResponse& response_ ) const;

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param tableNames  Names of the tables containing the data for various
 *                    layers of the resulting video.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered. The number of tables should
 *                         match the number of tables in the @a tableNames
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image.
 * @param timeIntervals
 * @param videoStyle
 * @param sessionKey  User Provided session key that is later used to retrieve
 *                    the generated video from the WMS.
 * @param styleOptions  Styling options for the image.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoResponse visualizeVideo( const std::vector<std::string>& tableNames,
                                       const std::vector<std::string>& worldTableNames,
                                       const std::vector<std::vector<std::string> >& trackIds,
                                       const std::string& xColumnName,
                                       const std::string& yColumnName,
                                       const double minX,
                                       const double maxX,
                                       const double minY,
                                       const double maxY,
                                       const int32_t width,
                                       const int32_t height,
                                       const std::string& projection,
                                       const int64_t bgColor,
                                       const std::vector<std::vector<double> >& timeIntervals,
                                       const std::string& videoStyle,
                                       const std::string& sessionKey,
                                       const std::map<std::string, std::vector<std::string> >& styleOptions,
                                       const std::map<std::string, std::string>& options ) const;

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param tableNames  Names of the tables containing the data for various
 *                    layers of the resulting video.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered. The number of tables should
 *                         match the number of tables in the @a tableNames
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image.
 * @param timeIntervals
 * @param videoStyle
 * @param sessionKey  User Provided session key that is later used to retrieve
 *                    the generated video from the WMS.
 * @param styleOptions  Styling options for the image.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoResponse& visualizeVideo( const std::vector<std::string>& tableNames,
                                        const std::vector<std::string>& worldTableNames,
                                        const std::vector<std::vector<std::string> >& trackIds,
                                        const std::string& xColumnName,
                                        const std::string& yColumnName,
                                        const double minX,
                                        const double maxX,
                                        const double minY,
                                        const double maxY,
                                        const int32_t width,
                                        const int32_t height,
                                        const std::string& projection,
                                        const int64_t bgColor,
                                        const std::vector<std::vector<double> >& timeIntervals,
                                        const std::string& videoStyle,
                                        const std::string& sessionKey,
                                        const std::map<std::string, std::vector<std::string> >& styleOptions,
                                        const std::map<std::string, std::string>& options,
                                        VisualizeVideoResponse& response_ ) const;

/**
 * Creates raster heat-map images of table data based on input parameters.
 * Numerous parameters are required to call this function. Some of the
 * important parameters are the attributes of the generated images (@a
 * bg_color, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied and a user specified session key. This
 * session key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until all the images are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * <p>

 * <p>

 * The response payload provides among other things the number of frames which
 * were created by GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoHeatmapResponse visualizeVideoHeatmap( const VisualizeVideoHeatmapRequest& request_ ) const;

/**
 * Creates raster heat-map images of table data based on input parameters.
 * Numerous parameters are required to call this function. Some of the
 * important parameters are the attributes of the generated images (@a
 * bg_color, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied and a user specified session key. This
 * session key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until all the images are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * <p>

 * <p>

 * The response payload provides among other things the number of frames which
 * were created by GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoHeatmapResponse& visualizeVideoHeatmap( const VisualizeVideoHeatmapRequest& request_,
                                                      VisualizeVideoHeatmapResponse& response_ ) const;

/**
 * Creates raster heat-map images of table data based on input parameters.
 * Numerous parameters are required to call this function. Some of the
 * important parameters are the attributes of the generated images (@a
 * bg_color, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied and a user specified session key. This
 * session key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until all the images are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * <p>

 * <p>

 * The response payload provides among other things the number of frames which
 * were created by GPUdb.
 * 
 * @param tableNames  Names of the tables containing the data for various
 *                    layers of the resulting video
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param timeIntervals
 * @param width  Width of the generated video.
 * @param height  Height of the generated video.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param videoStyle
 * @param sessionKey  User Provided session key that is later used to retrieve
 *                    the generated video from the WMS.
 * @param styleOptions  Various style related options.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoHeatmapResponse visualizeVideoHeatmap( const std::vector<std::string>& tableNames,
                                                     const std::string& xColumnName,
                                                     const std::string& yColumnName,
                                                     const double minX,
                                                     const double maxX,
                                                     const double minY,
                                                     const double maxY,
                                                     const std::vector<std::vector<double> >& timeIntervals,
                                                     const int32_t width,
                                                     const int32_t height,
                                                     const std::string& projection,
                                                     const std::string& videoStyle,
                                                     const std::string& sessionKey,
                                                     const std::map<std::string, std::string>& styleOptions,
                                                     const std::map<std::string, std::string>& options ) const;

/**
 * Creates raster heat-map images of table data based on input parameters.
 * Numerous parameters are required to call this function. Some of the
 * important parameters are the attributes of the generated images (@a
 * bg_color, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied and a user specified session key. This
 * session key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until all the images are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * <p>

 * <p>

 * The response payload provides among other things the number of frames which
 * were created by GPUdb.
 * 
 * @param tableNames  Names of the tables containing the data for various
 *                    layers of the resulting video
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param timeIntervals
 * @param width  Width of the generated video.
 * @param height  Height of the generated video.
 * @param projection  Spatial Reference System (i.e. EPSG Code).  Default value
 *                    is 'PLATE_CARREE'.
 * @param videoStyle
 * @param sessionKey  User Provided session key that is later used to retrieve
 *                    the generated video from the WMS.
 * @param styleOptions  Various style related options.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoHeatmapResponse& visualizeVideoHeatmap( const std::vector<std::string>& tableNames,
                                                      const std::string& xColumnName,
                                                      const std::string& yColumnName,
                                                      const double minX,
                                                      const double maxX,
                                                      const double minY,
                                                      const double maxY,
                                                      const std::vector<std::vector<double> >& timeIntervals,
                                                      const int32_t width,
                                                      const int32_t height,
                                                      const std::string& projection,
                                                      const std::string& videoStyle,
                                                      const std::string& sessionKey,
                                                      const std::map<std::string, std::string>& styleOptions,
                                                      const std::map<std::string, std::string>& options,
                                                      VisualizeVideoHeatmapResponse& response_ ) const;
