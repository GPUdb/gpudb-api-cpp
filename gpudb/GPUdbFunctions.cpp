/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */


// GPUdb Version
const std::string GPUdb::API_VERSION( "7.0.6.0" );



/**
 * Add one or more new ranks to the Kinetica cluster. The new ranks will not
 * contain any data initially, other than replicated tables, and not be
 * assigned any shards. To rebalance data across the cluster, which includes
 * shifting some shard key assignments to newly added ranks, see {@link
 * #adminRebalance(const AdminRebalanceRequest&) const}.
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts would be an array including 172.123.45.67 in the first two
 * indices (signifying two ranks being added to host 172.123.45.67) and
 * 172.123.45.68 in the last index (signifying one rank being added to host
 * 172.123.45.67)
 * <p>
 * * @a configParams would be an array of maps, with each map corresponding to
 * the ranks being added in @a hosts. The key of each map would be the
 * configuration parameter name and the value would be the parameter's value,
 * e.g. 'rank.gpu':'1'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link #createJob(const CreateJobRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAddRanksResponse GPUdb::adminAddRanks( const AdminAddRanksRequest& request_ ) const
{
    AdminAddRanksResponse actualResponse_;
    submitRequest("/admin/add/ranks", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Add one or more new ranks to the Kinetica cluster. The new ranks will not
 * contain any data initially, other than replicated tables, and not be
 * assigned any shards. To rebalance data across the cluster, which includes
 * shifting some shard key assignments to newly added ranks, see {@link
 * #adminRebalance(const AdminRebalanceRequest&,AdminRebalanceResponse&) const}.
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts would be an array including 172.123.45.67 in the first two
 * indices (signifying two ranks being added to host 172.123.45.67) and
 * 172.123.45.68 in the last index (signifying one rank being added to host
 * 172.123.45.67)
 * <p>
 * * @a configParams would be an array of maps, with each map corresponding to
 * the ranks being added in @a hosts. The key of each map would be the
 * configuration parameter name and the value would be the parameter's value,
 * e.g. 'rank.gpu':'1'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link #createJob(const CreateJobRequest&,CreateJobResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAddRanksResponse& GPUdb::adminAddRanks( const AdminAddRanksRequest& request_,
                                             AdminAddRanksResponse& response_ ) const
{
    submitRequest("/admin/add/ranks", request_, response_, false);
    return response_;
}


/**
 * Add one or more new ranks to the Kinetica cluster. The new ranks will not
 * contain any data initially, other than replicated tables, and not be
 * assigned any shards. To rebalance data across the cluster, which includes
 * shifting some shard key assignments to newly added ranks, see {@link
 * #adminRebalance(const std::map<std::string, std::string>&) const}.
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts would be an array including 172.123.45.67 in the first two
 * indices (signifying two ranks being added to host 172.123.45.67) and
 * 172.123.45.68 in the last index (signifying one rank being added to host
 * 172.123.45.67)
 * <p>
 * * @a configParams would be an array of maps, with each map corresponding to
 * the ranks being added in @a hosts. The key of each map would be the
 * configuration parameter name and the value would be the parameter's value,
 * e.g. 'rank.gpu':'1'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param hosts  The IP address of each rank being added to the cluster. Insert
 *               one entry per rank, even if they are on the same host. The
 *               order of the hosts in the array only matters as it relates to
 *               the @a configParams.
 * @param configParams  Configuration parameters to apply to the new ranks,
 *                      e.g., which GPU to use. Configuration parameters that
 *                      start with 'rankN.', where N is the rank number, should
 *                      omit the N, as the new rank number(s) are not allocated
 *                      until the ranks are created. Each entry in this array
 *                      corresponds to the entry at the same array index in the
 *                      @a hosts. This array must either be completely empty or
 *                      have the same number of elements as the hosts array.
 *                      An empty array will result in the new ranks being set
 *                      only with default parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_dry_run: If @a true,
 *                 only validation checks will be performed. No ranks are
 *                 added.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_true
 *                         <li> gpudb::admin_add_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_ranks_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAddRanksResponse GPUdb::adminAddRanks( const std::vector<std::string>& hosts,
                                            const std::vector<std::map<std::string, std::string> >& configParams,
                                            const std::map<std::string, std::string>& options ) const
{
    AdminAddRanksRequest actualRequest_;
    actualRequest_.hosts = hosts;
    actualRequest_.configParams = configParams;
    actualRequest_.options = options;
    AdminAddRanksResponse actualResponse_;
    submitRequest("/admin/add/ranks", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Add one or more new ranks to the Kinetica cluster. The new ranks will not
 * contain any data initially, other than replicated tables, and not be
 * assigned any shards. To rebalance data across the cluster, which includes
 * shifting some shard key assignments to newly added ranks, see {@link
 * #adminRebalance(const std::map<std::string, std::string>&,AdminRebalanceResponse&) const}.
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * @a hosts would be an array including 172.123.45.67 in the first two
 * indices (signifying two ranks being added to host 172.123.45.67) and
 * 172.123.45.68 in the last index (signifying one rank being added to host
 * 172.123.45.67)
 * <p>
 * * @a configParams would be an array of maps, with each map corresponding to
 * the ranks being added in @a hosts. The key of each map would be the
 * configuration parameter name and the value would be the parameter's value,
 * e.g. 'rank.gpu':'1'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&,CreateJobResponse&) const}.
 * 
 * @param hosts  The IP address of each rank being added to the cluster. Insert
 *               one entry per rank, even if they are on the same host. The
 *               order of the hosts in the array only matters as it relates to
 *               the @a configParams.
 * @param configParams  Configuration parameters to apply to the new ranks,
 *                      e.g., which GPU to use. Configuration parameters that
 *                      start with 'rankN.', where N is the rank number, should
 *                      omit the N, as the new rank number(s) are not allocated
 *                      until the ranks are created. Each entry in this array
 *                      corresponds to the entry at the same array index in the
 *                      @a hosts. This array must either be completely empty or
 *                      have the same number of elements as the hosts array.
 *                      An empty array will result in the new ranks being set
 *                      only with default parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_dry_run: If @a true,
 *                 only validation checks will be performed. No ranks are
 *                 added.
 *                 <ul>
 *                         <li> gpudb::admin_add_ranks_true
 *                         <li> gpudb::admin_add_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_add_ranks_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAddRanksResponse& GPUdb::adminAddRanks( const std::vector<std::string>& hosts,
                                             const std::vector<std::map<std::string, std::string> >& configParams,
                                             const std::map<std::string, std::string>& options,
                                             AdminAddRanksResponse& response_ ) const
{
    AdminAddRanksRequest actualRequest_;
    actualRequest_.hosts = hosts;
    actualRequest_.configParams = configParams;
    actualRequest_.options = options;
    submitRequest("/admin/add/ranks", actualRequest_, response_, false);
    return response_;
}


/**
 * Perform the requested action on a list of one or more job(s). Based on the
 * type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See <a
 * href="../../gpudbAdmin/job_manager.html" target="_top">Job Manager</a> for
 * more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAlterJobsResponse GPUdb::adminAlterJobs( const AdminAlterJobsRequest& request_ ) const
{
    AdminAlterJobsResponse actualResponse_;
    submitRequest("/admin/alter/jobs", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Perform the requested action on a list of one or more job(s). Based on the
 * type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See <a
 * href="../../gpudbAdmin/job_manager.html" target="_top">Job Manager</a> for
 * more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAlterJobsResponse& GPUdb::adminAlterJobs( const AdminAlterJobsRequest& request_,
                                               AdminAlterJobsResponse& response_ ) const
{
    submitRequest("/admin/alter/jobs", request_, response_, false);
    return response_;
}


/**
 * Perform the requested action on a list of one or more job(s). Based on the
 * type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See <a
 * href="../../gpudbAdmin/job_manager.html" target="_top">Job Manager</a> for
 * more information.
 * 
 * @param jobIds  Jobs to be modified.
 * @param action  Action to be performed on the jobs specified by job_ids.
 *                <ul>
 *                        <li> gpudb::admin_alter_jobs_cancel
 *                </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminAlterJobsResponse GPUdb::adminAlterJobs( const std::vector<int64_t>& jobIds,
                                              const std::string& action,
                                              const std::map<std::string, std::string>& options ) const
{
    AdminAlterJobsRequest actualRequest_;
    actualRequest_.jobIds = jobIds;
    actualRequest_.action = action;
    actualRequest_.options = options;
    AdminAlterJobsResponse actualResponse_;
    submitRequest("/admin/alter/jobs", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Perform the requested action on a list of one or more job(s). Based on the
 * type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See <a
 * href="../../gpudbAdmin/job_manager.html" target="_top">Job Manager</a> for
 * more information.
 * 
 * @param jobIds  Jobs to be modified.
 * @param action  Action to be performed on the jobs specified by job_ids.
 *                <ul>
 *                        <li> gpudb::admin_alter_jobs_cancel
 *                </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminAlterJobsResponse& GPUdb::adminAlterJobs( const std::vector<int64_t>& jobIds,
                                               const std::string& action,
                                               const std::map<std::string, std::string>& options,
                                               AdminAlterJobsResponse& response_ ) const
{
    AdminAlterJobsRequest actualRequest_;
    actualRequest_.jobIds = jobIds;
    actualRequest_.action = action;
    actualRequest_.options = options;
    submitRequest("/admin/alter/jobs", actualRequest_, response_, false);
    return response_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse GPUdb::adminOffline( const AdminOfflineRequest& request_ ) const
{
    AdminOfflineResponse actualResponse_;
    submitRequest("/admin/offline", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& GPUdb::adminOffline( const AdminOfflineRequest& request_,
                                           AdminOfflineResponse& response_ ) const
{
    submitRequest("/admin/offline", request_, response_, false);
    return response_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline.
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_offline_flush_to_disk: Flush to
 *                 disk when going offline
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse GPUdb::adminOffline( const bool offline,
                                          const std::map<std::string, std::string>& options ) const
{
    AdminOfflineRequest actualRequest_;
    actualRequest_.offline = offline;
    actualRequest_.options = options;
    AdminOfflineResponse actualResponse_;
    submitRequest("/admin/offline", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline.
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_offline_flush_to_disk: Flush to
 *                 disk when going offline
 *                 <ul>
 *                         <li> gpudb::admin_offline_true
 *                         <li> gpudb::admin_offline_false
 *                 </ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& GPUdb::adminOffline( const bool offline,
                                           const std::map<std::string, std::string>& options,
                                           AdminOfflineResponse& response_ ) const
{
    AdminOfflineRequest actualRequest_;
    actualRequest_.offline = offline;
    actualRequest_.options = options;
    submitRequest("/admin/offline", actualRequest_, response_, false);
    return response_;
}


/**
 * Rebalance the cluster so that all the nodes contain approximately an equal
 * number of records.  The rebalance will also cause the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * This endpoint may take a long time to run, depending on the amount of data
 * in the system. The API call may time out if run directly.  It is recommended
 * to run this endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse GPUdb::adminRebalance( const AdminRebalanceRequest& request_ ) const
{
    AdminRebalanceResponse actualResponse_;
    submitRequest("/admin/rebalance", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Rebalance the cluster so that all the nodes contain approximately an equal
 * number of records.  The rebalance will also cause the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * This endpoint may take a long time to run, depending on the amount of data
 * in the system. The API call may time out if run directly.  It is recommended
 * to run this endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&,CreateJobResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& GPUdb::adminRebalance( const AdminRebalanceRequest& request_,
                                               AdminRebalanceResponse& response_ ) const
{
    submitRequest("/admin/rebalance", request_, response_, false);
    return response_;
}


/**
 * Rebalance the cluster so that all the nodes contain approximately an equal
 * number of records.  The rebalance will also cause the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * This endpoint may take a long time to run, depending on the amount of data
 * in the system. The API call may time out if run directly.  It is recommended
 * to run this endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_rebalance_sharded_data:
 *                 If @a true, sharded data will be rebalanced approximately
 *                 equally across the cluster. Note that for big clusters, this
 *                 data transfer could be time consuming and result in delayed
 *                 query responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li>
 *                 gpudb::admin_rebalance_rebalance_unsharded_data: If @a true,
 *                 unsharded data (data without primary keys and without shard
 *                 keys) will be rebalanced approximately equally across the
 *                 cluster. Note that for big clusters, this data transfer
 *                 could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li> gpudb::admin_rebalance_table_whitelist:
 *                 Comma-separated list of unsharded table names to rebalance.
 *                 Not applicable to sharded tables because they are always
 *                 balanced in accordance with their primary key or shard key.
 *                 Cannot be used simultaneously with @a table_blacklist.
 *                         <li> gpudb::admin_rebalance_table_blacklist:
 *                 Comma-separated list of unsharded table names to not
 *                 rebalance. Not applicable to sharded tables because they are
 *                 always balanced in accordance with their primary key or
 *                 shard key. Cannot be used simultaneously with @a
 *                 table_whitelist.
 *                         <li> gpudb::admin_rebalance_aggressiveness:
 *                 Influences how much data to send per rebalance round.  A
 *                 higher aggressiveness setting will complete the rebalance
 *                 faster.  A lower aggressiveness setting will take longer,
 *                 but allow for better interleaving between the rebalance and
 *                 other queries. Allowed values are 1 through 10.  The default
 *                 value is '1'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse GPUdb::adminRebalance( const std::map<std::string, std::string>& options ) const
{
    AdminRebalanceRequest actualRequest_;
    actualRequest_.options = options;
    AdminRebalanceResponse actualResponse_;
    submitRequest("/admin/rebalance", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Rebalance the cluster so that all the nodes contain approximately an equal
 * number of records.  The rebalance will also cause the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * This endpoint may take a long time to run, depending on the amount of data
 * in the system. The API call may time out if run directly.  It is recommended
 * to run this endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&,CreateJobResponse&) const}.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_rebalance_sharded_data:
 *                 If @a true, sharded data will be rebalanced approximately
 *                 equally across the cluster. Note that for big clusters, this
 *                 data transfer could be time consuming and result in delayed
 *                 query responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li>
 *                 gpudb::admin_rebalance_rebalance_unsharded_data: If @a true,
 *                 unsharded data (data without primary keys and without shard
 *                 keys) will be rebalanced approximately equally across the
 *                 cluster. Note that for big clusters, this data transfer
 *                 could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_rebalance_true
 *                         <li> gpudb::admin_rebalance_false
 *                 </ul>
 *                 The default value is gpudb::admin_rebalance_true.
 *                         <li> gpudb::admin_rebalance_table_whitelist:
 *                 Comma-separated list of unsharded table names to rebalance.
 *                 Not applicable to sharded tables because they are always
 *                 balanced in accordance with their primary key or shard key.
 *                 Cannot be used simultaneously with @a table_blacklist.
 *                         <li> gpudb::admin_rebalance_table_blacklist:
 *                 Comma-separated list of unsharded table names to not
 *                 rebalance. Not applicable to sharded tables because they are
 *                 always balanced in accordance with their primary key or
 *                 shard key. Cannot be used simultaneously with @a
 *                 table_whitelist.
 *                         <li> gpudb::admin_rebalance_aggressiveness:
 *                 Influences how much data to send per rebalance round.  A
 *                 higher aggressiveness setting will complete the rebalance
 *                 faster.  A lower aggressiveness setting will take longer,
 *                 but allow for better interleaving between the rebalance and
 *                 other queries. Allowed values are 1 through 10.  The default
 *                 value is '1'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& GPUdb::adminRebalance( const std::map<std::string, std::string>& options,
                                               AdminRebalanceResponse& response_ ) const
{
    AdminRebalanceRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/admin/rebalance", actualRequest_, response_, false);
    return response_;
}


/**
 * Remove one or more ranks from the cluster. All data in the ranks to be
 * removed is rebalanced to other ranks before the node is removed unless the
 * @a rebalance_sharded_data or @a rebalance_unsharded_data parameters are set
 * to @a false in the @a options.
 * <p>
 * Due to the rebalancing, this endpoint may take a long time to run, depending
 * on the amount of data in the system. The API call may time out if run
 * directly.  It is recommended to run this endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRemoveRanksResponse GPUdb::adminRemoveRanks( const AdminRemoveRanksRequest& request_ ) const
{
    AdminRemoveRanksResponse actualResponse_;
    submitRequest("/admin/remove/ranks", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Remove one or more ranks from the cluster. All data in the ranks to be
 * removed is rebalanced to other ranks before the node is removed unless the
 * @a rebalance_sharded_data or @a rebalance_unsharded_data parameters are set
 * to @a false in the @a options.
 * <p>
 * Due to the rebalancing, this endpoint may take a long time to run, depending
 * on the amount of data in the system. The API call may time out if run
 * directly.  It is recommended to run this endpoint asynchronously via {@link
 * #createJob(const CreateJobRequest&,CreateJobResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRemoveRanksResponse& GPUdb::adminRemoveRanks( const AdminRemoveRanksRequest& request_,
                                                   AdminRemoveRanksResponse& response_ ) const
{
    submitRequest("/admin/remove/ranks", request_, response_, false);
    return response_;
}


/**
 * Remove one or more ranks from the cluster. All data in the ranks to be
 * removed is rebalanced to other ranks before the node is removed unless the
 * @a rebalance_sharded_data or @a rebalance_unsharded_data parameters are set
 * to @a false in the @a options.
 * <p>
 * Due to the rebalancing, this endpoint may take a long time to run, depending
 * on the amount of data in the system. The API call may time out if run
 * directly.  It is recommended to run this endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param ranks  Rank numbers of the ranks to be removed from the cluster.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_sharded_data: When @a
 *                 true, data with primary keys or shard keys will be
 *                 rebalanced to other ranks prior to rank removal. Note that
 *                 for big clusters, this data transfer could be time consuming
 *                 and result in delayed query responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_unsharded_data: When @a
 *                 true, unsharded data (data without primary keys and without
 *                 shard keys) will be rebalanced to other ranks prior to rank
 *                 removal. Note that for big clusters, this data transfer
 *                 could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li> gpudb::admin_remove_ranks_aggressiveness:
 *                 Influences how much data to send per rebalance round, during
 *                 the rebalance portion of removing ranks.  A higher
 *                 aggressiveness setting will complete the rebalance faster.
 *                 A lower aggressiveness setting will take longer, but allow
 *                 for better interleaving between the rebalance and other
 *                 queries. Allowed values are 1 through 10.  The default value
 *                 is '1'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRemoveRanksResponse GPUdb::adminRemoveRanks( const std::vector<int32_t>& ranks,
                                                  const std::map<std::string, std::string>& options ) const
{
    AdminRemoveRanksRequest actualRequest_;
    actualRequest_.ranks = ranks;
    actualRequest_.options = options;
    AdminRemoveRanksResponse actualResponse_;
    submitRequest("/admin/remove/ranks", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Remove one or more ranks from the cluster. All data in the ranks to be
 * removed is rebalanced to other ranks before the node is removed unless the
 * @a rebalance_sharded_data or @a rebalance_unsharded_data parameters are set
 * to @a false in the @a options.
 * <p>
 * Due to the rebalancing, this endpoint may take a long time to run, depending
 * on the amount of data in the system. The API call may time out if run
 * directly.  It is recommended to run this endpoint asynchronously via {@link
 * #createJob(const std::string&,const std::string&,const std::vector<uint8_t>&,const std::string&,const std::map<std::string, std::string>&,CreateJobResponse&) const}.
 * 
 * @param ranks  Rank numbers of the ranks to be removed from the cluster.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_sharded_data: When @a
 *                 true, data with primary keys or shard keys will be
 *                 rebalanced to other ranks prior to rank removal. Note that
 *                 for big clusters, this data transfer could be time consuming
 *                 and result in delayed query responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li>
 *                 gpudb::admin_remove_ranks_rebalance_unsharded_data: When @a
 *                 true, unsharded data (data without primary keys and without
 *                 shard keys) will be rebalanced to other ranks prior to rank
 *                 removal. Note that for big clusters, this data transfer
 *                 could be time consuming and result in delayed query
 *                 responses.
 *                 <ul>
 *                         <li> gpudb::admin_remove_ranks_true
 *                         <li> gpudb::admin_remove_ranks_false
 *                 </ul>
 *                 The default value is gpudb::admin_remove_ranks_true.
 *                         <li> gpudb::admin_remove_ranks_aggressiveness:
 *                 Influences how much data to send per rebalance round, during
 *                 the rebalance portion of removing ranks.  A higher
 *                 aggressiveness setting will complete the rebalance faster.
 *                 A lower aggressiveness setting will take longer, but allow
 *                 for better interleaving between the rebalance and other
 *                 queries. Allowed values are 1 through 10.  The default value
 *                 is '1'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRemoveRanksResponse& GPUdb::adminRemoveRanks( const std::vector<int32_t>& ranks,
                                                   const std::map<std::string, std::string>& options,
                                                   AdminRemoveRanksResponse& response_ ) const
{
    AdminRemoveRanksRequest actualRequest_;
    actualRequest_.ranks = ranks;
    actualRequest_.options = options;
    submitRequest("/admin/remove/ranks", actualRequest_, response_, false);
    return response_;
}


/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowAlertsResponse GPUdb::adminShowAlerts( const AdminShowAlertsRequest& request_ ) const
{
    AdminShowAlertsResponse actualResponse_;
    submitRequestToHostManager("/admin/show/alerts", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowAlertsResponse& GPUdb::adminShowAlerts( const AdminShowAlertsRequest& request_,
                                                 AdminShowAlertsResponse& response_ ) const
{
    submitRequestToHostManager("/admin/show/alerts", request_, response_, false);
    return response_;
}


/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param numAlerts  Number of most recent alerts to request. The response will
 *                   include up to @a numAlerts depending on how many alerts
 *                   there are in the system. A value of 0 returns all stored
 *                   alerts.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowAlertsResponse GPUdb::adminShowAlerts( const int32_t numAlerts,
                                                const std::map<std::string, std::string>& options ) const
{
    AdminShowAlertsRequest actualRequest_;
    actualRequest_.numAlerts = numAlerts;
    actualRequest_.options = options;
    AdminShowAlertsResponse actualResponse_;
    submitRequestToHostManager("/admin/show/alerts", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 * 
 * @param numAlerts  Number of most recent alerts to request. The response will
 *                   include up to @a numAlerts depending on how many alerts
 *                   there are in the system. A value of 0 returns all stored
 *                   alerts.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowAlertsResponse& GPUdb::adminShowAlerts( const int32_t numAlerts,
                                                 const std::map<std::string, std::string>& options,
                                                 AdminShowAlertsResponse& response_ ) const
{
    AdminShowAlertsRequest actualRequest_;
    actualRequest_.numAlerts = numAlerts;
    actualRequest_.options = options;
    submitRequestToHostManager("/admin/show/alerts", actualRequest_, response_, false);
    return response_;
}


/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowClusterOperationsResponse GPUdb::adminShowClusterOperations( const AdminShowClusterOperationsRequest& request_ ) const
{
    AdminShowClusterOperationsResponse actualResponse_;
    submitRequest("/admin/show/cluster/operations", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowClusterOperationsResponse& GPUdb::adminShowClusterOperations( const AdminShowClusterOperationsRequest& request_,
                                                                       AdminShowClusterOperationsResponse& response_ ) const
{
    submitRequest("/admin/show/cluster/operations", request_, response_, false);
    return response_;
}


/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param historyIndex  Indicates which cluster operation to retrieve.  Use 0
 *                      for the most recent.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowClusterOperationsResponse GPUdb::adminShowClusterOperations( const int32_t historyIndex,
                                                                      const std::map<std::string, std::string>& options ) const
{
    AdminShowClusterOperationsRequest actualRequest_;
    actualRequest_.historyIndex = historyIndex;
    actualRequest_.options = options;
    AdminShowClusterOperationsResponse actualResponse_;
    submitRequest("/admin/show/cluster/operations", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by @a historyIndex.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 * 
 * @param historyIndex  Indicates which cluster operation to retrieve.  Use 0
 *                      for the most recent.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowClusterOperationsResponse& GPUdb::adminShowClusterOperations( const int32_t historyIndex,
                                                                       const std::map<std::string, std::string>& options,
                                                                       AdminShowClusterOperationsResponse& response_ ) const
{
    AdminShowClusterOperationsRequest actualRequest_;
    actualRequest_.historyIndex = historyIndex;
    actualRequest_.options = options;
    submitRequest("/admin/show/cluster/operations", actualRequest_, response_, false);
    return response_;
}


/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowJobsResponse GPUdb::adminShowJobs( const AdminShowJobsRequest& request_ ) const
{
    AdminShowJobsResponse actualResponse_;
    submitRequest("/admin/show/jobs", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowJobsResponse& GPUdb::adminShowJobs( const AdminShowJobsRequest& request_,
                                             AdminShowJobsResponse& response_ ) const
{
    submitRequest("/admin/show/jobs", request_, response_, false);
    return response_;
}


/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_show_async_jobs: If @a
 *                 true, then the completed async jobs are also included in the
 *                 response. By default, once the async jobs are completed they
 *                 are no longer included in the jobs list.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_true
 *                         <li> gpudb::admin_show_jobs_false
 *                 </ul>
 *                 The default value is gpudb::admin_show_jobs_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowJobsResponse GPUdb::adminShowJobs( const std::map<std::string, std::string>& options ) const
{
    AdminShowJobsRequest actualRequest_;
    actualRequest_.options = options;
    AdminShowJobsResponse actualResponse_;
    submitRequest("/admin/show/jobs", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Get a list of the current jobs in GPUdb.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_show_async_jobs: If @a
 *                 true, then the completed async jobs are also included in the
 *                 response. By default, once the async jobs are completed they
 *                 are no longer included in the jobs list.
 *                 <ul>
 *                         <li> gpudb::admin_show_jobs_true
 *                         <li> gpudb::admin_show_jobs_false
 *                 </ul>
 *                 The default value is gpudb::admin_show_jobs_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowJobsResponse& GPUdb::adminShowJobs( const std::map<std::string, std::string>& options,
                                             AdminShowJobsResponse& response_ ) const
{
    AdminShowJobsRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/admin/show/jobs", actualRequest_, response_, false);
    return response_;
}


/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowShardsResponse GPUdb::adminShowShards( const AdminShowShardsRequest& request_ ) const
{
    AdminShowShardsResponse actualResponse_;
    submitRequest("/admin/show/shards", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowShardsResponse& GPUdb::adminShowShards( const AdminShowShardsRequest& request_,
                                                 AdminShowShardsResponse& response_ ) const
{
    submitRequest("/admin/show/shards", request_, response_, false);
    return response_;
}


/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShowShardsResponse GPUdb::adminShowShards( const std::map<std::string, std::string>& options ) const
{
    AdminShowShardsRequest actualRequest_;
    actualRequest_.options = options;
    AdminShowShardsResponse actualResponse_;
    submitRequest("/admin/show/shards", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 * 
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShowShardsResponse& GPUdb::adminShowShards( const std::map<std::string, std::string>& options,
                                                 AdminShowShardsResponse& response_ ) const
{
    AdminShowShardsRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/admin/show/shards", actualRequest_, response_, false);
    return response_;
}


/**
 * Exits the database server application.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse GPUdb::adminShutdown( const AdminShutdownRequest& request_ ) const
{
    AdminShutdownResponse actualResponse_;
    submitRequest("/admin/shutdown", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Exits the database server application.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& GPUdb::adminShutdown( const AdminShutdownRequest& request_,
                                             AdminShutdownResponse& response_ ) const
{
    submitRequest("/admin/shutdown", request_, response_, false);
    return response_;
}


/**
 * Exits the database server application.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse GPUdb::adminShutdown( const std::string& exitType,
                                            const std::string& authorization,
                                            const std::map<std::string, std::string>& options ) const
{
    AdminShutdownRequest actualRequest_;
    actualRequest_.exitType = exitType;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    AdminShutdownResponse actualResponse_;
    submitRequest("/admin/shutdown", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Exits the database server application.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& GPUdb::adminShutdown( const std::string& exitType,
                                             const std::string& authorization,
                                             const std::map<std::string, std::string>& options,
                                             AdminShutdownResponse& response_ ) const
{
    AdminShutdownRequest actualRequest_;
    actualRequest_.exitType = exitType;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    submitRequest("/admin/shutdown", actualRequest_, response_, false);
    return response_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse GPUdb::adminVerifyDb( const AdminVerifyDbRequest& request_ ) const
{
    AdminVerifyDbResponse actualResponse_;
    submitRequest("/admin/verifydb", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& GPUdb::adminVerifyDb( const AdminVerifyDbRequest& request_,
                                             AdminVerifyDbResponse& response_ ) const
{
    submitRequest("/admin/verifydb", request_, response_, false);
    return response_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_rebuild_on_error:
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_nulls: When
 *                 enabled, verifies that null values are set to zero
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_persist:
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_concurrent_safe: When
 *                 enabled, allows this endpoint to be run safely with other
 *                 concurrent database operations. Other operations may be
 *                 slower while this is running.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_true.
 *                         <li> gpudb::admin_verify_db_verify_rank0: When
 *                 enabled, compares rank0 table meta-data against workers
 *                 meta-data
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse GPUdb::adminVerifyDb( const std::map<std::string, std::string>& options ) const
{
    AdminVerifyDbRequest actualRequest_;
    actualRequest_.options = options;
    AdminVerifyDbResponse actualResponse_;
    submitRequest("/admin/verifydb", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_rebuild_on_error:
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_nulls: When
 *                 enabled, verifies that null values are set to zero
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_verify_persist:
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                         <li> gpudb::admin_verify_db_concurrent_safe: When
 *                 enabled, allows this endpoint to be run safely with other
 *                 concurrent database operations. Other operations may be
 *                 slower while this is running.
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_true.
 *                         <li> gpudb::admin_verify_db_verify_rank0: When
 *                 enabled, compares rank0 table meta-data against workers
 *                 meta-data
 *                 <ul>
 *                         <li> gpudb::admin_verify_db_true
 *                         <li> gpudb::admin_verify_db_false
 *                 </ul>
 *                 The default value is gpudb::admin_verify_db_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& GPUdb::adminVerifyDb( const std::map<std::string, std::string>& options,
                                             AdminVerifyDbResponse& response_ ) const
{
    AdminVerifyDbRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/admin/verifydb", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse GPUdb::aggregateConvexHull( const AggregateConvexHullRequest& request_ ) const
{
    AggregateConvexHullResponse actualResponse_;
    submitRequest("/aggregate/convexhull", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& GPUdb::aggregateConvexHull( const AggregateConvexHullRequest& request_,
                                                         AggregateConvexHullResponse& response_ ) const
{
    submitRequest("/aggregate/convexhull", request_, response_, false);
    return response_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of table on which the operation will be performed.
 *                   Must be an existing table.  It cannot be a collection.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse GPUdb::aggregateConvexHull( const std::string& tableName,
                                                        const std::string& xColumnName,
                                                        const std::string& yColumnName,
                                                        const std::map<std::string, std::string>& options ) const
{
    AggregateConvexHullRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.options = options;
    AggregateConvexHullResponse actualResponse_;
    submitRequest("/aggregate/convexhull", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of table on which the operation will be performed.
 *                   Must be an existing table.  It cannot be a collection.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& GPUdb::aggregateConvexHull( const std::string& tableName,
                                                         const std::string& xColumnName,
                                                         const std::string& yColumnName,
                                                         const std::map<std::string, std::string>& options,
                                                         AggregateConvexHullResponse& response_ ) const
{
    AggregateConvexHullRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.options = options;
    submitRequest("/aggregate/convexhull", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../concepts/aggregation.html" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../concepts/aggregation.html#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../concepts/rollup.html"
 * target="_top">Rollup</a>, <a href="../../concepts/cube.html"
 * target="_top">Cube</a>, and <a href="../../concepts/grouping_sets.html"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../concepts/pivot.html"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateGroupByResponse GPUdb::aggregateGroupByRaw( const AggregateGroupByRequest& request_ ) const
{
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../concepts/aggregation.html" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../concepts/aggregation.html#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../concepts/rollup.html"
 * target="_top">Rollup</a>, <a href="../../concepts/cube.html"
 * target="_top">Cube</a>, and <a href="../../concepts/grouping_sets.html"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../concepts/pivot.html"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateGroupByResponse& GPUdb::aggregateGroupByRaw( const AggregateGroupByRequest& request_,
                                                         RawAggregateGroupByResponse& response_ ) const
{
    submitRequest("/aggregate/groupby", request_, response_, false);
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../concepts/aggregation.html" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../concepts/aggregation.html#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../concepts/rollup.html"
 * target="_top">Rollup</a>, <a href="../../concepts/cube.html"
 * target="_top">Cube</a>, and <a href="../../concepts/grouping_sets.html"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../concepts/pivot.html"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse GPUdb::aggregateGroupBy( const AggregateGroupByRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", request_, actualResponse_, false);
    AggregateGroupByResponse response_;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../concepts/aggregation.html" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../concepts/aggregation.html#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../concepts/rollup.html"
 * target="_top">Rollup</a>, <a href="../../concepts/cube.html"
 * target="_top">Cube</a>, and <a href="../../concepts/grouping_sets.html"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../concepts/pivot.html"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& GPUdb::aggregateGroupBy( const AggregateGroupByRequest& request_,
                                                   AggregateGroupByResponse& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", request_, actualResponse_, false);
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../concepts/aggregation.html" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../concepts/aggregation.html#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../concepts/rollup.html"
 * target="_top">Rollup</a>, <a href="../../concepts/cube.html"
 * target="_top">Cube</a>, and <a href="../../concepts/grouping_sets.html"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../concepts/pivot.html"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table/view/collection.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_collection_name: Name
 *                 of a collection which is to contain the table specified in
 *                 @a result_table. If the collection provided is non-existent,
 *                 the collection will be automatically created. If empty, then
 *                 the table will be a top-level table.  Additionally this
 *                 option is invalid if @a tableName is a collection.
 *                         <li> gpudb::aggregate_group_by_expression: Filter
 *                 expression to apply to the table prior to computing the
 *                 aggregate group by.
 *                         <li> gpudb::aggregate_group_by_having: Filter
 *                 expression to apply to the aggregated results.
 *                         <li> gpudb::aggregate_group_by_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_ascending: Indicates
 *                 that the returned values should be sorted in ascending
 *                 order.
 *                         <li> gpudb::aggregate_group_by_descending: Indicates
 *                 that the returned values should be sorted in descending
 *                 order.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_ascending.
 *                         <li> gpudb::aggregate_group_by_sort_by: String
 *                 determining how the results are sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_key: Indicates that
 *                 the returned values should be sorted by key, which
 *                 corresponds to the grouping columns. If you have multiple
 *                 grouping columns (and are sorting by key), it will first
 *                 sort the first grouping column, then the second grouping
 *                 column, etc.
 *                         <li> gpudb::aggregate_group_by_value: Indicates that
 *                 the returned values should be sorted by value, which
 *                 corresponds to the aggregates. If you have multiple
 *                 aggregates (and are sorting by value), it will first sort by
 *                 the first aggregate, then the second aggregate, etc.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_value.
 *                         <li> gpudb::aggregate_group_by_result_table: The
 *                 name of the table used to store the results. Has the same
 *                 naming restrictions as <a href="../../concepts/tables.html"
 *                 target="_top">tables</a>. Column names (group-by and
 *                 aggregate fields) need to be given aliases e.g. ["FChar256
 *                 as fchar256", "sum(FDouble) as sfd"].  If present, no
 *                 results are returned in the response.  This option is not
 *                 available if one of the grouping attributes is an
 *                 unrestricted string (i.e.; not charN) type.
 *                         <li> gpudb::aggregate_group_by_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_generate_pk: If
 *                 'true' then set a primary key for the result table. Must be
 *                 used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_group_by_chunk_size: Indicates
 *                 the chunk size to be used for the result table. Must be used
 *                 in combination with the @a result_table option.
 *                         <li> gpudb::aggregate_group_by_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the result table. Must be used in combination with the @a
 *                 result_table option.
 *                         <li> gpudb::aggregate_group_by_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                         <li> gpudb::aggregate_group_by_materialize_on_gpu:
 *                 If @a true then the columns of the groupby result table will
 *                 be cached on the GPU. Must be used in combination with the
 *                 @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_pivot: pivot column
 *                         <li> gpudb::aggregate_group_by_pivot_values: The
 *                 value list provided will become the column headers in the
 *                 output. Should be the values from the pivot_column.
 *                         <li> gpudb::aggregate_group_by_grouping_sets:
 *                 Customize the grouping attribute sets to compute the
 *                 aggregates. These sets can include ROLLUP or CUBE
 *                 operartors. The attribute sets should be enclosed in
 *                 paranthesis and can include composite attributes. All
 *                 attributes specified in the grouping sets must present in
 *                 the groupby attributes.
 *                         <li> gpudb::aggregate_group_by_rollup: This option
 *                 is used to specify the multilevel aggregates.
 *                         <li> gpudb::aggregate_group_by_cube: This option is
 *                 used to specify the multidimensional aggregates.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse GPUdb::aggregateGroupBy( const std::string& tableName,
                                                  const std::vector<std::string>& columnNames,
                                                  const int64_t offset,
                                                  const int64_t limit,
                                                  const std::map<std::string, std::string>& options ) const
{
    AggregateGroupByRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", actualRequest_, actualResponse_, false);
    AggregateGroupByResponse response_;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../concepts/aggregation.html" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../concepts/aggregation.html#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the @a offset and @a limit parameters. For
 * example, to get 10 groups with the largest counts the inputs would be:
 * limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * @a options can be used to customize behavior of this call e.g. filtering or
 * sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../concepts/rollup.html"
 * target="_top">Rollup</a>, <a href="../../concepts/cube.html"
 * target="_top">Cube</a>, and <a href="../../concepts/grouping_sets.html"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../concepts/pivot.html"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../concepts/expressions.html#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to @a having.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column names must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (@a offset is 0 and @a limit is -9999), the result
 * table will be sharded, in all other cases it will be replicated.  Sorting
 * will properly function only if the result table is replicated or if there is
 * only one processing node and should not be relied upon in other cases.  Not
 * available when any of the values of @a columnNames is an unrestricted-length
 * string.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table/view/collection.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_collection_name: Name
 *                 of a collection which is to contain the table specified in
 *                 @a result_table. If the collection provided is non-existent,
 *                 the collection will be automatically created. If empty, then
 *                 the table will be a top-level table.  Additionally this
 *                 option is invalid if @a tableName is a collection.
 *                         <li> gpudb::aggregate_group_by_expression: Filter
 *                 expression to apply to the table prior to computing the
 *                 aggregate group by.
 *                         <li> gpudb::aggregate_group_by_having: Filter
 *                 expression to apply to the aggregated results.
 *                         <li> gpudb::aggregate_group_by_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_ascending: Indicates
 *                 that the returned values should be sorted in ascending
 *                 order.
 *                         <li> gpudb::aggregate_group_by_descending: Indicates
 *                 that the returned values should be sorted in descending
 *                 order.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_ascending.
 *                         <li> gpudb::aggregate_group_by_sort_by: String
 *                 determining how the results are sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_key: Indicates that
 *                 the returned values should be sorted by key, which
 *                 corresponds to the grouping columns. If you have multiple
 *                 grouping columns (and are sorting by key), it will first
 *                 sort the first grouping column, then the second grouping
 *                 column, etc.
 *                         <li> gpudb::aggregate_group_by_value: Indicates that
 *                 the returned values should be sorted by value, which
 *                 corresponds to the aggregates. If you have multiple
 *                 aggregates (and are sorting by value), it will first sort by
 *                 the first aggregate, then the second aggregate, etc.
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_value.
 *                         <li> gpudb::aggregate_group_by_result_table: The
 *                 name of the table used to store the results. Has the same
 *                 naming restrictions as <a href="../../concepts/tables.html"
 *                 target="_top">tables</a>. Column names (group-by and
 *                 aggregate fields) need to be given aliases e.g. ["FChar256
 *                 as fchar256", "sum(FDouble) as sfd"].  If present, no
 *                 results are returned in the response.  This option is not
 *                 available if one of the grouping attributes is an
 *                 unrestricted string (i.e.; not charN) type.
 *                         <li> gpudb::aggregate_group_by_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li>
 *                 gpudb::aggregate_group_by_result_table_generate_pk: If
 *                 'true' then set a primary key for the result table. Must be
 *                 used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_group_by_chunk_size: Indicates
 *                 the chunk size to be used for the result table. Must be used
 *                 in combination with the @a result_table option.
 *                         <li> gpudb::aggregate_group_by_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the result table. Must be used in combination with the @a
 *                 result_table option.
 *                         <li> gpudb::aggregate_group_by_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                         <li> gpudb::aggregate_group_by_materialize_on_gpu:
 *                 If @a true then the columns of the groupby result table will
 *                 be cached on the GPU. Must be used in combination with the
 *                 @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_group_by_true
 *                         <li> gpudb::aggregate_group_by_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_group_by_false.
 *                         <li> gpudb::aggregate_group_by_pivot: pivot column
 *                         <li> gpudb::aggregate_group_by_pivot_values: The
 *                 value list provided will become the column headers in the
 *                 output. Should be the values from the pivot_column.
 *                         <li> gpudb::aggregate_group_by_grouping_sets:
 *                 Customize the grouping attribute sets to compute the
 *                 aggregates. These sets can include ROLLUP or CUBE
 *                 operartors. The attribute sets should be enclosed in
 *                 paranthesis and can include composite attributes. All
 *                 attributes specified in the grouping sets must present in
 *                 the groupby attributes.
 *                         <li> gpudb::aggregate_group_by_rollup: This option
 *                 is used to specify the multilevel aggregates.
 *                         <li> gpudb::aggregate_group_by_cube: This option is
 *                 used to specify the multidimensional aggregates.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& GPUdb::aggregateGroupBy( const std::string& tableName,
                                                   const std::vector<std::string>& columnNames,
                                                   const int64_t offset,
                                                   const int64_t limit,
                                                   const std::map<std::string, std::string>& options,
                                                   AggregateGroupByResponse& response_ ) const
{
    AggregateGroupByRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", actualRequest_, actualResponse_, false);
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a @a value_column.  In this latter
 * case the sum of the values corresponding to the @a value_column is used as
 * the result instead.  The total number of bins requested cannot exceed
 * 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service a request that specifies a @a value_column
 * option.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse GPUdb::aggregateHistogram( const AggregateHistogramRequest& request_ ) const
{
    AggregateHistogramResponse actualResponse_;
    submitRequest("/aggregate/histogram", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a @a value_column.  In this latter
 * case the sum of the values corresponding to the @a value_column is used as
 * the result instead.  The total number of bins requested cannot exceed
 * 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service a request that specifies a @a value_column
 * option.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& GPUdb::aggregateHistogram( const AggregateHistogramRequest& request_,
                                                       AggregateHistogramResponse& response_ ) const
{
    submitRequest("/aggregate/histogram", request_, response_, false);
    return response_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a @a value_column.  In this latter
 * case the sum of the values corresponding to the @a value_column is used as
 * the result instead.  The total number of bins requested cannot exceed
 * 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service a request that specifies a @a value_column
 * option.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table or collection.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_histogram_value_column: The
 *                 name of the column to use when calculating the bin values
 *                 (values are summed).  The column must be a numerical type
 *                 (int, double, long, float).
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse GPUdb::aggregateHistogram( const std::string& tableName,
                                                      const std::string& columnName,
                                                      const double start,
                                                      const double end,
                                                      const double interval,
                                                      const std::map<std::string, std::string>& options ) const
{
    AggregateHistogramRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    AggregateHistogramResponse actualResponse_;
    submitRequest("/aggregate/histogram", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a @a value_column.  In this latter
 * case the sum of the values corresponding to the @a value_column is used as
 * the result instead.  The total number of bins requested cannot exceed
 * 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service a request that specifies a @a value_column
 * option.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table or collection.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_histogram_value_column: The
 *                 name of the column to use when calculating the bin values
 *                 (values are summed).  The column must be a numerical type
 *                 (int, double, long, float).
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& GPUdb::aggregateHistogram( const std::string& tableName,
                                                       const std::string& columnName,
                                                       const double start,
                                                       const double end,
                                                       const double interval,
                                                       const std::map<std::string, std::string>& options,
                                                       AggregateHistogramResponse& response_ ) const
{
    AggregateHistogramRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    submitRequest("/aggregate/histogram", actualRequest_, response_, false);
    return response_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse GPUdb::aggregateKMeans( const AggregateKMeansRequest& request_ ) const
{
    AggregateKMeansResponse actualResponse_;
    submitRequest("/aggregate/kmeans", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& GPUdb::aggregateKMeans( const AggregateKMeansRequest& request_,
                                                 AggregateKMeansResponse& response_ ) const
{
    submitRequest("/aggregate/kmeans", request_, response_, false);
    return response_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table or collection.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_whiten: When set to 1
 *                 each of the columns is first normalized by its stdv -
 *                 default is not to whiten.
 *                         <li> gpudb::aggregate_k_means_max_iters: Number of
 *                 times to try to hit the tolerance limit before giving up -
 *                 default is 10.
 *                         <li> gpudb::aggregate_k_means_num_tries: Number of
 *                 times to run the k-means algorithm with a different randomly
 *                 selected starting points - helps avoid local minimum.
 *                 Default is 1.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse GPUdb::aggregateKMeans( const std::string& tableName,
                                                const std::vector<std::string>& columnNames,
                                                const int32_t k,
                                                const double tolerance,
                                                const std::map<std::string, std::string>& options ) const
{
    AggregateKMeansRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.k = k;
    actualRequest_.tolerance = tolerance;
    actualRequest_.options = options;
    AggregateKMeansResponse actualResponse_;
    submitRequest("/aggregate/kmeans", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table or collection.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_k_means_whiten: When set to 1
 *                 each of the columns is first normalized by its stdv -
 *                 default is not to whiten.
 *                         <li> gpudb::aggregate_k_means_max_iters: Number of
 *                 times to try to hit the tolerance limit before giving up -
 *                 default is 10.
 *                         <li> gpudb::aggregate_k_means_num_tries: Number of
 *                 times to run the k-means algorithm with a different randomly
 *                 selected starting points - helps avoid local minimum.
 *                 Default is 1.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& GPUdb::aggregateKMeans( const std::string& tableName,
                                                 const std::vector<std::string>& columnNames,
                                                 const int32_t k,
                                                 const double tolerance,
                                                 const std::map<std::string, std::string>& options,
                                                 AggregateKMeansResponse& response_ ) const
{
    AggregateKMeansRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.k = k;
    actualRequest_.tolerance = tolerance;
    actualRequest_.options = options;
    submitRequest("/aggregate/kmeans", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse GPUdb::aggregateMinMax( const AggregateMinMaxRequest& request_ ) const
{
    AggregateMinMaxResponse actualResponse_;
    submitRequest("/aggregate/minmax", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& GPUdb::aggregateMinMax( const AggregateMinMaxRequest& request_,
                                                 AggregateMinMaxResponse& response_ ) const
{
    submitRequest("/aggregate/minmax", request_, response_, false);
    return response_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse GPUdb::aggregateMinMax( const std::string& tableName,
                                                const std::string& columnName,
                                                const std::map<std::string, std::string>& options ) const
{
    AggregateMinMaxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    AggregateMinMaxResponse actualResponse_;
    submitRequest("/aggregate/minmax", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& GPUdb::aggregateMinMax( const std::string& tableName,
                                                 const std::string& columnName,
                                                 const std::map<std::string, std::string>& options,
                                                 AggregateMinMaxResponse& response_ ) const
{
    AggregateMinMaxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    submitRequest("/aggregate/minmax", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates and returns the minimum and maximum x- and y-coordinates of a
 * particular geospatial geometry column in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxGeometryResponse GPUdb::aggregateMinMaxGeometry( const AggregateMinMaxGeometryRequest& request_ ) const
{
    AggregateMinMaxGeometryResponse actualResponse_;
    submitRequest("/aggregate/minmax/geometry", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the minimum and maximum x- and y-coordinates of a
 * particular geospatial geometry column in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxGeometryResponse& GPUdb::aggregateMinMaxGeometry( const AggregateMinMaxGeometryRequest& request_,
                                                                 AggregateMinMaxGeometryResponse& response_ ) const
{
    submitRequest("/aggregate/minmax/geometry", request_, response_, false);
    return response_;
}


/**
 * Calculates and returns the minimum and maximum x- and y-coordinates of a
 * particular geospatial geometry column in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table.
 * @param columnName  Name of a geospatial geometry column on which the min-max
 *                    will be calculated.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxGeometryResponse GPUdb::aggregateMinMaxGeometry( const std::string& tableName,
                                                                const std::string& columnName,
                                                                const std::map<std::string, std::string>& options ) const
{
    AggregateMinMaxGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    AggregateMinMaxGeometryResponse actualResponse_;
    submitRequest("/aggregate/minmax/geometry", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the minimum and maximum x- and y-coordinates of a
 * particular geospatial geometry column in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table.
 * @param columnName  Name of a geospatial geometry column on which the min-max
 *                    will be calculated.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxGeometryResponse& GPUdb::aggregateMinMaxGeometry( const std::string& tableName,
                                                                 const std::string& columnName,
                                                                 const std::map<std::string, std::string>& options,
                                                                 AggregateMinMaxGeometryResponse& response_ ) const
{
    AggregateMinMaxGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    submitRequest("/aggregate/minmax/geometry", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates the requested statistics of the given column(s) in a given table.
 * <p>
 * The available statistics are @a count (number of total objects), @a mean, @a
 * stdv (standard deviation), @a variance, @a skew, @a kurtosis, @a sum, @a
 * min, @a max, @a weighted_average, @a cardinality (unique count), @a
 * estimated_cardinality, @a percentile and @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired @a percentile/@a
 * percentile_rank. To compute multiple percentiles each value must be
 * specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the @a percentile statistic
 * to calculate percentile resolution, e.g., a 50th percentile with 200
 * resolution would be 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a @a weight_column_name to be
 * specified in @a options. The weighted average is then defined as the sum of
 * the products of @a columnName times the @a weight_column_name values divided
 * by the sum of the @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via the @a
 * additional_column_names option.  Values in these columns will be included in
 * the overall aggregate calculation--individual aggregates will not be
 * calculated per additional column.  For instance, requesting the @a count &
 * @a mean of @a columnName x and @a additional_column_names y & z, where x
 * holds the numbers 1-10, y holds 11-20, and z holds 21-30, would return the
 * total number of x, y, & z values (30), and the single average value across
 * all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and its corresponding value.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse GPUdb::aggregateStatistics( const AggregateStatisticsRequest& request_ ) const
{
    AggregateStatisticsResponse actualResponse_;
    submitRequest("/aggregate/statistics", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates the requested statistics of the given column(s) in a given table.
 * <p>
 * The available statistics are @a count (number of total objects), @a mean, @a
 * stdv (standard deviation), @a variance, @a skew, @a kurtosis, @a sum, @a
 * min, @a max, @a weighted_average, @a cardinality (unique count), @a
 * estimated_cardinality, @a percentile and @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired @a percentile/@a
 * percentile_rank. To compute multiple percentiles each value must be
 * specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the @a percentile statistic
 * to calculate percentile resolution, e.g., a 50th percentile with 200
 * resolution would be 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a @a weight_column_name to be
 * specified in @a options. The weighted average is then defined as the sum of
 * the products of @a columnName times the @a weight_column_name values divided
 * by the sum of the @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via the @a
 * additional_column_names option.  Values in these columns will be included in
 * the overall aggregate calculation--individual aggregates will not be
 * calculated per additional column.  For instance, requesting the @a count &
 * @a mean of @a columnName x and @a additional_column_names y & z, where x
 * holds the numbers 1-10, y holds 11-20, and z holds 21-30, would return the
 * total number of x, y, & z values (30), and the single average value across
 * all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and its corresponding value.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& GPUdb::aggregateStatistics( const AggregateStatisticsRequest& request_,
                                                         AggregateStatisticsResponse& response_ ) const
{
    submitRequest("/aggregate/statistics", request_, response_, false);
    return response_;
}


/**
 * Calculates the requested statistics of the given column(s) in a given table.
 * <p>
 * The available statistics are @a count (number of total objects), @a mean, @a
 * stdv (standard deviation), @a variance, @a skew, @a kurtosis, @a sum, @a
 * min, @a max, @a weighted_average, @a cardinality (unique count), @a
 * estimated_cardinality, @a percentile and @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired @a percentile/@a
 * percentile_rank. To compute multiple percentiles each value must be
 * specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the @a percentile statistic
 * to calculate percentile resolution, e.g., a 50th percentile with 200
 * resolution would be 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a @a weight_column_name to be
 * specified in @a options. The weighted average is then defined as the sum of
 * the products of @a columnName times the @a weight_column_name values divided
 * by the sum of the @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via the @a
 * additional_column_names option.  Values in these columns will be included in
 * the overall aggregate calculation--individual aggregates will not be
 * calculated per additional column.  For instance, requesting the @a count &
 * @a mean of @a columnName x and @a additional_column_names y & z, where x
 * holds the numbers 1-10, y holds 11-20, and z holds 21-30, would return the
 * total number of x, y, & z values (30), and the single average value across
 * all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and its corresponding value.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed.
 * @param columnName  Name of the primary column for which the statistics are
 *                    to be calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean".
 *               <ul>
 *                       <li> gpudb::aggregate_statistics_count: Number of
 *               objects (independent of the given column(s)).
 *                       <li> gpudb::aggregate_statistics_mean: Arithmetic mean
 *               (average), equivalent to sum/count.
 *                       <li> gpudb::aggregate_statistics_stdv: Sample standard
 *               deviation (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_variance: Unbiased
 *               sample variance (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_skew: Skewness (third
 *               standardized moment).
 *                       <li> gpudb::aggregate_statistics_kurtosis: Kurtosis
 *               (fourth standardized moment).
 *                       <li> gpudb::aggregate_statistics_sum: Sum of all
 *               values in the column(s).
 *                       <li> gpudb::aggregate_statistics_min: Minimum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_max: Maximum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_weighted_average:
 *               Weighted arithmetic mean (using the option @a
 *               weight_column_name as the weighting column).
 *                       <li> gpudb::aggregate_statistics_cardinality: Number
 *               of unique values in the column(s).
 *                       <li>
 *               gpudb::aggregate_statistics_estimated_cardinality: Estimate
 *               (via hyperloglog technique) of the number of unique values in
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_percentile: Estimate
 *               (via t-digest) of the given percentile of the column(s)
 *               (percentile(50.0) will be an approximation of the median). Add
 *               a second, comma-separated value to calculate percentile
 *               resolution, e.g., 'percentile(75,150)'
 *                       <li> gpudb::aggregate_statistics_percentile_rank:
 *               Estimate (via t-digest) of the percentile rank of the given
 *               value in the column(s) (if the given value is the median of
 *               the column(s), percentile_rank(<median>) will return
 *               approximately 50.0).
 *               </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_additional_column_names: A list
 *                 of comma separated column names over which statistics can be
 *                 accumulated along with the primary column.  All columns
 *                 listed and @a columnName must be of the same type.  Must not
 *                 include the column specified in @a columnName and no column
 *                 can be listed twice.
 *                         <li> gpudb::aggregate_statistics_weight_column_name:
 *                 Name of column used as weighting attribute for the weighted
 *                 average statistic.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse GPUdb::aggregateStatistics( const std::string& tableName,
                                                        const std::string& columnName,
                                                        const std::string& stats,
                                                        const std::map<std::string, std::string>& options ) const
{
    AggregateStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.stats = stats;
    actualRequest_.options = options;
    AggregateStatisticsResponse actualResponse_;
    submitRequest("/aggregate/statistics", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates the requested statistics of the given column(s) in a given table.
 * <p>
 * The available statistics are @a count (number of total objects), @a mean, @a
 * stdv (standard deviation), @a variance, @a skew, @a kurtosis, @a sum, @a
 * min, @a max, @a weighted_average, @a cardinality (unique count), @a
 * estimated_cardinality, @a percentile and @a percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired @a percentile/@a
 * percentile_rank. To compute multiple percentiles each value must be
 * specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the @a percentile statistic
 * to calculate percentile resolution, e.g., a 50th percentile with 200
 * resolution would be 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a @a weight_column_name to be
 * specified in @a options. The weighted average is then defined as the sum of
 * the products of @a columnName times the @a weight_column_name values divided
 * by the sum of the @a weight_column_name values.
 * <p>
 * Additional columns can be used in the calculation of statistics via the @a
 * additional_column_names option.  Values in these columns will be included in
 * the overall aggregate calculation--individual aggregates will not be
 * calculated per additional column.  For instance, requesting the @a count &
 * @a mean of @a columnName x and @a additional_column_names y & z, where x
 * holds the numbers 1-10, y holds 11-20, and z holds 21-30, would return the
 * total number of x, y, & z values (30), and the single average value across
 * all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and its corresponding value.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed.
 * @param columnName  Name of the primary column for which the statistics are
 *                    to be calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean".
 *               <ul>
 *                       <li> gpudb::aggregate_statistics_count: Number of
 *               objects (independent of the given column(s)).
 *                       <li> gpudb::aggregate_statistics_mean: Arithmetic mean
 *               (average), equivalent to sum/count.
 *                       <li> gpudb::aggregate_statistics_stdv: Sample standard
 *               deviation (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_variance: Unbiased
 *               sample variance (denominator is count-1).
 *                       <li> gpudb::aggregate_statistics_skew: Skewness (third
 *               standardized moment).
 *                       <li> gpudb::aggregate_statistics_kurtosis: Kurtosis
 *               (fourth standardized moment).
 *                       <li> gpudb::aggregate_statistics_sum: Sum of all
 *               values in the column(s).
 *                       <li> gpudb::aggregate_statistics_min: Minimum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_max: Maximum value of
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_weighted_average:
 *               Weighted arithmetic mean (using the option @a
 *               weight_column_name as the weighting column).
 *                       <li> gpudb::aggregate_statistics_cardinality: Number
 *               of unique values in the column(s).
 *                       <li>
 *               gpudb::aggregate_statistics_estimated_cardinality: Estimate
 *               (via hyperloglog technique) of the number of unique values in
 *               the column(s).
 *                       <li> gpudb::aggregate_statistics_percentile: Estimate
 *               (via t-digest) of the given percentile of the column(s)
 *               (percentile(50.0) will be an approximation of the median). Add
 *               a second, comma-separated value to calculate percentile
 *               resolution, e.g., 'percentile(75,150)'
 *                       <li> gpudb::aggregate_statistics_percentile_rank:
 *               Estimate (via t-digest) of the percentile rank of the given
 *               value in the column(s) (if the given value is the median of
 *               the column(s), percentile_rank(<median>) will return
 *               approximately 50.0).
 *               </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_additional_column_names: A list
 *                 of comma separated column names over which statistics can be
 *                 accumulated along with the primary column.  All columns
 *                 listed and @a columnName must be of the same type.  Must not
 *                 include the column specified in @a columnName and no column
 *                 can be listed twice.
 *                         <li> gpudb::aggregate_statistics_weight_column_name:
 *                 Name of column used as weighting attribute for the weighted
 *                 average statistic.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& GPUdb::aggregateStatistics( const std::string& tableName,
                                                         const std::string& columnName,
                                                         const std::string& stats,
                                                         const std::map<std::string, std::string>& options,
                                                         AggregateStatisticsResponse& response_ ) const
{
    AggregateStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.stats = stats;
    actualRequest_.options = options;
    submitRequest("/aggregate/statistics", actualRequest_, response_, false);
    return response_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse GPUdb::aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_ ) const
{
    AggregateStatisticsByRangeResponse actualResponse_;
    submitRequest("/aggregate/statistics/byrange", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& GPUdb::aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_,
                                                                       AggregateStatisticsByRangeResponse& response_ ) const
{
    submitRequest("/aggregate/statistics/byrange", request_, response_, false);
    return response_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval``*``i,
 *                  start+interval``*``(i+1)).
 * @param options  Map of optional parameters:
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_additional_column_names:
 *                 A list of comma separated value-column names over which
 *                 statistics can be accumulated along with the primary
 *                 value_column.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_bin_values: A list of
 *                 comma separated binning-column values. Values that match the
 *                 nth bin_values value are placed in the nth bin.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_weight_column_name:
 *                 Name of the column used as weighting column for the
 *                 weighted_average statistic.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_order_column_name: Name
 *                 of the column used for candlestick charting techniques.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse GPUdb::aggregateStatisticsByRange( const std::string& tableName,
                                                                      const std::string& selectExpression,
                                                                      const std::string& columnName,
                                                                      const std::string& valueColumnName,
                                                                      const std::string& stats,
                                                                      const double start,
                                                                      const double end,
                                                                      const double interval,
                                                                      const std::map<std::string, std::string>& options ) const
{
    AggregateStatisticsByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.selectExpression = selectExpression;
    actualRequest_.columnName = columnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.stats = stats;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    AggregateStatisticsByRangeResponse actualResponse_;
    submitRequest("/aggregate/statistics/byrange", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based) build to service this request.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval``*``i,
 *                  start+interval``*``(i+1)).
 * @param options  Map of optional parameters:
 *                 <ul>
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_additional_column_names:
 *                 A list of comma separated value-column names over which
 *                 statistics can be accumulated along with the primary
 *                 value_column.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_bin_values: A list of
 *                 comma separated binning-column values. Values that match the
 *                 nth bin_values value are placed in the nth bin.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_weight_column_name:
 *                 Name of the column used as weighting column for the
 *                 weighted_average statistic.
 *                         <li>
 *                 gpudb::aggregate_statistics_by_range_order_column_name: Name
 *                 of the column used for candlestick charting techniques.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& GPUdb::aggregateStatisticsByRange( const std::string& tableName,
                                                                       const std::string& selectExpression,
                                                                       const std::string& columnName,
                                                                       const std::string& valueColumnName,
                                                                       const std::string& stats,
                                                                       const double start,
                                                                       const double end,
                                                                       const double interval,
                                                                       const std::map<std::string, std::string>& options,
                                                                       AggregateStatisticsByRangeResponse& response_ ) const
{
    AggregateStatisticsByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.selectExpression = selectExpression;
    actualRequest_.columnName = columnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.stats = stats;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    submitRequest("/aggregate/statistics/byrange", actualRequest_, response_, false);
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table or collection (specified by @a tableName).
 * If @a columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  The results can be paged via the
 * @a offset and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column name must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; any column expression will need to be aliased.  If the
 * source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the @a columnName, the result table
 * will be sharded, in all other cases it will be replicated.  Sorting will
 * properly function only if the result table is replicated or if there is only
 * one processing node and should not be relied upon in other cases.  Not
 * available if @a tableName is a collection or when the value of @a columnName
 * is an unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateUniqueResponse GPUdb::aggregateUniqueRaw( const AggregateUniqueRequest& request_ ) const
{
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table or collection (specified by @a tableName).
 * If @a columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  The results can be paged via the
 * @a offset and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column name must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; any column expression will need to be aliased.  If the
 * source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the @a columnName, the result table
 * will be sharded, in all other cases it will be replicated.  Sorting will
 * properly function only if the result table is replicated or if there is only
 * one processing node and should not be relied upon in other cases.  Not
 * available if @a tableName is a collection or when the value of @a columnName
 * is an unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateUniqueResponse& GPUdb::aggregateUniqueRaw( const AggregateUniqueRequest& request_,
                                                       RawAggregateUniqueResponse& response_ ) const
{
    submitRequest("/aggregate/unique", request_, response_, false);
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table or collection (specified by @a tableName).
 * If @a columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  The results can be paged via the
 * @a offset and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column name must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; any column expression will need to be aliased.  If the
 * source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the @a columnName, the result table
 * will be sharded, in all other cases it will be replicated.  Sorting will
 * properly function only if the result table is replicated or if there is only
 * one processing node and should not be relied upon in other cases.  Not
 * available if @a tableName is a collection or when the value of @a columnName
 * is an unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse GPUdb::aggregateUnique( const AggregateUniqueRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", request_, actualResponse_, false);
    AggregateUniqueResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table or collection (specified by @a tableName).
 * If @a columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  The results can be paged via the
 * @a offset and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column name must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; any column expression will need to be aliased.  If the
 * source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the @a columnName, the result table
 * will be sharded, in all other cases it will be replicated.  Sorting will
 * properly function only if the result table is replicated or if there is only
 * one processing node and should not be relied upon in other cases.  Not
 * available if @a tableName is a collection or when the value of @a columnName
 * is an unrestricted-length string.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& GPUdb::aggregateUnique( const AggregateUniqueRequest& request_,
                                                 AggregateUniqueResponse& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table or collection (specified by @a tableName).
 * If @a columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  The results can be paged via the
 * @a offset and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column name must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; any column expression will need to be aliased.  If the
 * source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the @a columnName, the result table
 * will be sharded, in all other cases it will be replicated.  Sorting will
 * properly function only if the result table is replicated or if there is only
 * one processing node and should not be relied upon in other cases.  Not
 * available if @a tableName is a collection or when the value of @a columnName
 * is an unrestricted-length string.
 * 
 * @param tableName  Name of an existing table/collection on which the
 *                   operation will be performed.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_collection_name: Name
 *                 of a collection which is to contain the table specified in
 *                 @a result_table. If the collection provided is non-existent,
 *                 the collection will be automatically created. If empty, then
 *                 the table will be a top-level table.  Additionally this
 *                 option is invalid if @a tableName is a collection.
 *                         <li> gpudb::aggregate_unique_expression: Optional
 *                 filter expression to apply to the table.
 *                         <li> gpudb::aggregate_unique_sort_order: String
 *                 indicating how the returned values should be sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_ascending
 *                         <li> gpudb::aggregate_unique_descending
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_ascending.
 *                         <li> gpudb::aggregate_unique_result_table: The name
 *                 of the table used to store the results. If present, no
 *                 results are returned in the response. Has the same naming
 *                 restrictions as <a href="../../concepts/tables.html"
 *                 target="_top">tables</a>.  Not available if @a tableName is
 *                 a collection or when @a columnName is an unrestricted-length
 *                 string.
 *                         <li> gpudb::aggregate_unique_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_force_replicated: Force
 *                 the result table to be replicated (ignores any sharding).
 *                 Must be used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_generate_pk: If 'true'
 *                 then set a primary key for the result table. Must be used in
 *                 combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li> gpudb::aggregate_unique_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unique_chunk_size: Indicates
 *                 the chunk size to be used for the result table. Must be used
 *                 in combination with the @a result_table option.
 *                         <li> gpudb::aggregate_unique_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse GPUdb::aggregateUnique( const std::string& tableName,
                                                const std::string& columnName,
                                                const int64_t offset,
                                                const int64_t limit,
                                                const std::map<std::string, std::string>& options ) const
{
    AggregateUniqueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", actualRequest_, actualResponse_, false);
    AggregateUniqueResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table or collection (specified by @a tableName).
 * If @a columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  The results can be paged via the
 * @a offset and @a limit parameters.
 * <p>
 * Columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a> are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order @a options
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a @a result_table name is specified in the @a options, the results are
 * stored in a new table with that name--no results are returned in the
 * response.  Both the table name and resulting column name must adhere to <a
 * href="../../concepts/tables.html#table" target="_top">standard naming
 * conventions</a>; any column expression will need to be aliased.  If the
 * source table's <a href="../../concepts/tables.html#shard-keys"
 * target="_top">shard key</a> is used as the @a columnName, the result table
 * will be sharded, in all other cases it will be replicated.  Sorting will
 * properly function only if the result table is replicated or if there is only
 * one processing node and should not be relied upon in other cases.  Not
 * available if @a tableName is a collection or when the value of @a columnName
 * is an unrestricted-length string.
 * 
 * @param tableName  Name of an existing table/collection on which the
 *                   operation will be performed.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_collection_name: Name
 *                 of a collection which is to contain the table specified in
 *                 @a result_table. If the collection provided is non-existent,
 *                 the collection will be automatically created. If empty, then
 *                 the table will be a top-level table.  Additionally this
 *                 option is invalid if @a tableName is a collection.
 *                         <li> gpudb::aggregate_unique_expression: Optional
 *                 filter expression to apply to the table.
 *                         <li> gpudb::aggregate_unique_sort_order: String
 *                 indicating how the returned values should be sorted.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_ascending
 *                         <li> gpudb::aggregate_unique_descending
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_ascending.
 *                         <li> gpudb::aggregate_unique_result_table: The name
 *                 of the table used to store the results. If present, no
 *                 results are returned in the response. Has the same naming
 *                 restrictions as <a href="../../concepts/tables.html"
 *                 target="_top">tables</a>.  Not available if @a tableName is
 *                 a collection or when @a columnName is an unrestricted-length
 *                 string.
 *                         <li> gpudb::aggregate_unique_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_force_replicated: Force
 *                 the result table to be replicated (ignores any sharding).
 *                 Must be used in combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li>
 *                 gpudb::aggregate_unique_result_table_generate_pk: If 'true'
 *                 then set a primary key for the result table. Must be used in
 *                 combination with the @a result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unique_true
 *                         <li> gpudb::aggregate_unique_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unique_false.
 *                         <li> gpudb::aggregate_unique_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unique_chunk_size: Indicates
 *                 the chunk size to be used for the result table. Must be used
 *                 in combination with the @a result_table option.
 *                         <li> gpudb::aggregate_unique_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& GPUdb::aggregateUnique( const std::string& tableName,
                                                 const std::string& columnName,
                                                 const int64_t offset,
                                                 const int64_t limit,
                                                 const std::map<std::string, std::string>& options,
                                                 AggregateUniqueResponse& response_ ) const
{
    AggregateUniqueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see <a href="../../concepts/unpivot.html"
 * target="_top">Unpivot</a>.  For limitations, see <a
 * href="../../concepts/unpivot.html#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting purposes. The unpivot operator rotates the column values for all
 * the pivoted columns. A variable column, value column and all columns from
 * the source table except the unpivot columns are projected into the result
 * table. The variable column and value columns in the result table indicate
 * the pivoted column name and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateUnpivotResponse GPUdb::aggregateUnpivotRaw( const AggregateUnpivotRequest& request_ ) const
{
    RawAggregateUnpivotResponse actualResponse_;
    submitRequest("/aggregate/unpivot", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see <a href="../../concepts/unpivot.html"
 * target="_top">Unpivot</a>.  For limitations, see <a
 * href="../../concepts/unpivot.html#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting purposes. The unpivot operator rotates the column values for all
 * the pivoted columns. A variable column, value column and all columns from
 * the source table except the unpivot columns are projected into the result
 * table. The variable column and value columns in the result table indicate
 * the pivoted column name and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateUnpivotResponse& GPUdb::aggregateUnpivotRaw( const AggregateUnpivotRequest& request_,
                                                         RawAggregateUnpivotResponse& response_ ) const
{
    submitRequest("/aggregate/unpivot", request_, response_, false);
    return response_;
}


/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see <a href="../../concepts/unpivot.html"
 * target="_top">Unpivot</a>.  For limitations, see <a
 * href="../../concepts/unpivot.html#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting purposes. The unpivot operator rotates the column values for all
 * the pivoted columns. A variable column, value column and all columns from
 * the source table except the unpivot columns are projected into the result
 * table. The variable column and value columns in the result table indicate
 * the pivoted column name and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUnpivotResponse GPUdb::aggregateUnpivot( const AggregateUnpivotRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawAggregateUnpivotResponse actualResponse_;
    submitRequest("/aggregate/unpivot", request_, actualResponse_, false);
    AggregateUnpivotResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see <a href="../../concepts/unpivot.html"
 * target="_top">Unpivot</a>.  For limitations, see <a
 * href="../../concepts/unpivot.html#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting purposes. The unpivot operator rotates the column values for all
 * the pivoted columns. A variable column, value column and all columns from
 * the source table except the unpivot columns are projected into the result
 * table. The variable column and value columns in the result table indicate
 * the pivoted column name and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUnpivotResponse& GPUdb::aggregateUnpivot( const AggregateUnpivotRequest& request_,
                                                   AggregateUnpivotResponse& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawAggregateUnpivotResponse actualResponse_;
    submitRequest("/aggregate/unpivot", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see <a href="../../concepts/unpivot.html"
 * target="_top">Unpivot</a>.  For limitations, see <a
 * href="../../concepts/unpivot.html#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting purposes. The unpivot operator rotates the column values for all
 * the pivoted columns. A variable column, value column and all columns from
 * the source table except the unpivot columns are projected into the result
 * table. The variable column and value columns in the result table indicate
 * the pivoted column name and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table/view.
 * @param columnNames  List of column names or expressions. A wildcard '*' can
 *                     be used to include all the non-pivoted columns from the
 *                     source table.
 * @param variableColumnName  Specifies the variable/parameter column name.
 * @param valueColumnName  Specifies the value column name.
 * @param pivotedColumns  List of one or more values typically the column names
 *                        of the input table. All the columns in the source
 *                        table must have the same data type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_collection_name: Name
 *                 of a collection which is to contain the table specified in
 *                 @a result_table. If the collection provided is non-existent,
 *                 the collection will be automatically created. If empty, then
 *                 the table will be a top-level table.
 *                         <li> gpudb::aggregate_unpivot_result_table: The name
 *                 of the table used to store the results. Has the same naming
 *                 restrictions as <a href="../../concepts/tables.html"
 *                 target="_top">tables</a>. If present, no results are
 *                 returned in the response.
 *                         <li> gpudb::aggregate_unpivot_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_expression: Filter
 *                 expression to apply to the table prior to unpivot
 *                 processing.
 *                         <li> gpudb::aggregate_unpivot_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in input table.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_chunk_size: Indicates
 *                 the chunk size to be used for the result table. Must be used
 *                 in combination with the @a result_table option.
 *                         <li> gpudb::aggregate_unpivot_limit: The number of
 *                 records to keep.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unpivot_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_materialize_on_gpu: If
 *                 @a true then the output columns will be cached on the GPU.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the table specified in @a result_table. The columns
 *                 specified must be present in output column names.  If any
 *                 alias is given for any column name, the alias must be used,
 *                 rather than the original column name.
 *                         <li>
 *                 gpudb::aggregate_unpivot_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUnpivotResponse GPUdb::aggregateUnpivot( const std::string& tableName,
                                                  const std::vector<std::string>& columnNames,
                                                  const std::string& variableColumnName,
                                                  const std::string& valueColumnName,
                                                  const std::vector<std::string>& pivotedColumns,
                                                  const std::map<std::string, std::string>& options ) const
{
    AggregateUnpivotRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.variableColumnName = variableColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.pivotedColumns = pivotedColumns;
    actualRequest_.options = options;
    RawAggregateUnpivotResponse actualResponse_;
    submitRequest("/aggregate/unpivot", actualRequest_, actualResponse_, false);
    AggregateUnpivotResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see <a href="../../concepts/unpivot.html"
 * target="_top">Unpivot</a>.  For limitations, see <a
 * href="../../concepts/unpivot.html#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting purposes. The unpivot operator rotates the column values for all
 * the pivoted columns. A variable column, value column and all columns from
 * the source table except the unpivot columns are projected into the result
 * table. The variable column and value columns in the result table indicate
 * the pivoted column name and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be an existing table/view.
 * @param columnNames  List of column names or expressions. A wildcard '*' can
 *                     be used to include all the non-pivoted columns from the
 *                     source table.
 * @param variableColumnName  Specifies the variable/parameter column name.
 * @param valueColumnName  Specifies the value column name.
 * @param pivotedColumns  List of one or more values typically the column names
 *                        of the input table. All the columns in the source
 *                        table must have the same data type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_collection_name: Name
 *                 of a collection which is to contain the table specified in
 *                 @a result_table. If the collection provided is non-existent,
 *                 the collection will be automatically created. If empty, then
 *                 the table will be a top-level table.
 *                         <li> gpudb::aggregate_unpivot_result_table: The name
 *                 of the table used to store the results. Has the same naming
 *                 restrictions as <a href="../../concepts/tables.html"
 *                 target="_top">tables</a>. If present, no results are
 *                 returned in the response.
 *                         <li> gpudb::aggregate_unpivot_result_table_persist:
 *                 If @a true, then the result table specified in @a
 *                 result_table will be persisted and will not expire unless a
 *                 @a ttl is specified.   If @a false, then the result table
 *                 will be an in-memory table and will expire unless a @a ttl
 *                 is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_expression: Filter
 *                 expression to apply to the table prior to unpivot
 *                 processing.
 *                         <li> gpudb::aggregate_unpivot_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in input table.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_chunk_size: Indicates
 *                 the chunk size to be used for the result table. Must be used
 *                 in combination with the @a result_table option.
 *                         <li> gpudb::aggregate_unpivot_limit: The number of
 *                 records to keep.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a result_table.
 *                         <li> gpudb::aggregate_unpivot_view_id: view this
 *                 result table is part of.  The default value is ''.
 *                         <li> gpudb::aggregate_unpivot_materialize_on_gpu: If
 *                 @a true then the output columns will be cached on the GPU.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                         <li> gpudb::aggregate_unpivot_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the table specified in @a result_table. The columns
 *                 specified must be present in output column names.  If any
 *                 alias is given for any column name, the alias must be used,
 *                 rather than the original column name.
 *                         <li>
 *                 gpudb::aggregate_unpivot_result_table_force_replicated:
 *                 Force the result table to be replicated (ignores any
 *                 sharding). Must be used in combination with the @a
 *                 result_table option.
 *                 <ul>
 *                         <li> gpudb::aggregate_unpivot_true
 *                         <li> gpudb::aggregate_unpivot_false
 *                 </ul>
 *                 The default value is gpudb::aggregate_unpivot_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUnpivotResponse& GPUdb::aggregateUnpivot( const std::string& tableName,
                                                   const std::vector<std::string>& columnNames,
                                                   const std::string& variableColumnName,
                                                   const std::string& valueColumnName,
                                                   const std::vector<std::string>& pivotedColumns,
                                                   const std::map<std::string, std::string>& options,
                                                   AggregateUnpivotResponse& response_ ) const
{
    AggregateUnpivotRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.variableColumnName = variableColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.pivotedColumns = pivotedColumns;
    actualRequest_.options = options;
    RawAggregateUnpivotResponse actualResponse_;
    submitRequest("/aggregate/unpivot", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterResourceGroupResponse GPUdb::alterResourceGroup( const AlterResourceGroupRequest& request_ ) const
{
    AlterResourceGroupResponse actualResponse_;
    submitRequest("/alter/resourcegroup", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterResourceGroupResponse& GPUdb::alterResourceGroup( const AlterResourceGroupRequest& request_,
                                                       AlterResourceGroupResponse& response_ ) const
{
    submitRequest("/alter/resourcegroup", request_, response_, false);
    return response_;
}


/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param name  Name of the group to be altered. Must be an existing resource
 *              group name.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::alter_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  If the resource group ranking is to be updated, this
 *                 indicates the relative ranking among existing resource
 *                 groups where this resource group will be moved; leave blank
 *                 if not changing the ranking.  When using @a before or @a
 *                 after, specify which resource group this one will be
 *                 inserted before or after in @a adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_empty_string
 *                         <li> gpudb::alter_resource_group_first
 *                         <li> gpudb::alter_resource_group_last
 *                         <li> gpudb::alter_resource_group_before
 *                         <li> gpudb::alter_resource_group_after
 *                 </ul>
 *                 The default value is
 *                 gpudb::alter_resource_group_empty_string.
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::alter_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li>
 *                 gpudb::alter_resource_group_max_scheduling_priority: Maximum
 *                 priority of a scheduled task for this group.
 *                         <li> gpudb::alter_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                         <li> gpudb::alter_resource_group_is_default_group:
 *                 If @a true, this request applies to the global default
 *                 resource group. It is an error for this field to be @a true
 *                 when the @a name field is also populated.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_true
 *                         <li> gpudb::alter_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::alter_resource_group_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterResourceGroupResponse GPUdb::alterResourceGroup( const std::string& name,
                                                      const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                                      const std::string& ranking,
                                                      const std::string& adjoiningResourceGroup,
                                                      const std::map<std::string, std::string>& options ) const
{
    AlterResourceGroupRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.tierAttributes = tierAttributes;
    actualRequest_.ranking = ranking;
    actualRequest_.adjoiningResourceGroup = adjoiningResourceGroup;
    actualRequest_.options = options;
    AlterResourceGroupResponse actualResponse_;
    submitRequest("/alter/resourcegroup", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 * 
 * @param name  Name of the group to be altered. Must be an existing resource
 *              group name.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::alter_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  If the resource group ranking is to be updated, this
 *                 indicates the relative ranking among existing resource
 *                 groups where this resource group will be moved; leave blank
 *                 if not changing the ranking.  When using @a before or @a
 *                 after, specify which resource group this one will be
 *                 inserted before or after in @a adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_empty_string
 *                         <li> gpudb::alter_resource_group_first
 *                         <li> gpudb::alter_resource_group_last
 *                         <li> gpudb::alter_resource_group_before
 *                         <li> gpudb::alter_resource_group_after
 *                 </ul>
 *                 The default value is
 *                 gpudb::alter_resource_group_empty_string.
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::alter_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li>
 *                 gpudb::alter_resource_group_max_scheduling_priority: Maximum
 *                 priority of a scheduled task for this group.
 *                         <li> gpudb::alter_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                         <li> gpudb::alter_resource_group_is_default_group:
 *                 If @a true, this request applies to the global default
 *                 resource group. It is an error for this field to be @a true
 *                 when the @a name field is also populated.
 *                 <ul>
 *                         <li> gpudb::alter_resource_group_true
 *                         <li> gpudb::alter_resource_group_false
 *                 </ul>
 *                 The default value is gpudb::alter_resource_group_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterResourceGroupResponse& GPUdb::alterResourceGroup( const std::string& name,
                                                       const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                                       const std::string& ranking,
                                                       const std::string& adjoiningResourceGroup,
                                                       const std::map<std::string, std::string>& options,
                                                       AlterResourceGroupResponse& response_ ) const
{
    AlterResourceGroupRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.tierAttributes = tierAttributes;
    actualRequest_.ranking = ranking;
    actualRequest_.adjoiningResourceGroup = adjoiningResourceGroup;
    actualRequest_.options = options;
    submitRequest("/alter/resourcegroup", actualRequest_, response_, false);
    return response_;
}


/**
 * Alters a Role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterRoleResponse GPUdb::alterRole( const AlterRoleRequest& request_ ) const
{
    AlterRoleResponse actualResponse_;
    submitRequest("/alter/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters a Role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterRoleResponse& GPUdb::alterRole( const AlterRoleRequest& request_,
                                     AlterRoleResponse& response_ ) const
{
    submitRequest("/alter/role", request_, response_, false);
    return response_;
}


/**
 * Alters a Role.
 * 
 * @param name  Name of the role to be altered. Must be an existing role.
 * @param action  Modification operation to be applied to the role.
 *                <ul>
 *                        <li> gpudb::alter_role_set_resource_group: Sets the
 *                resource group for an internal role. The resource group must
 *                exist, otherwise, an empty string assigns the role to the
 *                default resource group.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterRoleResponse GPUdb::alterRole( const std::string& name,
                                    const std::string& action,
                                    const std::string& value,
                                    const std::map<std::string, std::string>& options ) const
{
    AlterRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    AlterRoleResponse actualResponse_;
    submitRequest("/alter/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters a Role.
 * 
 * @param name  Name of the role to be altered. Must be an existing role.
 * @param action  Modification operation to be applied to the role.
 *                <ul>
 *                        <li> gpudb::alter_role_set_resource_group: Sets the
 *                resource group for an internal role. The resource group must
 *                exist, otherwise, an empty string assigns the role to the
 *                default resource group.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterRoleResponse& GPUdb::alterRole( const std::string& name,
                                     const std::string& action,
                                     const std::string& value,
                                     const std::map<std::string, std::string>& options,
                                     AlterRoleResponse& response_ ) const
{
    AlterRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    submitRequest("/alter/role", actualRequest_, response_, false);
    return response_;
}


/**
 * The {@link
 * #alterSystemProperties(const AlterSystemPropertiesRequest&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse GPUdb::alterSystemProperties( const AlterSystemPropertiesRequest& request_ ) const
{
    AlterSystemPropertiesResponse actualResponse_;
    submitRequest("/alter/system/properties", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * The {@link
 * #alterSystemProperties(const AlterSystemPropertiesRequest&,AlterSystemPropertiesResponse&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& GPUdb::alterSystemProperties( const AlterSystemPropertiesRequest& request_,
                                                             AlterSystemPropertiesResponse& response_ ) const
{
    submitRequest("/alter/system/properties", request_, response_, false);
    return response_;
}


/**
 * The {@link
 * #alterSystemProperties(const std::map<std::string, std::string>&,const std::map<std::string, std::string>&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 *                            <ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_sm_omp_threads:
 *                            Set the number of OpenMP threads that will be
 *                            used to service filter & aggregation requests
 *                            against collections to the specified integer
 *                            value.
 *                                    <li>
 *                            gpudb::alter_system_properties_kernel_omp_threads:
 *                            Set the number of kernel OpenMP threads to the
 *                            specified integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_concurrent_kernel_execution:
 *                            Enables concurrent kernel execution if the value
 *                            is @a true and disables it if the value is @a
 *                            false.
 *                            <ul>
 *                                    <li> gpudb::alter_system_properties_true
 *                                    <li> gpudb::alter_system_properties_false
 *                            </ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_subtask_concurrency_limit:
 *                            Sets the maximum number of simultaneous threads
 *                            allocated to a given request, on each rank. Note
 *                            that thread allocation may also be limted by
 *                            resource group limits and/or system load.
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_size: Sets
 *                            the chunk size of all new sets to the specified
 *                            integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_execution_mode:
 *                            Sets the execution_mode for kernel executions to
 *                            the specified string value. Possible values are
 *                            host, device, default (engine decides) or an
 *                            integer value that indicates max chunk size to
 *                            exec on host
 *                                    <li>
 *                            gpudb::alter_system_properties_flush_to_disk:
 *                            Flushes any changes to any tables to the
 *                            persistent store.  These changes include updates
 *                            to the vector store, object store, and text
 *                            search store, Value string is ignored
 *                                    <li>
 *                            gpudb::alter_system_properties_clear_cache:
 *                            Clears cached results.  Useful to allow repeated
 *                            timing of endpoints. Value string is ignored
 *                                    <li>
 *                            gpudb::alter_system_properties_communicator_test:
 *                            Invoke the communicator test and report timing
 *                            results. Value string is is a semicolon separated
 *                            list of <key>=<value> expressions.  Expressions
 *                            are: num_transactions=<num> where num is the
 *                            number of request reply transactions to invoke
 *                            per test; message_size=<bytes> where bytes is the
 *                            size of the messages to send in bytes;
 *                            check_values=<enabled> where if enabled is true
 *                            the value of the messages received are verified.
 *                                    <li>
 *                            gpudb::alter_system_properties_set_message_timers_enabled:
 *                            Enables the communicator test to collect
 *                            additional timing statistics when the value
 *                            string is @a true. Disables the collection when
 *                            the value string is @a false
 *                            <ul>
 *                                    <li> gpudb::alter_system_properties_true
 *                                    <li> gpudb::alter_system_properties_false
 *                            </ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_bulk_add_test:
 *                            Invoke the bulk add test and report timing
 *                            results. Value string is ignored.
 *                                    <li>
 *                            gpudb::alter_system_properties_network_speed:
 *                            Invoke the network speed test and report timing
 *                            results. Value string is a semicolon-separated
 *                            list of <key>=<value> expressions.  Valid
 *                            expressions are: seconds=<time> where time is the
 *                            time in seconds to run the test; data_size=<size>
 *                            where size is the size in bytes of the block to
 *                            be transferred; threads=<number of threads>;
 *                            to_ranks=<space-separated list of ranks> where
 *                            the list of ranks is the ranks that rank 0 will
 *                            send data to and get data from. If to_ranks is
 *                            unspecified then all worker ranks are used.
 *                                    <li>
 *                            gpudb::alter_system_properties_request_timeout:
 *                            Number of minutes after which filtering (e.g.,
 *                            /filter) and aggregating (e.g.,
 *                            /aggregate/groupby) queries will timeout.  The
 *                            default value is '20'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_get_records_size:
 *                            The maximum number of records the database will
 *                            serve for a given data retrieval call.  The
 *                            default value is '20000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_enable_audit:
 *                            Enable or disable auditing.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_headers:
 *                            Enable or disable auditing of request headers.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_body: Enable
 *                            or disable auditing of request bodies.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_data: Enable
 *                            or disable auditing of request data.
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_cache_enabled:
 *                            Enable chunk level query caching. Flushes the
 *                            chunk cache when value is false
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_cache_size:
 *                            Size of the chunk cache in bytes.  The default
 *                            value is '10000000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_synchronous_compression:
 *                            compress vector on set_compression (instead of
 *                            waiting for background thread).  The default
 *                            value is 'false'.
 *                            </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse GPUdb::alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                            const std::map<std::string, std::string>& options ) const
{
    AlterSystemPropertiesRequest actualRequest_;
    actualRequest_.propertyUpdatesMap = propertyUpdatesMap;
    actualRequest_.options = options;
    AlterSystemPropertiesResponse actualResponse_;
    submitRequest("/alter/system/properties", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * The {@link
 * #alterSystemProperties(const std::map<std::string, std::string>&,const std::map<std::string, std::string>&,AlterSystemPropertiesResponse&) const}
 * endpoint is primarily used to simplify the testing of the system and is not
 * expected to be used during normal execution.  Commands are given through the
 * @a propertyUpdatesMap whose keys are commands and values are strings
 * representing integer values (for example '8000') or boolean values ('true'
 * or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 *                            <ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_sm_omp_threads:
 *                            Set the number of OpenMP threads that will be
 *                            used to service filter & aggregation requests
 *                            against collections to the specified integer
 *                            value.
 *                                    <li>
 *                            gpudb::alter_system_properties_kernel_omp_threads:
 *                            Set the number of kernel OpenMP threads to the
 *                            specified integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_concurrent_kernel_execution:
 *                            Enables concurrent kernel execution if the value
 *                            is @a true and disables it if the value is @a
 *                            false.
 *                            <ul>
 *                                    <li> gpudb::alter_system_properties_true
 *                                    <li> gpudb::alter_system_properties_false
 *                            </ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_subtask_concurrency_limit:
 *                            Sets the maximum number of simultaneous threads
 *                            allocated to a given request, on each rank. Note
 *                            that thread allocation may also be limted by
 *                            resource group limits and/or system load.
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_size: Sets
 *                            the chunk size of all new sets to the specified
 *                            integer value.
 *                                    <li>
 *                            gpudb::alter_system_properties_execution_mode:
 *                            Sets the execution_mode for kernel executions to
 *                            the specified string value. Possible values are
 *                            host, device, default (engine decides) or an
 *                            integer value that indicates max chunk size to
 *                            exec on host
 *                                    <li>
 *                            gpudb::alter_system_properties_flush_to_disk:
 *                            Flushes any changes to any tables to the
 *                            persistent store.  These changes include updates
 *                            to the vector store, object store, and text
 *                            search store, Value string is ignored
 *                                    <li>
 *                            gpudb::alter_system_properties_clear_cache:
 *                            Clears cached results.  Useful to allow repeated
 *                            timing of endpoints. Value string is ignored
 *                                    <li>
 *                            gpudb::alter_system_properties_communicator_test:
 *                            Invoke the communicator test and report timing
 *                            results. Value string is is a semicolon separated
 *                            list of <key>=<value> expressions.  Expressions
 *                            are: num_transactions=<num> where num is the
 *                            number of request reply transactions to invoke
 *                            per test; message_size=<bytes> where bytes is the
 *                            size of the messages to send in bytes;
 *                            check_values=<enabled> where if enabled is true
 *                            the value of the messages received are verified.
 *                                    <li>
 *                            gpudb::alter_system_properties_set_message_timers_enabled:
 *                            Enables the communicator test to collect
 *                            additional timing statistics when the value
 *                            string is @a true. Disables the collection when
 *                            the value string is @a false
 *                            <ul>
 *                                    <li> gpudb::alter_system_properties_true
 *                                    <li> gpudb::alter_system_properties_false
 *                            </ul>
 *                                    <li>
 *                            gpudb::alter_system_properties_bulk_add_test:
 *                            Invoke the bulk add test and report timing
 *                            results. Value string is ignored.
 *                                    <li>
 *                            gpudb::alter_system_properties_network_speed:
 *                            Invoke the network speed test and report timing
 *                            results. Value string is a semicolon-separated
 *                            list of <key>=<value> expressions.  Valid
 *                            expressions are: seconds=<time> where time is the
 *                            time in seconds to run the test; data_size=<size>
 *                            where size is the size in bytes of the block to
 *                            be transferred; threads=<number of threads>;
 *                            to_ranks=<space-separated list of ranks> where
 *                            the list of ranks is the ranks that rank 0 will
 *                            send data to and get data from. If to_ranks is
 *                            unspecified then all worker ranks are used.
 *                                    <li>
 *                            gpudb::alter_system_properties_request_timeout:
 *                            Number of minutes after which filtering (e.g.,
 *                            /filter) and aggregating (e.g.,
 *                            /aggregate/groupby) queries will timeout.  The
 *                            default value is '20'.
 *                                    <li>
 *                            gpudb::alter_system_properties_max_get_records_size:
 *                            The maximum number of records the database will
 *                            serve for a given data retrieval call.  The
 *                            default value is '20000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_enable_audit:
 *                            Enable or disable auditing.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_headers:
 *                            Enable or disable auditing of request headers.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_body: Enable
 *                            or disable auditing of request bodies.
 *                                    <li>
 *                            gpudb::alter_system_properties_audit_data: Enable
 *                            or disable auditing of request data.
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_cache_enabled:
 *                            Enable chunk level query caching. Flushes the
 *                            chunk cache when value is false
 *                                    <li>
 *                            gpudb::alter_system_properties_chunk_cache_size:
 *                            Size of the chunk cache in bytes.  The default
 *                            value is '10000000'.
 *                                    <li>
 *                            gpudb::alter_system_properties_synchronous_compression:
 *                            compress vector on set_compression (instead of
 *                            waiting for background thread).  The default
 *                            value is 'false'.
 *                            </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& GPUdb::alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                             const std::map<std::string, std::string>& options,
                                                             AlterSystemPropertiesResponse& response_ ) const
{
    AlterSystemPropertiesRequest actualRequest_;
    actualRequest_.propertyUpdatesMap = propertyUpdatesMap;
    actualRequest_.options = options;
    submitRequest("/alter/system/properties", actualRequest_, response_, false);
    return response_;
}


/**
 * Apply various modifications to a table, view, or collection.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified, including
 * whether it is <a href="../../concepts/compression.html"
 * target="_top">compressed</a> or not.
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Create or delete a <a href="../../concepts/tables.html#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../concepts/tables.html#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../concepts/tables.html#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../rm/concepts.html#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../concepts/materialized_views.html" target="_top">materialized
 * view</a>.
 * <p>
 * Set the <a href="../../concepts/ttl.html" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables, views, or collections.  When applied to collections, every
 * contained
 * table & view that is not protected will have its TTL set to the given value.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * <p>
 * Change the <a href="../../concepts/protection.html"
 * target="_top">protection</a> mode to prevent or
 * allow automatic expiration. This can be applied to tables, views, and
 * collections.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse GPUdb::alterTable( const AlterTableRequest& request_ ) const
{
    AlterTableResponse actualResponse_;
    submitRequest("/alter/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Apply various modifications to a table, view, or collection.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified, including
 * whether it is <a href="../../concepts/compression.html"
 * target="_top">compressed</a> or not.
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Create or delete a <a href="../../concepts/tables.html#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../concepts/tables.html#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../concepts/tables.html#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../rm/concepts.html#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../concepts/materialized_views.html" target="_top">materialized
 * view</a>.
 * <p>
 * Set the <a href="../../concepts/ttl.html" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables, views, or collections.  When applied to collections, every
 * contained
 * table & view that is not protected will have its TTL set to the given value.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * <p>
 * Change the <a href="../../concepts/protection.html"
 * target="_top">protection</a> mode to prevent or
 * allow automatic expiration. This can be applied to tables, views, and
 * collections.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& GPUdb::alterTable( const AlterTableRequest& request_,
                                       AlterTableResponse& response_ ) const
{
    submitRequest("/alter/table", request_, response_, false);
    return response_;
}


/**
 * Apply various modifications to a table, view, or collection.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified, including
 * whether it is <a href="../../concepts/compression.html"
 * target="_top">compressed</a> or not.
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Create or delete a <a href="../../concepts/tables.html#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../concepts/tables.html#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../concepts/tables.html#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../rm/concepts.html#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../concepts/materialized_views.html" target="_top">materialized
 * view</a>.
 * <p>
 * Set the <a href="../../concepts/ttl.html" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables, views, or collections.  When applied to collections, every
 * contained
 * table & view that is not protected will have its TTL set to the given value.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * <p>
 * Change the <a href="../../concepts/protection.html"
 * target="_top">protection</a> mode to prevent or
 * allow automatic expiration. This can be applied to tables, views, and
 * collections.
 * 
 * @param tableName  Table on which the operation will be performed. Must be an
 *                   existing table, view, or collection.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_table_allow_homogeneous_tables: No
 *                longer supported; action will be ignored.
 *                        <li> gpudb::alter_table_create_index: Creates an <a
 *                href="../../concepts/indexes.html#column-index"
 *                target="_top">index</a> on the column name specified in @a
 *                value. If this column is already indexed, an error will be
 *                returned.
 *                        <li> gpudb::alter_table_delete_index: Deletes an
 *                existing <a href="../../concepts/indexes.html#column-index"
 *                target="_top">index</a> on the column name specified in @a
 *                value. If this column does not have indexing turned on, an
 *                error will be returned.
 *                        <li> gpudb::alter_table_move_to_collection: Moves a
 *                table or view into a collection named @a value.  If the
 *                collection provided is non-existent, the collection will be
 *                automatically created. If @a value is empty, then the table
 *                or view will be top-level.
 *                        <li> gpudb::alter_table_protected: Sets whether the
 *                given @a tableName should be <a
 *                href="../../concepts/protection.html"
 *                target="_top">protected</a> or not. The @a value must be
 *                either 'true' or 'false'.
 *                        <li> gpudb::alter_table_rename_table: Renames a
 *                table, view or collection to @a value. Has the same naming
 *                restrictions as <a href="../../concepts/tables.html"
 *                target="_top">tables</a>.
 *                        <li> gpudb::alter_table_ttl: Sets the <a
 *                href="../../concepts/ttl.html" target="_top">time-to-live</a>
 *                in minutes of the table, view, or collection specified in @a
 *                tableName.
 *                        <li> gpudb::alter_table_add_column: Adds the column
 *                specified in @a value to the table specified in @a tableName.
 *                Use @a column_type and @a column_properties in @a options to
 *                set the column's type and properties, respectively.
 *                        <li> gpudb::alter_table_change_column: Changes type
 *                and properties of the column specified in @a value.  Use @a
 *                column_type and @a column_properties in @a options to set the
 *                column's type and properties, respectively. Note that primary
 *                key and/or shard key columns cannot be changed. All
 *                unchanging column properties must be listed for the change to
 *                take place, e.g., to add dictionary encoding to an existing
 *                'char4' column, both 'char4' and 'dict' must be specified in
 *                the @a options map.
 *                        <li> gpudb::alter_table_set_column_compression:
 *                Modifies the <a href="../../concepts/compression.html"
 *                target="_top">compression</a> setting on the column specified
 *                in @a value to the compression type specified in @a
 *                compression_type.
 *                        <li> gpudb::alter_table_delete_column: Deletes the
 *                column specified in @a value from the table specified in @a
 *                tableName.
 *                        <li> gpudb::alter_table_create_foreign_key: Creates a
 *                <a href="../../concepts/tables.html#foreign-key"
 *                target="_top">foreign key</a> specified in @a value using the
 *                format '(source_column_name [, ...]) references
 *                target_table_name(primary_key_column_name [, ...]) [as
 *                foreign_key_name]'.
 *                        <li> gpudb::alter_table_delete_foreign_key: Deletes a
 *                <a href="../../concepts/tables.html#foreign-key"
 *                target="_top">foreign key</a>.  The @a value should be the
 *                foreign_key_name specified when creating the key or the
 *                complete string used to define it.
 *                        <li> gpudb::alter_table_add_partition: Adds the
 *                partition specified in @a value, to either a <a
 *                href="../../concepts/tables.html#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../concepts/tables.html#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_remove_partition: Removes the
 *                partition specified in @a value (and relocates all of its
 *                data to the default partition) from either a <a
 *                href="../../concepts/tables.html#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../concepts/tables.html#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_delete_partition: Deletes the
 *                partition specified in @a value (and all of its data) from
 *                either a <a
 *                href="../../concepts/tables.html#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../concepts/tables.html#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_set_global_access_mode: Sets
 *                the global access mode (i.e. locking) for the table specified
 *                in @a tableName. Specify the access mode in @a value. Valid
 *                modes are 'no_access', 'read_only', 'write_only' and
 *                'read_write'.
 *                        <li> gpudb::alter_table_refresh: Replays all the
 *                table creation commands required to create this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a>.
 *                        <li> gpudb::alter_table_set_refresh_method: Sets the
 *                method by which this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a> is refreshed to the
 *                method specified in @a value - one of 'manual', 'periodic',
 *                'on_change'.
 *                        <li> gpudb::alter_table_set_refresh_start_time: Sets
 *                the time to start periodic refreshes of this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a> to the datetime string
 *                specified in @a value with format 'YYYY-MM-DD HH:MM:SS'.
 *                Subsequent refreshes occur at the specified time + N * the
 *                refresh period.
 *                        <li> gpudb::alter_table_set_refresh_period: Sets the
 *                time interval in seconds at which to refresh this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a> to the value specified in
 *                @a value.  Also, sets the refresh method to periodic if not
 *                already set.
 *                        <li>
 *                gpudb::alter_table_remove_text_search_attributes: Removes <a
 *                href="../../concepts/full_text_search.html"
 *                target="_top">text search</a> attribute from all columns.
 *                        <li> gpudb::alter_table_set_strategy_definition: Sets
 *                the <a href="../../rm/concepts.html#tier-strategies"
 *                target="_top">tier strategy</a> for the table and its columns
 *                to the one specified in @a value, replacing the existing tier
 *                strategy in its entirety. See <a
 *                href="../../rm/concepts.html#tier-strategies"
 *                target="_top">tier strategy usage</a> for format and <a
 *                href="../../rm/usage.html#tier-strategies" target="_top">tier
 *                strategy examples</a> for examples.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.  For
 *               example, if @a action is @a add_column, this would be the
 *               column name; while the column's definition would be covered by
 *               the @a column_type, @a column_properties, @a
 *               column_default_value, and @a add_column_expression in @a
 *               options.  If @a action is @a ttl, it would be the number of
 *               minutes for the new TTL. If @a action is @a refresh, this
 *               field would be blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_table_action
 *                         <li> gpudb::alter_table_column_name
 *                         <li> gpudb::alter_table_table_name
 *                         <li> gpudb::alter_table_column_default_value: When
 *                 adding a column, set a default value for existing records.
 *                 For nullable columns, the default value will be null,
 *                 regardless of data type.
 *                         <li> gpudb::alter_table_column_properties: When
 *                 adding or changing a column, set the column properties
 *                 (strings, separated by a comma: data, store_only,
 *                 text_search, char8, int8 etc).
 *                         <li> gpudb::alter_table_column_type: When adding or
 *                 changing a column, set the column type (strings, separated
 *                 by a comma: int, double, string, null etc).
 *                         <li> gpudb::alter_table_compression_type: When
 *                 setting column compression (@a set_column_compression for @a
 *                 action), compression type to use: @a none (to use no
 *                 compression) or a valid compression type.
 *                 <ul>
 *                         <li> gpudb::alter_table_none
 *                         <li> gpudb::alter_table_snappy
 *                         <li> gpudb::alter_table_lz4
 *                         <li> gpudb::alter_table_lz4hc
 *                 </ul>
 *                 The default value is gpudb::alter_table_snappy.
 *                         <li> gpudb::alter_table_copy_values_from_column:
 *                 Deprecated.  Please use @a add_column_expression instead.
 *                         <li> gpudb::alter_table_rename_column: When changing
 *                 a column, specify new column name.
 *                         <li> gpudb::alter_table_validate_change_column: When
 *                 changing a column, validate the change before applying it.
 *                 If @a true, then validate all values. A value too large (or
 *                 too long) for the new type will prevent any change. If @a
 *                 false, then when a value is too large or long, it will be
 *                 truncated.
 *                 <ul>
 *                         <li> gpudb::alter_table_true: true
 *                         <li> gpudb::alter_table_false: false
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_update_last_access_time:
 *                 Indicates whether the <a href="../../concepts/ttl.html"
 *                 target="_top">time-to-live</a> (TTL) expiration countdown
 *                 timer should be reset to the table's TTL.
 *                 <ul>
 *                         <li> gpudb::alter_table_true: Reset the expiration
 *                 countdown timer to the table's configured TTL.
 *                         <li> gpudb::alter_table_false: Don't reset the
 *                 timer; expiration countdown will continue from where it is,
 *                 as if the table had not been accessed.
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_add_column_expression: When
 *                 adding a column, an optional expression to use for the new
 *                 column's values. Any valid expression may be used, including
 *                 one containing references to existing columns in the same
 *                 table.
 *                         <li> gpudb::alter_table_strategy_definition:
 *                 Optional parameter for specifying the <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns when @a action is @a set_strategy_definition,
 *                 replacing the existing tier strategy in its entirety. See <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy usage</a> for format and <a
 *                 href="../../rm/usage.html#tier-strategies"
 *                 target="_top">tier strategy examples</a> for examples.  This
 *                 option will be ignored if @a value is also specified.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse GPUdb::alterTable( const std::string& tableName,
                                      const std::string& action,
                                      const std::string& value,
                                      const std::map<std::string, std::string>& options ) const
{
    AlterTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    AlterTableResponse actualResponse_;
    submitRequest("/alter/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Apply various modifications to a table, view, or collection.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified, including
 * whether it is <a href="../../concepts/compression.html"
 * target="_top">compressed</a> or not.
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Create or delete a <a href="../../concepts/tables.html#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../concepts/tables.html#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../concepts/tables.html#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../rm/concepts.html#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../concepts/materialized_views.html" target="_top">materialized
 * view</a>.
 * <p>
 * Set the <a href="../../concepts/ttl.html" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables, views, or collections.  When applied to collections, every
 * contained
 * table & view that is not protected will have its TTL set to the given value.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 * <p>
 * Change the <a href="../../concepts/protection.html"
 * target="_top">protection</a> mode to prevent or
 * allow automatic expiration. This can be applied to tables, views, and
 * collections.
 * 
 * @param tableName  Table on which the operation will be performed. Must be an
 *                   existing table, view, or collection.
 * @param action  Modification operation to be applied
 *                <ul>
 *                        <li> gpudb::alter_table_allow_homogeneous_tables: No
 *                longer supported; action will be ignored.
 *                        <li> gpudb::alter_table_create_index: Creates an <a
 *                href="../../concepts/indexes.html#column-index"
 *                target="_top">index</a> on the column name specified in @a
 *                value. If this column is already indexed, an error will be
 *                returned.
 *                        <li> gpudb::alter_table_delete_index: Deletes an
 *                existing <a href="../../concepts/indexes.html#column-index"
 *                target="_top">index</a> on the column name specified in @a
 *                value. If this column does not have indexing turned on, an
 *                error will be returned.
 *                        <li> gpudb::alter_table_move_to_collection: Moves a
 *                table or view into a collection named @a value.  If the
 *                collection provided is non-existent, the collection will be
 *                automatically created. If @a value is empty, then the table
 *                or view will be top-level.
 *                        <li> gpudb::alter_table_protected: Sets whether the
 *                given @a tableName should be <a
 *                href="../../concepts/protection.html"
 *                target="_top">protected</a> or not. The @a value must be
 *                either 'true' or 'false'.
 *                        <li> gpudb::alter_table_rename_table: Renames a
 *                table, view or collection to @a value. Has the same naming
 *                restrictions as <a href="../../concepts/tables.html"
 *                target="_top">tables</a>.
 *                        <li> gpudb::alter_table_ttl: Sets the <a
 *                href="../../concepts/ttl.html" target="_top">time-to-live</a>
 *                in minutes of the table, view, or collection specified in @a
 *                tableName.
 *                        <li> gpudb::alter_table_add_column: Adds the column
 *                specified in @a value to the table specified in @a tableName.
 *                Use @a column_type and @a column_properties in @a options to
 *                set the column's type and properties, respectively.
 *                        <li> gpudb::alter_table_change_column: Changes type
 *                and properties of the column specified in @a value.  Use @a
 *                column_type and @a column_properties in @a options to set the
 *                column's type and properties, respectively. Note that primary
 *                key and/or shard key columns cannot be changed. All
 *                unchanging column properties must be listed for the change to
 *                take place, e.g., to add dictionary encoding to an existing
 *                'char4' column, both 'char4' and 'dict' must be specified in
 *                the @a options map.
 *                        <li> gpudb::alter_table_set_column_compression:
 *                Modifies the <a href="../../concepts/compression.html"
 *                target="_top">compression</a> setting on the column specified
 *                in @a value to the compression type specified in @a
 *                compression_type.
 *                        <li> gpudb::alter_table_delete_column: Deletes the
 *                column specified in @a value from the table specified in @a
 *                tableName.
 *                        <li> gpudb::alter_table_create_foreign_key: Creates a
 *                <a href="../../concepts/tables.html#foreign-key"
 *                target="_top">foreign key</a> specified in @a value using the
 *                format '(source_column_name [, ...]) references
 *                target_table_name(primary_key_column_name [, ...]) [as
 *                foreign_key_name]'.
 *                        <li> gpudb::alter_table_delete_foreign_key: Deletes a
 *                <a href="../../concepts/tables.html#foreign-key"
 *                target="_top">foreign key</a>.  The @a value should be the
 *                foreign_key_name specified when creating the key or the
 *                complete string used to define it.
 *                        <li> gpudb::alter_table_add_partition: Adds the
 *                partition specified in @a value, to either a <a
 *                href="../../concepts/tables.html#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../concepts/tables.html#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_remove_partition: Removes the
 *                partition specified in @a value (and relocates all of its
 *                data to the default partition) from either a <a
 *                href="../../concepts/tables.html#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../concepts/tables.html#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_delete_partition: Deletes the
 *                partition specified in @a value (and all of its data) from
 *                either a <a
 *                href="../../concepts/tables.html#partitioning-by-range"
 *                target="_top">range-partitioned</a> or <a
 *                href="../../concepts/tables.html#partitioning-by-list-manual"
 *                target="_top">manual list-partitioned</a> table.
 *                        <li> gpudb::alter_table_set_global_access_mode: Sets
 *                the global access mode (i.e. locking) for the table specified
 *                in @a tableName. Specify the access mode in @a value. Valid
 *                modes are 'no_access', 'read_only', 'write_only' and
 *                'read_write'.
 *                        <li> gpudb::alter_table_refresh: Replays all the
 *                table creation commands required to create this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a>.
 *                        <li> gpudb::alter_table_set_refresh_method: Sets the
 *                method by which this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a> is refreshed to the
 *                method specified in @a value - one of 'manual', 'periodic',
 *                'on_change'.
 *                        <li> gpudb::alter_table_set_refresh_start_time: Sets
 *                the time to start periodic refreshes of this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a> to the datetime string
 *                specified in @a value with format 'YYYY-MM-DD HH:MM:SS'.
 *                Subsequent refreshes occur at the specified time + N * the
 *                refresh period.
 *                        <li> gpudb::alter_table_set_refresh_period: Sets the
 *                time interval in seconds at which to refresh this <a
 *                href="../../concepts/materialized_views.html"
 *                target="_top">materialized view</a> to the value specified in
 *                @a value.  Also, sets the refresh method to periodic if not
 *                already set.
 *                        <li>
 *                gpudb::alter_table_remove_text_search_attributes: Removes <a
 *                href="../../concepts/full_text_search.html"
 *                target="_top">text search</a> attribute from all columns.
 *                        <li> gpudb::alter_table_set_strategy_definition: Sets
 *                the <a href="../../rm/concepts.html#tier-strategies"
 *                target="_top">tier strategy</a> for the table and its columns
 *                to the one specified in @a value, replacing the existing tier
 *                strategy in its entirety. See <a
 *                href="../../rm/concepts.html#tier-strategies"
 *                target="_top">tier strategy usage</a> for format and <a
 *                href="../../rm/usage.html#tier-strategies" target="_top">tier
 *                strategy examples</a> for examples.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.  For
 *               example, if @a action is @a add_column, this would be the
 *               column name; while the column's definition would be covered by
 *               the @a column_type, @a column_properties, @a
 *               column_default_value, and @a add_column_expression in @a
 *               options.  If @a action is @a ttl, it would be the number of
 *               minutes for the new TTL. If @a action is @a refresh, this
 *               field would be blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_table_action
 *                         <li> gpudb::alter_table_column_name
 *                         <li> gpudb::alter_table_table_name
 *                         <li> gpudb::alter_table_column_default_value: When
 *                 adding a column, set a default value for existing records.
 *                 For nullable columns, the default value will be null,
 *                 regardless of data type.
 *                         <li> gpudb::alter_table_column_properties: When
 *                 adding or changing a column, set the column properties
 *                 (strings, separated by a comma: data, store_only,
 *                 text_search, char8, int8 etc).
 *                         <li> gpudb::alter_table_column_type: When adding or
 *                 changing a column, set the column type (strings, separated
 *                 by a comma: int, double, string, null etc).
 *                         <li> gpudb::alter_table_compression_type: When
 *                 setting column compression (@a set_column_compression for @a
 *                 action), compression type to use: @a none (to use no
 *                 compression) or a valid compression type.
 *                 <ul>
 *                         <li> gpudb::alter_table_none
 *                         <li> gpudb::alter_table_snappy
 *                         <li> gpudb::alter_table_lz4
 *                         <li> gpudb::alter_table_lz4hc
 *                 </ul>
 *                 The default value is gpudb::alter_table_snappy.
 *                         <li> gpudb::alter_table_copy_values_from_column:
 *                 Deprecated.  Please use @a add_column_expression instead.
 *                         <li> gpudb::alter_table_rename_column: When changing
 *                 a column, specify new column name.
 *                         <li> gpudb::alter_table_validate_change_column: When
 *                 changing a column, validate the change before applying it.
 *                 If @a true, then validate all values. A value too large (or
 *                 too long) for the new type will prevent any change. If @a
 *                 false, then when a value is too large or long, it will be
 *                 truncated.
 *                 <ul>
 *                         <li> gpudb::alter_table_true: true
 *                         <li> gpudb::alter_table_false: false
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_update_last_access_time:
 *                 Indicates whether the <a href="../../concepts/ttl.html"
 *                 target="_top">time-to-live</a> (TTL) expiration countdown
 *                 timer should be reset to the table's TTL.
 *                 <ul>
 *                         <li> gpudb::alter_table_true: Reset the expiration
 *                 countdown timer to the table's configured TTL.
 *                         <li> gpudb::alter_table_false: Don't reset the
 *                 timer; expiration countdown will continue from where it is,
 *                 as if the table had not been accessed.
 *                 </ul>
 *                 The default value is gpudb::alter_table_true.
 *                         <li> gpudb::alter_table_add_column_expression: When
 *                 adding a column, an optional expression to use for the new
 *                 column's values. Any valid expression may be used, including
 *                 one containing references to existing columns in the same
 *                 table.
 *                         <li> gpudb::alter_table_strategy_definition:
 *                 Optional parameter for specifying the <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns when @a action is @a set_strategy_definition,
 *                 replacing the existing tier strategy in its entirety. See <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy usage</a> for format and <a
 *                 href="../../rm/usage.html#tier-strategies"
 *                 target="_top">tier strategy examples</a> for examples.  This
 *                 option will be ignored if @a value is also specified.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& GPUdb::alterTable( const std::string& tableName,
                                       const std::string& action,
                                       const std::string& value,
                                       const std::map<std::string, std::string>& options,
                                       AlterTableResponse& response_ ) const
{
    AlterTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    submitRequest("/alter/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified.
 * <p>
 * Set or unset <a href="../../concepts/compression.html"
 * target="_top">compression</a> for a column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableColumnsResponse GPUdb::alterTableColumns( const AlterTableColumnsRequest& request_ ) const
{
    AlterTableColumnsResponse actualResponse_;
    submitRequest("/alter/table/columns", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified.
 * <p>
 * Set or unset <a href="../../concepts/compression.html"
 * target="_top">compression</a> for a column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableColumnsResponse& GPUdb::alterTableColumns( const AlterTableColumnsRequest& request_,
                                                     AlterTableColumnsResponse& response_ ) const
{
    submitRequest("/alter/table/columns", request_, response_, false);
    return response_;
}


/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified.
 * <p>
 * Set or unset <a href="../../concepts/compression.html"
 * target="_top">compression</a> for a column.
 * 
 * @param tableName  Table on which the operation will be performed. Must be an
 *                   existing table or view.
 * @param columnAlterations  list of alter table add/delete/change column
 *                           requests - all for the same table.
 *                                           each request is a map that
 *                           includes 'column_name', 'action' and the options
 *                           specific for the action,
 *                                           note that the same options as in
 *                           alter table requests but in the same map as the
 *                           column name and the action. For example:
 *                           [{'column_name':'col_1','action':'change_column','rename_column':'col_2'},
 *                           {'column_name':'col_1','action':'add_column',
 *                           'type':'int','default_value':'1'}
 *                                           ]
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableColumnsResponse GPUdb::alterTableColumns( const std::string& tableName,
                                                    const std::vector<std::map<std::string, std::string> >& columnAlterations,
                                                    const std::map<std::string, std::string>& options ) const
{
    AlterTableColumnsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnAlterations = columnAlterations;
    actualRequest_.options = options;
    AlterTableColumnsResponse actualResponse_;
    submitRequest("/alter/table/columns", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../concepts/indexes.html#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../concepts/types.html" target="_top">type and properties</a>
 * modified.
 * <p>
 * Set or unset <a href="../../concepts/compression.html"
 * target="_top">compression</a> for a column.
 * 
 * @param tableName  Table on which the operation will be performed. Must be an
 *                   existing table or view.
 * @param columnAlterations  list of alter table add/delete/change column
 *                           requests - all for the same table.
 *                                           each request is a map that
 *                           includes 'column_name', 'action' and the options
 *                           specific for the action,
 *                                           note that the same options as in
 *                           alter table requests but in the same map as the
 *                           column name and the action. For example:
 *                           [{'column_name':'col_1','action':'change_column','rename_column':'col_2'},
 *                           {'column_name':'col_1','action':'add_column',
 *                           'type':'int','default_value':'1'}
 *                                           ]
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableColumnsResponse& GPUdb::alterTableColumns( const std::string& tableName,
                                                     const std::vector<std::map<std::string, std::string> >& columnAlterations,
                                                     const std::map<std::string, std::string>& options,
                                                     AlterTableColumnsResponse& response_ ) const
{
    AlterTableColumnsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnAlterations = columnAlterations;
    actualRequest_.options = options;
    submitRequest("/alter/table/columns", actualRequest_, response_, false);
    return response_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse GPUdb::alterTableMetadata( const AlterTableMetadataRequest& request_ ) const
{
    AlterTableMetadataResponse actualResponse_;
    submitRequest("/alter/table/metadata", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& GPUdb::alterTableMetadata( const AlterTableMetadataRequest& request_,
                                                       AlterTableMetadataResponse& response_ ) const
{
    submitRequest("/alter/table/metadata", request_, response_, false);
    return response_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated. All
 *                    specified tables must exist, or an error will be
 *                    returned.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse GPUdb::alterTableMetadata( const std::vector<std::string>& tableNames,
                                                      const std::map<std::string, std::string>& metadataMap,
                                                      const std::map<std::string, std::string>& options ) const
{
    AlterTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.metadataMap = metadataMap;
    actualRequest_.options = options;
    AlterTableMetadataResponse actualResponse_;
    submitRequest("/alter/table/metadata", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated. All
 *                    specified tables must exist, or an error will be
 *                    returned.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& GPUdb::alterTableMetadata( const std::vector<std::string>& tableNames,
                                                       const std::map<std::string, std::string>& metadataMap,
                                                       const std::map<std::string, std::string>& options,
                                                       AlterTableMetadataResponse& response_ ) const
{
    AlterTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.metadataMap = metadataMap;
    actualRequest_.options = options;
    submitRequest("/alter/table/metadata", actualRequest_, response_, false);
    return response_;
}


/**
 * Alters properties of an exisiting <a
 * href="../../rm/concepts.html#storage-tiers" target="_top">tier</a> to
 * facilitate <a href="../../rm/concepts.html" target="_top">resource
 * management</a>.
 * <p>
 * To disable <a href="../../rm/concepts.html#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>, set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTierResponse GPUdb::alterTier( const AlterTierRequest& request_ ) const
{
    AlterTierResponse actualResponse_;
    submitRequest("/alter/tier", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters properties of an exisiting <a
 * href="../../rm/concepts.html#storage-tiers" target="_top">tier</a> to
 * facilitate <a href="../../rm/concepts.html" target="_top">resource
 * management</a>.
 * <p>
 * To disable <a href="../../rm/concepts.html#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>, set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTierResponse& GPUdb::alterTier( const AlterTierRequest& request_,
                                     AlterTierResponse& response_ ) const
{
    submitRequest("/alter/tier", request_, response_, false);
    return response_;
}


/**
 * Alters properties of an exisiting <a
 * href="../../rm/concepts.html#storage-tiers" target="_top">tier</a> to
 * facilitate <a href="../../rm/concepts.html" target="_top">resource
 * management</a>.
 * <p>
 * To disable <a href="../../rm/concepts.html#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>, set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param name  Name of the tier to be altered. Must be an existing tier group
 *              name.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_tier_capacity: Maximum size in
 *                 bytes this tier may hold at once.
 *                         <li> gpudb::alter_tier_high_watermark: Threshold of
 *                 usage of this tier's resource that, once exceeded, will
 *                 trigger watermark-based eviction from this tier.
 *                         <li> gpudb::alter_tier_low_watermark: Threshold of
 *                 resource usage that, once fallen below after crossing the @a
 *                 high_watermark, will cease watermark-based eviction from
 *                 this tier.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTierResponse GPUdb::alterTier( const std::string& name,
                                    const std::map<std::string, std::string>& options ) const
{
    AlterTierRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    AlterTierResponse actualResponse_;
    submitRequest("/alter/tier", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters properties of an exisiting <a
 * href="../../rm/concepts.html#storage-tiers" target="_top">tier</a> to
 * facilitate <a href="../../rm/concepts.html" target="_top">resource
 * management</a>.
 * <p>
 * To disable <a href="../../rm/concepts.html#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>, set both @a high_watermark and
 * @a low_watermark to 100.
 * 
 * @param name  Name of the tier to be altered. Must be an existing tier group
 *              name.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::alter_tier_capacity: Maximum size in
 *                 bytes this tier may hold at once.
 *                         <li> gpudb::alter_tier_high_watermark: Threshold of
 *                 usage of this tier's resource that, once exceeded, will
 *                 trigger watermark-based eviction from this tier.
 *                         <li> gpudb::alter_tier_low_watermark: Threshold of
 *                 resource usage that, once fallen below after crossing the @a
 *                 high_watermark, will cease watermark-based eviction from
 *                 this tier.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTierResponse& GPUdb::alterTier( const std::string& name,
                                     const std::map<std::string, std::string>& options,
                                     AlterTierResponse& response_ ) const
{
    AlterTierRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/alter/tier", actualRequest_, response_, false);
    return response_;
}


/**
 * Alters a user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterUserResponse GPUdb::alterUser( const AlterUserRequest& request_ ) const
{
    AlterUserResponse actualResponse_;
    submitRequest("/alter/user", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters a user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterUserResponse& GPUdb::alterUser( const AlterUserRequest& request_,
                                     AlterUserResponse& response_ ) const
{
    submitRequest("/alter/user", request_, response_, false);
    return response_;
}


/**
 * Alters a user.
 * 
 * @param name  Name of the user to be altered. Must be an existing user.
 * @param action  Modification operation to be applied to the user.
 *                <ul>
 *                        <li> gpudb::alter_user_set_password: Sets the
 *                password of the user. The user must be an internal user.
 *                        <li> gpudb::alter_user_set_resource_group: Sets the
 *                resource group for an internal user. The resource group must
 *                exist, otherwise, an empty string assigns the user to the
 *                default resource group.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterUserResponse GPUdb::alterUser( const std::string& name,
                                    const std::string& action,
                                    const std::string& value,
                                    const std::map<std::string, std::string>& options ) const
{
    AlterUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    AlterUserResponse actualResponse_;
    submitRequest("/alter/user", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters a user.
 * 
 * @param name  Name of the user to be altered. Must be an existing user.
 * @param action  Modification operation to be applied to the user.
 *                <ul>
 *                        <li> gpudb::alter_user_set_password: Sets the
 *                password of the user. The user must be an internal user.
 *                        <li> gpudb::alter_user_set_resource_group: Sets the
 *                resource group for an internal user. The resource group must
 *                exist, otherwise, an empty string assigns the user to the
 *                default resource group.
 *                </ul>
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterUserResponse& GPUdb::alterUser( const std::string& name,
                                     const std::string& action,
                                     const std::string& value,
                                     const std::map<std::string, std::string>& options,
                                     AlterUserResponse& response_ ) const
{
    AlterUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    submitRequest("/alter/user", actualRequest_, response_, false);
    return response_;
}


/**
 * Append (or insert) all records from a source table (specified by @a
 * sourceTableName) to a particular target table (specified by @a tableName).
 * The field map (specified by @a fieldMap) holds the user specified map of
 * target table column names with their mapped source column names.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AppendRecordsResponse GPUdb::appendRecords( const AppendRecordsRequest& request_ ) const
{
    AppendRecordsResponse actualResponse_;
    submitRequest("/append/records", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Append (or insert) all records from a source table (specified by @a
 * sourceTableName) to a particular target table (specified by @a tableName).
 * The field map (specified by @a fieldMap) holds the user specified map of
 * target table column names with their mapped source column names.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AppendRecordsResponse& GPUdb::appendRecords( const AppendRecordsRequest& request_,
                                             AppendRecordsResponse& response_ ) const
{
    submitRequest("/append/records", request_, response_, false);
    return response_;
}


/**
 * Append (or insert) all records from a source table (specified by @a
 * sourceTableName) to a particular target table (specified by @a tableName).
 * The field map (specified by @a fieldMap) holds the user specified map of
 * target table column names with their mapped source column names.
 * 
 * @param tableName  The table name for the records to be appended. Must be an
 *                   existing table.
 * @param sourceTableName  The source table name to get records from. Must be
 *                         an existing table name.
 * @param fieldMap  Contains the mapping of column names from the target table
 *                  (specified by @a tableName) as the keys, and corresponding
 *                  column names or expressions (e.g., 'col_name+1') from the
 *                  source table (specified by @a sourceTableName). Must be
 *                  existing column names in source table and target table, and
 *                  their types must be matched. For details on using
 *                  expressions, see <a href="../../concepts/expressions.html"
 *                  target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::append_records_offset: A positive
 *                 integer indicating the number of initial results to skip
 *                 from @a sourceTableName. Default is 0. The minimum allowed
 *                 value is 0. The maximum allowed value is MAX_INT.  The
 *                 default value is '0'.
 *                         <li> gpudb::append_records_limit: A positive integer
 *                 indicating the maximum number of results to be returned from
 *                 @a sourceTableName. Or END_OF_SET (-9999) to indicate that
 *                 the max number of results should be returned.  The default
 *                 value is '-9999'.
 *                         <li> gpudb::append_records_expression: Optional
 *                 filter expression to apply to the @a sourceTableName.  The
 *                 default value is ''.
 *                         <li> gpudb::append_records_order_by: Comma-separated
 *                 list of the columns to be sorted by from source table
 *                 (specified by @a sourceTableName), e.g., 'timestamp asc, x
 *                 desc'. The @a order_by columns do not have to be present in
 *                 @a fieldMap.  The default value is ''.
 *                         <li> gpudb::append_records_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting the
 *                 source table records (specified by @a sourceTableName) into
 *                 the target table (specified by @a tableName) table with a <a
 *                 href="../../concepts/tables.html#primary-keys"
 *                 target="_top">primary key</a>.  If set to @a true, any
 *                 existing target table record with primary key values that
 *                 match those of a source table record being inserted will be
 *                 replaced by that new record.  If set to @a false, any
 *                 existing target table record with primary key values that
 *                 match those of a source table record being inserted will
 *                 remain unchanged and the new record discarded.  If the
 *                 specified table does not have a primary key, then this
 *                 option is ignored.
 *                 <ul>
 *                         <li> gpudb::append_records_true
 *                         <li> gpudb::append_records_false
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                         <li> gpudb::append_records_truncate_strings: If set
 *                 to {true}@{, it allows appending longer strings to smaller
 *                 charN string columns by truncating the longer string to fit.
 *                 The default value is false.
 *                 <ul>
 *                         <li> gpudb::append_records_true
 *                         <li> gpudb::append_records_false
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AppendRecordsResponse GPUdb::appendRecords( const std::string& tableName,
                                            const std::string& sourceTableName,
                                            const std::map<std::string, std::string>& fieldMap,
                                            const std::map<std::string, std::string>& options ) const
{
    AppendRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.sourceTableName = sourceTableName;
    actualRequest_.fieldMap = fieldMap;
    actualRequest_.options = options;
    AppendRecordsResponse actualResponse_;
    submitRequest("/append/records", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Append (or insert) all records from a source table (specified by @a
 * sourceTableName) to a particular target table (specified by @a tableName).
 * The field map (specified by @a fieldMap) holds the user specified map of
 * target table column names with their mapped source column names.
 * 
 * @param tableName  The table name for the records to be appended. Must be an
 *                   existing table.
 * @param sourceTableName  The source table name to get records from. Must be
 *                         an existing table name.
 * @param fieldMap  Contains the mapping of column names from the target table
 *                  (specified by @a tableName) as the keys, and corresponding
 *                  column names or expressions (e.g., 'col_name+1') from the
 *                  source table (specified by @a sourceTableName). Must be
 *                  existing column names in source table and target table, and
 *                  their types must be matched. For details on using
 *                  expressions, see <a href="../../concepts/expressions.html"
 *                  target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::append_records_offset: A positive
 *                 integer indicating the number of initial results to skip
 *                 from @a sourceTableName. Default is 0. The minimum allowed
 *                 value is 0. The maximum allowed value is MAX_INT.  The
 *                 default value is '0'.
 *                         <li> gpudb::append_records_limit: A positive integer
 *                 indicating the maximum number of results to be returned from
 *                 @a sourceTableName. Or END_OF_SET (-9999) to indicate that
 *                 the max number of results should be returned.  The default
 *                 value is '-9999'.
 *                         <li> gpudb::append_records_expression: Optional
 *                 filter expression to apply to the @a sourceTableName.  The
 *                 default value is ''.
 *                         <li> gpudb::append_records_order_by: Comma-separated
 *                 list of the columns to be sorted by from source table
 *                 (specified by @a sourceTableName), e.g., 'timestamp asc, x
 *                 desc'. The @a order_by columns do not have to be present in
 *                 @a fieldMap.  The default value is ''.
 *                         <li> gpudb::append_records_update_on_existing_pk:
 *                 Specifies the record collision policy for inserting the
 *                 source table records (specified by @a sourceTableName) into
 *                 the target table (specified by @a tableName) table with a <a
 *                 href="../../concepts/tables.html#primary-keys"
 *                 target="_top">primary key</a>.  If set to @a true, any
 *                 existing target table record with primary key values that
 *                 match those of a source table record being inserted will be
 *                 replaced by that new record.  If set to @a false, any
 *                 existing target table record with primary key values that
 *                 match those of a source table record being inserted will
 *                 remain unchanged and the new record discarded.  If the
 *                 specified table does not have a primary key, then this
 *                 option is ignored.
 *                 <ul>
 *                         <li> gpudb::append_records_true
 *                         <li> gpudb::append_records_false
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                         <li> gpudb::append_records_truncate_strings: If set
 *                 to {true}@{, it allows appending longer strings to smaller
 *                 charN string columns by truncating the longer string to fit.
 *                 The default value is false.
 *                 <ul>
 *                         <li> gpudb::append_records_true
 *                         <li> gpudb::append_records_false
 *                 </ul>
 *                 The default value is gpudb::append_records_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AppendRecordsResponse& GPUdb::appendRecords( const std::string& tableName,
                                             const std::string& sourceTableName,
                                             const std::map<std::string, std::string>& fieldMap,
                                             const std::map<std::string, std::string>& options,
                                             AppendRecordsResponse& response_ ) const
{
    AppendRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.sourceTableName = sourceTableName;
    actualRequest_.fieldMap = fieldMap;
    actualRequest_.options = options;
    submitRequest("/append/records", actualRequest_, response_, false);
    return response_;
}


/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearStatisticsResponse GPUdb::clearStatistics( const ClearStatisticsRequest& request_ ) const
{
    ClearStatisticsResponse actualResponse_;
    submitRequest("/clear/statistics", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearStatisticsResponse& GPUdb::clearStatistics( const ClearStatisticsRequest& request_,
                                                 ClearStatisticsResponse& response_ ) const
{
    submitRequest("/clear/statistics", request_, response_, false);
    return response_;
}


/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param tableName  Name of a table. Must be an existing table.
 * @param columnName  Name of the column in @a tableName for which to clear
 *                    statistics. The column must be from an existing table. An
 *                    empty string clears statistics for all columns in the
 *                    table.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearStatisticsResponse GPUdb::clearStatistics( const std::string& tableName,
                                                const std::string& columnName,
                                                const std::map<std::string, std::string>& options ) const
{
    ClearStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    ClearStatisticsResponse actualResponse_;
    submitRequest("/clear/statistics", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 * 
 * @param tableName  Name of a table. Must be an existing table.
 * @param columnName  Name of the column in @a tableName for which to clear
 *                    statistics. The column must be from an existing table. An
 *                    empty string clears statistics for all columns in the
 *                    table.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearStatisticsResponse& GPUdb::clearStatistics( const std::string& tableName,
                                                 const std::string& columnName,
                                                 const std::map<std::string, std::string>& options,
                                                 ClearStatisticsResponse& response_ ) const
{
    ClearStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    submitRequest("/clear/statistics", actualRequest_, response_, false);
    return response_;
}


/**
 * Clears (drops) one or all tables in the database cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse GPUdb::clearTable( const ClearTableRequest& request_ ) const
{
    ClearTableResponse actualResponse_;
    submitRequest("/clear/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears (drops) one or all tables in the database cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& GPUdb::clearTable( const ClearTableRequest& request_,
                                       ClearTableResponse& response_ ) const
{
    submitRequest("/clear/table", request_, response_, false);
    return response_;
}


/**
 * Clears (drops) one or all tables in the database cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param tableName  Name of the table to be cleared. Must be an existing
 *                   table. Empty string clears all available tables, though
 *                   this behavior is be prevented by default via gpudb.conf
 *                   parameter 'disable_clear_all'.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::clear_table_no_error_if_not_exists: If
 *                 @a true and if the table specified in @a tableName does not
 *                 exist no error is returned. If @a false and if the table
 *                 specified in @a tableName does not exist then an error is
 *                 returned.
 *                 <ul>
 *                         <li> gpudb::clear_table_true
 *                         <li> gpudb::clear_table_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse GPUdb::clearTable( const std::string& tableName,
                                      const std::string& authorization,
                                      const std::map<std::string, std::string>& options ) const
{
    ClearTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    ClearTableResponse actualResponse_;
    submitRequest("/clear/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears (drops) one or all tables in the database cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param tableName  Name of the table to be cleared. Must be an existing
 *                   table. Empty string clears all available tables, though
 *                   this behavior is be prevented by default via gpudb.conf
 *                   parameter 'disable_clear_all'.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::clear_table_no_error_if_not_exists: If
 *                 @a true and if the table specified in @a tableName does not
 *                 exist no error is returned. If @a false and if the table
 *                 specified in @a tableName does not exist then an error is
 *                 returned.
 *                 <ul>
 *                         <li> gpudb::clear_table_true
 *                         <li> gpudb::clear_table_false
 *                 </ul>
 *                 The default value is gpudb::clear_table_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& GPUdb::clearTable( const std::string& tableName,
                                       const std::string& authorization,
                                       const std::map<std::string, std::string>& options,
                                       ClearTableResponse& response_ ) const
{
    ClearTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    submitRequest("/clear/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse GPUdb::clearTableMonitor( const ClearTableMonitorRequest& request_ ) const
{
    ClearTableMonitorResponse actualResponse_;
    submitRequest("/clear/tablemonitor", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&,CreateTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& GPUdb::clearTableMonitor( const ClearTableMonitorRequest& request_,
                                                     ClearTableMonitorResponse& response_ ) const
{
    submitRequest("/clear/tablemonitor", request_, response_, false);
    return response_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse GPUdb::clearTableMonitor( const std::string& topicId,
                                                    const std::map<std::string, std::string>& options ) const
{
    ClearTableMonitorRequest actualRequest_;
    actualRequest_.topicId = topicId;
    actualRequest_.options = options;
    ClearTableMonitorResponse actualResponse_;
    submitRequest("/clear/tablemonitor", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&,CreateTableMonitorResponse&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& GPUdb::clearTableMonitor( const std::string& topicId,
                                                     const std::map<std::string, std::string>& options,
                                                     ClearTableMonitorResponse& response_ ) const
{
    ClearTableMonitorRequest actualRequest_;
    actualRequest_.topicId = topicId;
    actualRequest_.options = options;
    submitRequest("/clear/tablemonitor", actualRequest_, response_, false);
    return response_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse GPUdb::clearTrigger( const ClearTriggerRequest& request_ ) const
{
    ClearTriggerResponse actualResponse_;
    submitRequest("/clear/trigger", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& GPUdb::clearTrigger( const ClearTriggerRequest& request_,
                                           ClearTriggerResponse& response_ ) const
{
    submitRequest("/clear/trigger", request_, response_, false);
    return response_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse GPUdb::clearTrigger( const std::string& triggerId,
                                          const std::map<std::string, std::string>& options ) const
{
    ClearTriggerRequest actualRequest_;
    actualRequest_.triggerId = triggerId;
    actualRequest_.options = options;
    ClearTriggerResponse actualResponse_;
    submitRequest("/clear/trigger", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& GPUdb::clearTrigger( const std::string& triggerId,
                                           const std::map<std::string, std::string>& options,
                                           ClearTriggerResponse& response_ ) const
{
    ClearTriggerRequest actualRequest_;
    actualRequest_.triggerId = triggerId;
    actualRequest_.options = options;
    submitRequest("/clear/trigger", actualRequest_, response_, false);
    return response_;
}


/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CollectStatisticsResponse GPUdb::collectStatistics( const CollectStatisticsRequest& request_ ) const
{
    CollectStatisticsResponse actualResponse_;
    submitRequest("/collect/statistics", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CollectStatisticsResponse& GPUdb::collectStatistics( const CollectStatisticsRequest& request_,
                                                     CollectStatisticsResponse& response_ ) const
{
    submitRequest("/collect/statistics", request_, response_, false);
    return response_;
}


/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param tableName  Name of a table. Must be an existing table.
 * @param columnNames  List of one or more column names in @a tableName for
 *                     which to collect statistics (cardinality, mean value,
 *                     etc.).
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CollectStatisticsResponse GPUdb::collectStatistics( const std::string& tableName,
                                                    const std::vector<std::string>& columnNames,
                                                    const std::map<std::string, std::string>& options ) const
{
    CollectStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    CollectStatisticsResponse actualResponse_;
    submitRequest("/collect/statistics", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Collect statistics for a column(s) in a specified table.
 * 
 * @param tableName  Name of a table. Must be an existing table.
 * @param columnNames  List of one or more column names in @a tableName for
 *                     which to collect statistics (cardinality, mean value,
 *                     etc.).
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CollectStatisticsResponse& GPUdb::collectStatistics( const std::string& tableName,
                                                     const std::vector<std::string>& columnNames,
                                                     const std::map<std::string, std::string>& options,
                                                     CollectStatisticsResponse& response_ ) const
{
    CollectStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    submitRequest("/collect/statistics", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateGraphResponse GPUdb::createGraph( const CreateGraphRequest& request_ ) const
{
    CreateGraphResponse actualResponse_;
    submitRequest("/create/graph", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateGraphResponse& GPUdb::createGraph( const CreateGraphRequest& request_,
                                         CreateGraphResponse& response_ ) const
{
    submitRequest("/create/graph", request_, response_, false);
    return response_;
}


/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param graphName  Name of the graph resource to generate.
 * @param directedGraph  If set to @a true, the graph will be directed (0 to 1,
 *                       1 to 2, etc.). If set to @a false, the graph will not
 *                       be directed.
 *                       <ul>
 *                               <li> gpudb::create_graph_true
 *                               <li> gpudb::create_graph_false
 *                       </ul>
 *                       The default value is gpudb::create_graph_true.
 * @param nodes  Nodes represent fundamental topological units of a graph.
 *               Nodes must be specified using <a
 *               href="../../graph_solver/network_graph_solver.html#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../graph_solver/network_graph_solver.html#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS NODE_ID',
 *               expressions, e.g., 'ST_MAKEPOINT(column1, column2) AS
 *               NODE_WKTPOINT', or raw values, e.g., '{9, 10, 11} AS NODE_ID'.
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 * @param edges  Edges represent the required fundamental topological unit of a
 *               graph that typically connect nodes. Edges must be specified
 *               using <a
 *               href="../../graph_solver/network_graph_solver.html#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../graph_solver/network_graph_solver.html#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS EDGE_ID',
 *               expressions, e.g., 'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME',
 *               or raw values, e.g., "{'family', 'coworker'} AS EDGE_LABEL".
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 * @param weights  Weights represent a method of informing the graph solver of
 *                 the cost of including a given edge in a solution. Weights
 *                 must be specified using <a
 *                 href="../../graph_solver/network_graph_solver.html#identifiers"
 *                 target="_top">identifiers</a>; identifiers are grouped as <a
 *                 href="../../graph_solver/network_graph_solver.html#id-combos"
 *                 target="_top">combinations</a>. Identifiers can be used with
 *                 existing column names, e.g., 'table.column AS
 *                 WEIGHTS_EDGE_ID', expressions, e.g., 'ST_LENGTH(wkt) AS
 *                 WEIGHTS_VALUESPECIFIED', or raw values, e.g., '{4, 15} AS
 *                 WEIGHTS_VALUESPECIFIED'. If using raw values in an
 *                 identifier combination, the number of values specified must
 *                 match across the combination.
 * @param restrictions  Restrictions represent a method of informing the graph
 *                      solver which edges and/or nodes should be ignored for
 *                      the solution. Restrictions must be specified using <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_graph_restriction_threshold_value: Value-based
 *                 restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 graph.
 *                         <li> gpudb::create_graph_merge_tolerance: If node
 *                 geospatial positions are input (e.g., WKTPOINT, X, Y),
 *                 determines the minimum separation allowed between unique
 *                 nodes. If nodes are within the tolerance of each other, they
 *                 will be merged as a single node.  The default value is
 *                 '1.0E-4'.
 *                         <li> gpudb::create_graph_min_x: Minimum x
 *                 (longitude) value for spatial graph associations.  The
 *                 default value is '-180.0'.
 *                         <li> gpudb::create_graph_max_x: Maximum x
 *                 (longitude) value for spatial graph associations.  The
 *                 default value is '180.0'.
 *                         <li> gpudb::create_graph_min_y: Minimum y (latitude)
 *                 value for spatial graph associations.  The default value is
 *                 '-90.0'.
 *                         <li> gpudb::create_graph_max_y: Maximum y (latitude)
 *                 value for spatial graph associations.  The default value is
 *                 '90.0'.
 *                         <li> gpudb::create_graph_recreate: If set to @a true
 *                 and the graph (using @a graphName) already exists, the graph
 *                 is deleted and recreated.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_export_create_results: If
 *                 set to @a true, returns the graph topology in the response
 *                 as arrays.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_enable_graph_draw: If set
 *                 to @a true, adds a 'EDGE_WKTLINE' column identifier to the
 *                 specified @a graph_table so the graph can be viewed via WMS;
 *                 for social and non-geospatial graphs, the 'EDGE_WKTLINE'
 *                 column identifier will be populated with spatial coordinates
 *                 derived from a flattening layout algorithm so the graph can
 *                 still be viewed.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_save_persist: If set to @a
 *                 true, the graph will be saved in the persist directory (see
 *                 the <a href="../../config/index.html" target="_top">config
 *                 reference</a> for more information). If set to @a false, the
 *                 graph will be removed when the graph server is shutdown.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_sync_db: If set to @a true,
 *                 the graph will be updated if its source table(s) is updated.
 *                 If set to @a false, the graph will not be updated if the
 *                 source table(s) is updated.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_add_table_monitor: Adds a
 *                 table monitor to every table used in the creation of the
 *                 graph. For more details on table monitors, see
 *                 /create/tablemonitor.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_graph_table: If the @a
 *                 graph_table name is NOT left blank, the created graph is
 *                 also created as a table with the given name and following
 *                 identifier columns: 'EDGE_ID', 'EDGE_NODE1_ID',
 *                 'EDGE_NODE2_ID'. If left blank, no table is created.  The
 *                 default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateGraphResponse GPUdb::createGraph( const std::string& graphName,
                                        const bool directedGraph,
                                        const std::vector<std::string>& nodes,
                                        const std::vector<std::string>& edges,
                                        const std::vector<std::string>& weights,
                                        const std::vector<std::string>& restrictions,
                                        const std::map<std::string, std::string>& options ) const
{
    CreateGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.directedGraph = directedGraph;
    actualRequest_.nodes = nodes;
    actualRequest_.edges = edges;
    actualRequest_.weights = weights;
    actualRequest_.restrictions = restrictions;
    actualRequest_.options = options;
    CreateGraphResponse actualResponse_;
    submitRequest("/create/graph", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param graphName  Name of the graph resource to generate.
 * @param directedGraph  If set to @a true, the graph will be directed (0 to 1,
 *                       1 to 2, etc.). If set to @a false, the graph will not
 *                       be directed.
 *                       <ul>
 *                               <li> gpudb::create_graph_true
 *                               <li> gpudb::create_graph_false
 *                       </ul>
 *                       The default value is gpudb::create_graph_true.
 * @param nodes  Nodes represent fundamental topological units of a graph.
 *               Nodes must be specified using <a
 *               href="../../graph_solver/network_graph_solver.html#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../graph_solver/network_graph_solver.html#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS NODE_ID',
 *               expressions, e.g., 'ST_MAKEPOINT(column1, column2) AS
 *               NODE_WKTPOINT', or raw values, e.g., '{9, 10, 11} AS NODE_ID'.
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 * @param edges  Edges represent the required fundamental topological unit of a
 *               graph that typically connect nodes. Edges must be specified
 *               using <a
 *               href="../../graph_solver/network_graph_solver.html#identifiers"
 *               target="_top">identifiers</a>; identifiers are grouped as <a
 *               href="../../graph_solver/network_graph_solver.html#id-combos"
 *               target="_top">combinations</a>. Identifiers can be used with
 *               existing column names, e.g., 'table.column AS EDGE_ID',
 *               expressions, e.g., 'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME',
 *               or raw values, e.g., "{'family', 'coworker'} AS EDGE_LABEL".
 *               If using raw values in an identifier combination, the number
 *               of values specified must match across the combination.
 * @param weights  Weights represent a method of informing the graph solver of
 *                 the cost of including a given edge in a solution. Weights
 *                 must be specified using <a
 *                 href="../../graph_solver/network_graph_solver.html#identifiers"
 *                 target="_top">identifiers</a>; identifiers are grouped as <a
 *                 href="../../graph_solver/network_graph_solver.html#id-combos"
 *                 target="_top">combinations</a>. Identifiers can be used with
 *                 existing column names, e.g., 'table.column AS
 *                 WEIGHTS_EDGE_ID', expressions, e.g., 'ST_LENGTH(wkt) AS
 *                 WEIGHTS_VALUESPECIFIED', or raw values, e.g., '{4, 15} AS
 *                 WEIGHTS_VALUESPECIFIED'. If using raw values in an
 *                 identifier combination, the number of values specified must
 *                 match across the combination.
 * @param restrictions  Restrictions represent a method of informing the graph
 *                      solver which edges and/or nodes should be ignored for
 *                      the solution. Restrictions must be specified using <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_graph_restriction_threshold_value: Value-based
 *                 restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 graph.
 *                         <li> gpudb::create_graph_merge_tolerance: If node
 *                 geospatial positions are input (e.g., WKTPOINT, X, Y),
 *                 determines the minimum separation allowed between unique
 *                 nodes. If nodes are within the tolerance of each other, they
 *                 will be merged as a single node.  The default value is
 *                 '1.0E-4'.
 *                         <li> gpudb::create_graph_min_x: Minimum x
 *                 (longitude) value for spatial graph associations.  The
 *                 default value is '-180.0'.
 *                         <li> gpudb::create_graph_max_x: Maximum x
 *                 (longitude) value for spatial graph associations.  The
 *                 default value is '180.0'.
 *                         <li> gpudb::create_graph_min_y: Minimum y (latitude)
 *                 value for spatial graph associations.  The default value is
 *                 '-90.0'.
 *                         <li> gpudb::create_graph_max_y: Maximum y (latitude)
 *                 value for spatial graph associations.  The default value is
 *                 '90.0'.
 *                         <li> gpudb::create_graph_recreate: If set to @a true
 *                 and the graph (using @a graphName) already exists, the graph
 *                 is deleted and recreated.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_export_create_results: If
 *                 set to @a true, returns the graph topology in the response
 *                 as arrays.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_enable_graph_draw: If set
 *                 to @a true, adds a 'EDGE_WKTLINE' column identifier to the
 *                 specified @a graph_table so the graph can be viewed via WMS;
 *                 for social and non-geospatial graphs, the 'EDGE_WKTLINE'
 *                 column identifier will be populated with spatial coordinates
 *                 derived from a flattening layout algorithm so the graph can
 *                 still be viewed.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_save_persist: If set to @a
 *                 true, the graph will be saved in the persist directory (see
 *                 the <a href="../../config/index.html" target="_top">config
 *                 reference</a> for more information). If set to @a false, the
 *                 graph will be removed when the graph server is shutdown.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_sync_db: If set to @a true,
 *                 the graph will be updated if its source table(s) is updated.
 *                 If set to @a false, the graph will not be updated if the
 *                 source table(s) is updated.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_add_table_monitor: Adds a
 *                 table monitor to every table used in the creation of the
 *                 graph. For more details on table monitors, see
 *                 /create/tablemonitor.
 *                 <ul>
 *                         <li> gpudb::create_graph_true
 *                         <li> gpudb::create_graph_false
 *                 </ul>
 *                 The default value is gpudb::create_graph_false.
 *                         <li> gpudb::create_graph_graph_table: If the @a
 *                 graph_table name is NOT left blank, the created graph is
 *                 also created as a table with the given name and following
 *                 identifier columns: 'EDGE_ID', 'EDGE_NODE1_ID',
 *                 'EDGE_NODE2_ID'. If left blank, no table is created.  The
 *                 default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateGraphResponse& GPUdb::createGraph( const std::string& graphName,
                                         const bool directedGraph,
                                         const std::vector<std::string>& nodes,
                                         const std::vector<std::string>& edges,
                                         const std::vector<std::string>& weights,
                                         const std::vector<std::string>& restrictions,
                                         const std::map<std::string, std::string>& options,
                                         CreateGraphResponse& response_ ) const
{
    CreateGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.directedGraph = directedGraph;
    actualRequest_.nodes = nodes;
    actualRequest_.edges = edges;
    actualRequest_.weights = weights;
    actualRequest_.restrictions = restrictions;
    actualRequest_.options = options;
    submitRequest("/create/graph", actualRequest_, response_, false);
    return response_;
}


/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const GetJobRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJobResponse GPUdb::createJob( const CreateJobRequest& request_ ) const
{
    CreateJobResponse actualResponse_;
    submitRequest("/create/job", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const GetJobRequest&,GetJobResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJobResponse& GPUdb::createJob( const CreateJobRequest& request_,
                                     CreateJobResponse& response_ ) const
{
    submitRequest("/create/job", request_, response_, false);
    return response_;
}


/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const int64_t,const std::map<std::string, std::string>&) const}.
 * 
 * @param endpoint  Indicates which endpoint to execute, e.g. '/alter/table'.
 * @param requestEncoding  The encoding of the request payload for the job.
 *                         <ul>
 *                                 <li> gpudb::create_job_binary
 *                                 <li> gpudb::create_job_json
 *                                 <li> gpudb::create_job_snappy
 *                         </ul>
 *                         The default value is gpudb::create_job_binary.
 * @param data  Binary-encoded payload for the job to be run asynchronously.
 *              The payload must contain the relevant input parameters for the
 *              endpoint indicated in @a endpoint.  Please see the
 *              documentation for the appropriate endpoint to see what values
 *              must (or can) be specified.  If this parameter is used, then @a
 *              requestEncoding must be @a binary or @a snappy.
 * @param dataStr  JSON-encoded payload for the job to be run asynchronously.
 *                 The payload must contain the relevant input parameters for
 *                 the endpoint indicated in @a endpoint.  Please see the
 *                 documentation for the appropriate endpoint to see what
 *                 values must (or can) be specified.  If this parameter is
 *                 used, then @a requestEncoding must be @a json.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJobResponse GPUdb::createJob( const std::string& endpoint,
                                    const std::string& requestEncoding,
                                    const std::vector<uint8_t>& data,
                                    const std::string& dataStr,
                                    const std::map<std::string, std::string>& options ) const
{
    CreateJobRequest actualRequest_;
    actualRequest_.endpoint = endpoint;
    actualRequest_.requestEncoding = requestEncoding;
    actualRequest_.data = data;
    actualRequest_.dataStr = dataStr;
    actualRequest_.options = options;
    CreateJobResponse actualResponse_;
    submitRequest("/create/job", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by {@link
 * #getJob(const int64_t,const std::map<std::string, std::string>&,GetJobResponse&) const}.
 * 
 * @param endpoint  Indicates which endpoint to execute, e.g. '/alter/table'.
 * @param requestEncoding  The encoding of the request payload for the job.
 *                         <ul>
 *                                 <li> gpudb::create_job_binary
 *                                 <li> gpudb::create_job_json
 *                                 <li> gpudb::create_job_snappy
 *                         </ul>
 *                         The default value is gpudb::create_job_binary.
 * @param data  Binary-encoded payload for the job to be run asynchronously.
 *              The payload must contain the relevant input parameters for the
 *              endpoint indicated in @a endpoint.  Please see the
 *              documentation for the appropriate endpoint to see what values
 *              must (or can) be specified.  If this parameter is used, then @a
 *              requestEncoding must be @a binary or @a snappy.
 * @param dataStr  JSON-encoded payload for the job to be run asynchronously.
 *                 The payload must contain the relevant input parameters for
 *                 the endpoint indicated in @a endpoint.  Please see the
 *                 documentation for the appropriate endpoint to see what
 *                 values must (or can) be specified.  If this parameter is
 *                 used, then @a requestEncoding must be @a json.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJobResponse& GPUdb::createJob( const std::string& endpoint,
                                     const std::string& requestEncoding,
                                     const std::vector<uint8_t>& data,
                                     const std::string& dataStr,
                                     const std::map<std::string, std::string>& options,
                                     CreateJobResponse& response_ ) const
{
    CreateJobRequest actualRequest_;
    actualRequest_.endpoint = endpoint;
    actualRequest_.requestEncoding = requestEncoding;
    actualRequest_.data = data;
    actualRequest_.dataStr = dataStr;
    actualRequest_.options = options;
    submitRequest("/create/job", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../concepts/joins.html"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../concepts/joins.html#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse GPUdb::createJoinTable( const CreateJoinTableRequest& request_ ) const
{
    CreateJoinTableResponse actualResponse_;
    submitRequest("/create/jointable", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../concepts/joins.html"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../concepts/joins.html#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& GPUdb::createJoinTable( const CreateJoinTableRequest& request_,
                                                 CreateJoinTableResponse& response_ ) const
{
    submitRequest("/create/jointable", request_, response_, false);
    return response_;
}


/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../concepts/joins.html"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../concepts/joins.html#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param joinTableName  Name of the join table to be created.  Has the same
 *                       naming restrictions as <a
 *                       href="../../concepts/tables.html"
 *                       target="_top">tables</a>.
 * @param tableNames  The list of table names composing the join.  Corresponds
 *                    to a SQL statement FROM clause.
 * @param columnNames  List of member table columns or column expressions to be
 *                     included in the join. Columns can be prefixed with
 *                     'table_id.column_name', where 'table_id' is the table
 *                     name or alias.  Columns can be aliased via the syntax
 *                     'column_name as alias'. Wild cards '*' can be used to
 *                     include all columns across member tables or 'table_id.*'
 *                     for all of a single table's columns.  Columns and column
 *                     expressions composing the join must be uniquely named or
 *                     aliased--therefore, the '*' wild card cannot be used if
 *                     column names aren't unique across all tables.
 * @param expressions  An optional list of expressions to combine and filter
 *                     the joined tables.  Corresponds to a SQL statement WHERE
 *                     clause. For details see: <a
 *                     href="../../concepts/expressions.html"
 *                     target="_top">expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_join_table_collection_name: Name
 *                 of a collection which is to contain the join. If the
 *                 collection provided is non-existent, the collection will be
 *                 automatically created. If empty, then the join will be at
 *                 the top level.  The default value is ''.
 *                         <li> gpudb::create_join_table_max_query_dimensions:
 *                 Obsolete in GPUdb v7.0
 *                         <li> gpudb::create_join_table_optimize_lookups: Use
 *                 more memory to speed up the joining of tables.
 *                 <ul>
 *                         <li> gpudb::create_join_table_true
 *                         <li> gpudb::create_join_table_false
 *                 </ul>
 *                 The default value is gpudb::create_join_table_false.
 *                         <li> gpudb::create_join_table_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 join table specified in @a joinTableName.
 *                         <li> gpudb::create_join_table_view_id: view this
 *                 projection is part of.  The default value is ''.
 *                         <li> gpudb::create_join_table_no_count: return a
 *                 count of 0 for the join table for logging and for
 *                 show_table. optimization needed for large overlapped
 *                 equi-join stencils.  The default value is 'false'.
 *                         <li> gpudb::create_join_table_chunk_size: Maximum
 *                 size of a joined-chunk for this table. Defaults to the
 *                 gpudb.conf file chunk size
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse GPUdb::createJoinTable( const std::string& joinTableName,
                                                const std::vector<std::string>& tableNames,
                                                const std::vector<std::string>& columnNames,
                                                const std::vector<std::string>& expressions,
                                                const std::map<std::string, std::string>& options ) const
{
    CreateJoinTableRequest actualRequest_;
    actualRequest_.joinTableName = joinTableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnNames = columnNames;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    CreateJoinTableResponse actualResponse_;
    submitRequest("/create/jointable", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../concepts/joins.html"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../concepts/joins.html#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 * 
 * @param joinTableName  Name of the join table to be created.  Has the same
 *                       naming restrictions as <a
 *                       href="../../concepts/tables.html"
 *                       target="_top">tables</a>.
 * @param tableNames  The list of table names composing the join.  Corresponds
 *                    to a SQL statement FROM clause.
 * @param columnNames  List of member table columns or column expressions to be
 *                     included in the join. Columns can be prefixed with
 *                     'table_id.column_name', where 'table_id' is the table
 *                     name or alias.  Columns can be aliased via the syntax
 *                     'column_name as alias'. Wild cards '*' can be used to
 *                     include all columns across member tables or 'table_id.*'
 *                     for all of a single table's columns.  Columns and column
 *                     expressions composing the join must be uniquely named or
 *                     aliased--therefore, the '*' wild card cannot be used if
 *                     column names aren't unique across all tables.
 * @param expressions  An optional list of expressions to combine and filter
 *                     the joined tables.  Corresponds to a SQL statement WHERE
 *                     clause. For details see: <a
 *                     href="../../concepts/expressions.html"
 *                     target="_top">expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_join_table_collection_name: Name
 *                 of a collection which is to contain the join. If the
 *                 collection provided is non-existent, the collection will be
 *                 automatically created. If empty, then the join will be at
 *                 the top level.  The default value is ''.
 *                         <li> gpudb::create_join_table_max_query_dimensions:
 *                 Obsolete in GPUdb v7.0
 *                         <li> gpudb::create_join_table_optimize_lookups: Use
 *                 more memory to speed up the joining of tables.
 *                 <ul>
 *                         <li> gpudb::create_join_table_true
 *                         <li> gpudb::create_join_table_false
 *                 </ul>
 *                 The default value is gpudb::create_join_table_false.
 *                         <li> gpudb::create_join_table_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 join table specified in @a joinTableName.
 *                         <li> gpudb::create_join_table_view_id: view this
 *                 projection is part of.  The default value is ''.
 *                         <li> gpudb::create_join_table_no_count: return a
 *                 count of 0 for the join table for logging and for
 *                 show_table. optimization needed for large overlapped
 *                 equi-join stencils.  The default value is 'false'.
 *                         <li> gpudb::create_join_table_chunk_size: Maximum
 *                 size of a joined-chunk for this table. Defaults to the
 *                 gpudb.conf file chunk size
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& GPUdb::createJoinTable( const std::string& joinTableName,
                                                 const std::vector<std::string>& tableNames,
                                                 const std::vector<std::string>& columnNames,
                                                 const std::vector<std::string>& expressions,
                                                 const std::map<std::string, std::string>& options,
                                                 CreateJoinTableResponse& response_ ) const
{
    CreateJoinTableRequest actualRequest_;
    actualRequest_.joinTableName = joinTableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnNames = columnNames;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    submitRequest("/create/jointable", actualRequest_, response_, false);
    return response_;
}


/**
 * Initiates the process of creating a materialized view, reserving the view's
 * name to prevent other views or tables from being created with that name.
 * <p>
 * For materialized view details and examples, see <a
 * href="../../concepts/materialized_views.html" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose the view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateMaterializedViewResponse GPUdb::createMaterializedView( const CreateMaterializedViewRequest& request_ ) const
{
    CreateMaterializedViewResponse actualResponse_;
    submitRequest("/create/materializedview", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Initiates the process of creating a materialized view, reserving the view's
 * name to prevent other views or tables from being created with that name.
 * <p>
 * For materialized view details and examples, see <a
 * href="../../concepts/materialized_views.html" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose the view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateMaterializedViewResponse& GPUdb::createMaterializedView( const CreateMaterializedViewRequest& request_,
                                                               CreateMaterializedViewResponse& response_ ) const
{
    submitRequest("/create/materializedview", request_, response_, false);
    return response_;
}


/**
 * Initiates the process of creating a materialized view, reserving the view's
 * name to prevent other views or tables from being created with that name.
 * <p>
 * For materialized view details and examples, see <a
 * href="../../concepts/materialized_views.html" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose the view.
 * 
 * @param tableName  Name of the table to be created that is the top-level
 *                   table of the materialized view.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_materialized_view_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 table will be a top-level table.
 *                         <li> gpudb::create_materialized_view_ttl: Sets the
 *                 <a href="../../concepts/ttl.html" target="_top">TTL</a> of
 *                 the table specified in @a tableName.
 *                         <li> gpudb::create_materialized_view_persist: If @a
 *                 true, then the materialized view specified in @a tableName
 *                 will be persisted and will not expire unless a @a ttl is
 *                 specified.   If @a false, then the materialized view will be
 *                 an in-memory table and will expire unless a @a ttl is
 *                 specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_true
 *                         <li> gpudb::create_materialized_view_false
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_false.
 *                         <li> gpudb::create_materialized_view_refresh_method:
 *                 Method by which the join can be refreshed when the data in
 *                 underlying member tables have changed.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_manual: Refresh
 *                 only occurs when manually requested by calling /alter/table
 *                 with an 'action' of 'refresh'
 *                         <li> gpudb::create_materialized_view_on_query: For
 *                 future use.
 *                         <li> gpudb::create_materialized_view_on_change: If
 *                 possible, incrementally refresh (refresh just those records
 *                 added) whenever an insert, update, delete or refresh of
 *                 input table is done.  A full refresh is done if an
 *                 incremental refresh is not possible.
 *                         <li> gpudb::create_materialized_view_periodic:
 *                 Refresh table periodically at rate specified by @a
 *                 refresh_period
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_manual.
 *                         <li> gpudb::create_materialized_view_refresh_period:
 *                 When @a refresh_method is @a periodic, specifies the period
 *                 in seconds at which refresh occurs
 *                         <li>
 *                 gpudb::create_materialized_view_refresh_start_time: When @a
 *                 refresh_method is @a periodic, specifies the first time at
 *                 which a refresh is to be done.  Value is a datetime string
 *                 with format 'YYYY-MM-DD HH:MM:SS'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateMaterializedViewResponse GPUdb::createMaterializedView( const std::string& tableName,
                                                              const std::map<std::string, std::string>& options ) const
{
    CreateMaterializedViewRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    CreateMaterializedViewResponse actualResponse_;
    submitRequest("/create/materializedview", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Initiates the process of creating a materialized view, reserving the view's
 * name to prevent other views or tables from being created with that name.
 * <p>
 * For materialized view details and examples, see <a
 * href="../../concepts/materialized_views.html" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains @a viewId, which is used to tag each subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose the view.
 * 
 * @param tableName  Name of the table to be created that is the top-level
 *                   table of the materialized view.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_materialized_view_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 table will be a top-level table.
 *                         <li> gpudb::create_materialized_view_ttl: Sets the
 *                 <a href="../../concepts/ttl.html" target="_top">TTL</a> of
 *                 the table specified in @a tableName.
 *                         <li> gpudb::create_materialized_view_persist: If @a
 *                 true, then the materialized view specified in @a tableName
 *                 will be persisted and will not expire unless a @a ttl is
 *                 specified.   If @a false, then the materialized view will be
 *                 an in-memory table and will expire unless a @a ttl is
 *                 specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_true
 *                         <li> gpudb::create_materialized_view_false
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_false.
 *                         <li> gpudb::create_materialized_view_refresh_method:
 *                 Method by which the join can be refreshed when the data in
 *                 underlying member tables have changed.
 *                 <ul>
 *                         <li> gpudb::create_materialized_view_manual: Refresh
 *                 only occurs when manually requested by calling /alter/table
 *                 with an 'action' of 'refresh'
 *                         <li> gpudb::create_materialized_view_on_query: For
 *                 future use.
 *                         <li> gpudb::create_materialized_view_on_change: If
 *                 possible, incrementally refresh (refresh just those records
 *                 added) whenever an insert, update, delete or refresh of
 *                 input table is done.  A full refresh is done if an
 *                 incremental refresh is not possible.
 *                         <li> gpudb::create_materialized_view_periodic:
 *                 Refresh table periodically at rate specified by @a
 *                 refresh_period
 *                 </ul>
 *                 The default value is gpudb::create_materialized_view_manual.
 *                         <li> gpudb::create_materialized_view_refresh_period:
 *                 When @a refresh_method is @a periodic, specifies the period
 *                 in seconds at which refresh occurs
 *                         <li>
 *                 gpudb::create_materialized_view_refresh_start_time: When @a
 *                 refresh_method is @a periodic, specifies the first time at
 *                 which a refresh is to be done.  Value is a datetime string
 *                 with format 'YYYY-MM-DD HH:MM:SS'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateMaterializedViewResponse& GPUdb::createMaterializedView( const std::string& tableName,
                                                               const std::map<std::string, std::string>& options,
                                                               CreateMaterializedViewResponse& response_ ) const
{
    CreateMaterializedViewRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/create/materializedview", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates an instance (proc) of the user-defined function (UDF) specified by
 * the given command, options, and files, and makes it available for execution.
 * For details on UDFs, see: <a href="../../concepts/udf.html"
 * target="_top">User-Defined Functions</a>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProcResponse GPUdb::createProc( const CreateProcRequest& request_ ) const
{
    CreateProcResponse actualResponse_;
    submitRequest("/create/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates an instance (proc) of the user-defined function (UDF) specified by
 * the given command, options, and files, and makes it available for execution.
 * For details on UDFs, see: <a href="../../concepts/udf.html"
 * target="_top">User-Defined Functions</a>
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProcResponse& GPUdb::createProc( const CreateProcRequest& request_,
                                       CreateProcResponse& response_ ) const
{
    submitRequest("/create/proc", request_, response_, false);
    return response_;
}


/**
 * Creates an instance (proc) of the user-defined function (UDF) specified by
 * the given command, options, and files, and makes it available for execution.
 * For details on UDFs, see: <a href="../../concepts/udf.html"
 * target="_top">User-Defined Functions</a>
 * 
 * @param procName  Name of the proc to be created. Must not be the name of a
 *                  currently existing proc.
 * @param executionMode  The execution mode of the proc.
 *                       <ul>
 *                               <li> gpudb::create_proc_distributed: Input
 *                       table data will be divided into data segments that are
 *                       distributed across all nodes in the cluster, and the
 *                       proc command will be invoked once per data segment in
 *                       parallel. Output table data from each invocation will
 *                       be saved to the same node as the corresponding input
 *                       data.
 *                               <li> gpudb::create_proc_nondistributed: The
 *                       proc command will be invoked only once per execution,
 *                       and will not have access to any input or output table
 *                       data.
 *                       </ul>
 *                       The default value is gpudb::create_proc_distributed.
 * @param files  A map of the files that make up the proc. The keys of the map
 *               are file names, and the values are the binary contents of the
 *               files. The file names may include subdirectory names (e.g.
 *               'subdir/file') but must not resolve to a directory above the
 *               root for the proc.
 * @param command  The command (excluding arguments) that will be invoked when
 *                 the proc is executed. It will be invoked from the directory
 *                 containing the proc @a files and may be any command that can
 *                 be resolved from that directory. It need not refer to a file
 *                 actually in that directory; for example, it could be 'java'
 *                 if the proc is a Java application; however, any necessary
 *                 external programs must be preinstalled on every database
 *                 node. If the command refers to a file in that directory, it
 *                 must be preceded with './' as per Linux convention. If not
 *                 specified, and exactly one file is provided in @a files,
 *                 that file will be invoked.
 * @param args  An array of command-line arguments that will be passed to @a
 *              command when the proc is executed.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_proc_max_concurrency_per_node:
 *                 The maximum number of concurrent instances of the proc that
 *                 will be executed per node. 0 allows unlimited concurrency.
 *                 The default value is '0'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProcResponse GPUdb::createProc( const std::string& procName,
                                      const std::string& executionMode,
                                      const std::map<std::string, std::vector<uint8_t> >& files,
                                      const std::string& command,
                                      const std::vector<std::string>& args,
                                      const std::map<std::string, std::string>& options ) const
{
    CreateProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.executionMode = executionMode;
    actualRequest_.files = files;
    actualRequest_.command = command;
    actualRequest_.args = args;
    actualRequest_.options = options;
    CreateProcResponse actualResponse_;
    submitRequest("/create/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates an instance (proc) of the user-defined function (UDF) specified by
 * the given command, options, and files, and makes it available for execution.
 * For details on UDFs, see: <a href="../../concepts/udf.html"
 * target="_top">User-Defined Functions</a>
 * 
 * @param procName  Name of the proc to be created. Must not be the name of a
 *                  currently existing proc.
 * @param executionMode  The execution mode of the proc.
 *                       <ul>
 *                               <li> gpudb::create_proc_distributed: Input
 *                       table data will be divided into data segments that are
 *                       distributed across all nodes in the cluster, and the
 *                       proc command will be invoked once per data segment in
 *                       parallel. Output table data from each invocation will
 *                       be saved to the same node as the corresponding input
 *                       data.
 *                               <li> gpudb::create_proc_nondistributed: The
 *                       proc command will be invoked only once per execution,
 *                       and will not have access to any input or output table
 *                       data.
 *                       </ul>
 *                       The default value is gpudb::create_proc_distributed.
 * @param files  A map of the files that make up the proc. The keys of the map
 *               are file names, and the values are the binary contents of the
 *               files. The file names may include subdirectory names (e.g.
 *               'subdir/file') but must not resolve to a directory above the
 *               root for the proc.
 * @param command  The command (excluding arguments) that will be invoked when
 *                 the proc is executed. It will be invoked from the directory
 *                 containing the proc @a files and may be any command that can
 *                 be resolved from that directory. It need not refer to a file
 *                 actually in that directory; for example, it could be 'java'
 *                 if the proc is a Java application; however, any necessary
 *                 external programs must be preinstalled on every database
 *                 node. If the command refers to a file in that directory, it
 *                 must be preceded with './' as per Linux convention. If not
 *                 specified, and exactly one file is provided in @a files,
 *                 that file will be invoked.
 * @param args  An array of command-line arguments that will be passed to @a
 *              command when the proc is executed.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_proc_max_concurrency_per_node:
 *                 The maximum number of concurrent instances of the proc that
 *                 will be executed per node. 0 allows unlimited concurrency.
 *                 The default value is '0'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProcResponse& GPUdb::createProc( const std::string& procName,
                                       const std::string& executionMode,
                                       const std::map<std::string, std::vector<uint8_t> >& files,
                                       const std::string& command,
                                       const std::vector<std::string>& args,
                                       const std::map<std::string, std::string>& options,
                                       CreateProcResponse& response_ ) const
{
    CreateProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.executionMode = executionMode;
    actualRequest_.files = files;
    actualRequest_.command = command;
    actualRequest_.args = args;
    actualRequest_.options = options;
    submitRequest("/create/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new <a href="../../concepts/projections.html"
 * target="_top">projection</a> of an existing table. A projection represents a
 * subset of the columns (potentially including derived columns) of a table.
 * <p>
 * For projection details and examples, see <a
 * href="../../concepts/projections.html" target="_top">Projections</a>.  For
 * limitations, see <a
 * href="../../concepts/projections.html#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #getRecordsByColumnRaw(const GetRecordsByColumnRequest&) const}.
 * <p>
 * A projection can be created with a different <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a>
 * than the source table.  By specifying @a shard_key, the projection will be
 * sharded according to the specified columns, regardless of how the source
 * table is sharded.  The source table can even be unsharded or replicated.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProjectionResponse GPUdb::createProjection( const CreateProjectionRequest& request_ ) const
{
    CreateProjectionResponse actualResponse_;
    submitRequest("/create/projection", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new <a href="../../concepts/projections.html"
 * target="_top">projection</a> of an existing table. A projection represents a
 * subset of the columns (potentially including derived columns) of a table.
 * <p>
 * For projection details and examples, see <a
 * href="../../concepts/projections.html" target="_top">Projections</a>.  For
 * limitations, see <a
 * href="../../concepts/projections.html#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #getRecordsByColumnRaw(const GetRecordsByColumnRequest&,RawGetRecordsByColumnResponse&) const}.
 * <p>
 * A projection can be created with a different <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a>
 * than the source table.  By specifying @a shard_key, the projection will be
 * sharded according to the specified columns, regardless of how the source
 * table is sharded.  The source table can even be unsharded or replicated.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProjectionResponse& GPUdb::createProjection( const CreateProjectionRequest& request_,
                                                   CreateProjectionResponse& response_ ) const
{
    submitRequest("/create/projection", request_, response_, false);
    return response_;
}


/**
 * Creates a new <a href="../../concepts/projections.html"
 * target="_top">projection</a> of an existing table. A projection represents a
 * subset of the columns (potentially including derived columns) of a table.
 * <p>
 * For projection details and examples, see <a
 * href="../../concepts/projections.html" target="_top">Projections</a>.  For
 * limitations, see <a
 * href="../../concepts/projections.html#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #getRecordsByColumnRaw(const GetRecordsByColumnRequest&) const}.
 * <p>
 * A projection can be created with a different <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a>
 * than the source table.  By specifying @a shard_key, the projection will be
 * sharded according to the specified columns, regardless of how the source
 * table is sharded.  The source table can even be unsharded or replicated.
 * 
 * @param tableName  Name of the existing table on which the projection is to
 *                   be applied.
 * @param projectionName  Name of the projection to be created. Has the same
 *                        naming restrictions as <a
 *                        href="../../concepts/tables.html"
 *                        target="_top">tables</a>.
 * @param columnNames  List of columns from @a tableName to be included in the
 *                     projection. Can include derived columns. Can be
 *                     specified as aliased via the syntax 'column_name as
 *                     alias'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_projection_collection_name: Name
 *                 of a <a href="../../concepts/collections.html"
 *                 target="_top">collection</a> to which the projection is to
 *                 be assigned as a child. If the collection provided is
 *                 non-existent, the collection will be automatically created.
 *                 If empty, then the projection will be at the top level.  The
 *                 default value is ''.
 *                         <li> gpudb::create_projection_expression: An
 *                 optional filter <a href="../../concepts/expressions.html"
 *                 target="_top">expression</a> to be applied to the source
 *                 table prior to the projection.  The default value is ''.
 *                         <li> gpudb::create_projection_is_replicated: If @a
 *                 true then the projection will be replicated even if the
 *                 source table is not.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_limit: The number of
 *                 records to keep.  The default value is ''.
 *                         <li> gpudb::create_projection_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in @a columnNames.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::create_projection_materialize_on_gpu: If
 *                 @a true then the columns of the projection will be cached on
 *                 the GPU.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_chunk_size: Indicates
 *                 the chunk size to be used for this table.
 *                         <li> gpudb::create_projection_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the output table.  The columns specified must be present
 *                 in @a columnNames.  If any alias is given for any column
 *                 name, the alias must be used, rather than the original
 *                 column name.
 *                         <li> gpudb::create_projection_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 projection specified in @a projectionName.
 *                         <li> gpudb::create_projection_shard_key:
 *                 Comma-separated list of the columns to be sharded on; e.g.
 *                 'column1, column2'.  The columns specified must be present
 *                 in @a columnNames.  If any alias is given for any column
 *                 name, the alias must be used, rather than the original
 *                 column name.  The default value is ''.
 *                         <li> gpudb::create_projection_persist: If @a true,
 *                 then the projection specified in @a projectionName will be
 *                 persisted and will not expire unless a @a ttl is specified.
 *                 If @a false, then the projection will be an in-memory table
 *                 and will expire unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li>
 *                 gpudb::create_projection_preserve_dict_encoding: If @a true,
 *                 then columns that were dict encoded in the source table will
 *                 be dict encoded in the projection table.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_true.
 *                         <li> gpudb::create_projection_view_id: view this
 *                 projection is part of.  The default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProjectionResponse GPUdb::createProjection( const std::string& tableName,
                                                  const std::string& projectionName,
                                                  const std::vector<std::string>& columnNames,
                                                  const std::map<std::string, std::string>& options ) const
{
    CreateProjectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.projectionName = projectionName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    CreateProjectionResponse actualResponse_;
    submitRequest("/create/projection", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new <a href="../../concepts/projections.html"
 * target="_top">projection</a> of an existing table. A projection represents a
 * subset of the columns (potentially including derived columns) of a table.
 * <p>
 * For projection details and examples, see <a
 * href="../../concepts/projections.html" target="_top">Projections</a>.  For
 * limitations, see <a
 * href="../../concepts/projections.html#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #getRecordsByColumnRaw(const GetRecordsByColumnRequest&) const}.
 * <p>
 * A projection can be created with a different <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a>
 * than the source table.  By specifying @a shard_key, the projection will be
 * sharded according to the specified columns, regardless of how the source
 * table is sharded.  The source table can even be unsharded or replicated.
 * 
 * @param tableName  Name of the existing table on which the projection is to
 *                   be applied.
 * @param projectionName  Name of the projection to be created. Has the same
 *                        naming restrictions as <a
 *                        href="../../concepts/tables.html"
 *                        target="_top">tables</a>.
 * @param columnNames  List of columns from @a tableName to be included in the
 *                     projection. Can include derived columns. Can be
 *                     specified as aliased via the syntax 'column_name as
 *                     alias'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_projection_collection_name: Name
 *                 of a <a href="../../concepts/collections.html"
 *                 target="_top">collection</a> to which the projection is to
 *                 be assigned as a child. If the collection provided is
 *                 non-existent, the collection will be automatically created.
 *                 If empty, then the projection will be at the top level.  The
 *                 default value is ''.
 *                         <li> gpudb::create_projection_expression: An
 *                 optional filter <a href="../../concepts/expressions.html"
 *                 target="_top">expression</a> to be applied to the source
 *                 table prior to the projection.  The default value is ''.
 *                         <li> gpudb::create_projection_is_replicated: If @a
 *                 true then the projection will be replicated even if the
 *                 source table is not.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_limit: The number of
 *                 records to keep.  The default value is ''.
 *                         <li> gpudb::create_projection_order_by:
 *                 Comma-separated list of the columns to be sorted by; e.g.
 *                 'timestamp asc, x desc'.  The columns specified must be
 *                 present in @a columnNames.  If any alias is given for any
 *                 column name, the alias must be used, rather than the
 *                 original column name.  The default value is ''.
 *                         <li> gpudb::create_projection_materialize_on_gpu: If
 *                 @a true then the columns of the projection will be cached on
 *                 the GPU.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li> gpudb::create_projection_chunk_size: Indicates
 *                 the chunk size to be used for this table.
 *                         <li> gpudb::create_projection_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the output table.  The columns specified must be present
 *                 in @a columnNames.  If any alias is given for any column
 *                 name, the alias must be used, rather than the original
 *                 column name.
 *                         <li> gpudb::create_projection_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 projection specified in @a projectionName.
 *                         <li> gpudb::create_projection_shard_key:
 *                 Comma-separated list of the columns to be sharded on; e.g.
 *                 'column1, column2'.  The columns specified must be present
 *                 in @a columnNames.  If any alias is given for any column
 *                 name, the alias must be used, rather than the original
 *                 column name.  The default value is ''.
 *                         <li> gpudb::create_projection_persist: If @a true,
 *                 then the projection specified in @a projectionName will be
 *                 persisted and will not expire unless a @a ttl is specified.
 *                 If @a false, then the projection will be an in-memory table
 *                 and will expire unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_false.
 *                         <li>
 *                 gpudb::create_projection_preserve_dict_encoding: If @a true,
 *                 then columns that were dict encoded in the source table will
 *                 be dict encoded in the projection table.
 *                 <ul>
 *                         <li> gpudb::create_projection_true
 *                         <li> gpudb::create_projection_false
 *                 </ul>
 *                 The default value is gpudb::create_projection_true.
 *                         <li> gpudb::create_projection_view_id: view this
 *                 projection is part of.  The default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProjectionResponse& GPUdb::createProjection( const std::string& tableName,
                                                   const std::string& projectionName,
                                                   const std::vector<std::string>& columnNames,
                                                   const std::map<std::string, std::string>& options,
                                                   CreateProjectionResponse& response_ ) const
{
    CreateProjectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.projectionName = projectionName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    submitRequest("/create/projection", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateResourceGroupResponse GPUdb::createResourceGroup( const CreateResourceGroupRequest& request_ ) const
{
    CreateResourceGroupResponse actualResponse_;
    submitRequest("/create/resourcegroup", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateResourceGroupResponse& GPUdb::createResourceGroup( const CreateResourceGroupRequest& request_,
                                                         CreateResourceGroupResponse& response_ ) const
{
    submitRequest("/create/resourcegroup", request_, response_, false);
    return response_;
}


/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param name  Name of the group to be created. Must contain only letters,
 *              digits, and underscores, and cannot begin with a digit. Must
 *              not match existing resource group name.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::create_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  Indicates the relative ranking among existing resource
 *                 groups where this new resource group will be placed.  When
 *                 using @a before or @a after, specify which resource group
 *                 this one will be inserted before or after in @a
 *                 adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::create_resource_group_first
 *                         <li> gpudb::create_resource_group_last
 *                         <li> gpudb::create_resource_group_before
 *                         <li> gpudb::create_resource_group_after
 *                 </ul>
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li>
 *                 gpudb::create_resource_group_max_scheduling_priority:
 *                 Maximum priority of a scheduled task for this group.
 *                         <li> gpudb::create_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateResourceGroupResponse GPUdb::createResourceGroup( const std::string& name,
                                                        const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                                        const std::string& ranking,
                                                        const std::string& adjoiningResourceGroup,
                                                        const std::map<std::string, std::string>& options ) const
{
    CreateResourceGroupRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.tierAttributes = tierAttributes;
    actualRequest_.ranking = ranking;
    actualRequest_.adjoiningResourceGroup = adjoiningResourceGroup;
    actualRequest_.options = options;
    CreateResourceGroupResponse actualResponse_;
    submitRequest("/create/resourcegroup", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new resource group to facilitate resource management.
 * 
 * @param name  Name of the group to be created. Must contain only letters,
 *              digits, and underscores, and cannot begin with a digit. Must
 *              not match existing resource group name.
 * @param tierAttributes  Optional map containing tier names and their
 *                        respective attribute group limits.  The only valid
 *                        attribute limit that can be set is max_memory (in
 *                        bytes) for the VRAM & RAM tiers.
 *                        For instance, to set max VRAM capacity to 1GB and max
 *                        RAM capacity to 10GB, use:
 *                        {'VRAM':{'max_memory':'1000000000'},
 *                        'RAM':{'max_memory':'10000000000'}}
 *                        <ul>
 *                                <li> gpudb::create_resource_group_max_memory:
 *                        Maximum amount of memory usable in the given tier at
 *                        one time for this group.
 *                        </ul>
 * @param ranking  Indicates the relative ranking among existing resource
 *                 groups where this new resource group will be placed.  When
 *                 using @a before or @a after, specify which resource group
 *                 this one will be inserted before or after in @a
 *                 adjoiningResourceGroup.
 *                 <ul>
 *                         <li> gpudb::create_resource_group_first
 *                         <li> gpudb::create_resource_group_last
 *                         <li> gpudb::create_resource_group_before
 *                         <li> gpudb::create_resource_group_after
 *                 </ul>
 * @param adjoiningResourceGroup  If @a ranking is @a before or @a after, this
 *                                field indicates the resource group before or
 *                                after which the current group will be placed;
 *                                otherwise, leave blank.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::create_resource_group_max_cpu_concurrency: Maximum
 *                 number of simultaneous threads that will be used to execute
 *                 a request for this group.
 *                         <li>
 *                 gpudb::create_resource_group_max_scheduling_priority:
 *                 Maximum priority of a scheduled task for this group.
 *                         <li> gpudb::create_resource_group_max_tier_priority:
 *                 Maximum priority of a tiered object for this group.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateResourceGroupResponse& GPUdb::createResourceGroup( const std::string& name,
                                                         const std::map<std::string, std::map<std::string, std::string> >& tierAttributes,
                                                         const std::string& ranking,
                                                         const std::string& adjoiningResourceGroup,
                                                         const std::map<std::string, std::string>& options,
                                                         CreateResourceGroupResponse& response_ ) const
{
    CreateResourceGroupRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.tierAttributes = tierAttributes;
    actualRequest_.ranking = ranking;
    actualRequest_.adjoiningResourceGroup = adjoiningResourceGroup;
    actualRequest_.options = options;
    submitRequest("/create/resourcegroup", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateRoleResponse GPUdb::createRole( const CreateRoleRequest& request_ ) const
{
    CreateRoleResponse actualResponse_;
    submitRequest("/create/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateRoleResponse& GPUdb::createRole( const CreateRoleRequest& request_,
                                       CreateRoleResponse& response_ ) const
{
    submitRequest("/create/role", request_, response_, false);
    return response_;
}


/**
 * Creates a new role.
 * 
 * @param name  Name of the role to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_role_resource_group: Name of an
 *                 existing resource group to associate with this user
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateRoleResponse GPUdb::createRole( const std::string& name,
                                      const std::map<std::string, std::string>& options ) const
{
    CreateRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    CreateRoleResponse actualResponse_;
    submitRequest("/create/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new role.
 * 
 * @param name  Name of the role to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_role_resource_group: Name of an
 *                 existing resource group to associate with this user
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateRoleResponse& GPUdb::createRole( const std::string& name,
                                       const std::map<std::string, std::string>& options,
                                       CreateRoleResponse& response_ ) const
{
    CreateRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/create/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new table or collection. If a new table is being created,
 * the type of the table is given by @a typeId, which must the be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&) const}). The
 * table will be created inside a collection if the option
 * @a collection_name is specified. If that collection does
 * not already exist, it will be created.
 * <p>
 * To create a new collection, specify the name of the collection in
 * @a tableName and set the @a is_collection option to
 * @a true; @a typeId will be
 * ignored.
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../concepts/tables.html#replication"
 * target="_top">replicated</a> distribution scheme,
 * have <a href="../../concepts/tables.html#foreign-keys" target="_top">foreign
 * keys</a> to other
 * tables assigned, be assigned a
 * <a href="../../concepts/tables.html#partitioning"
 * target="_top">partitioning</a> scheme, or have a
 * <a href="../../rm/concepts.html#tier-strategies" target="_top">tier
 * strategy</a> assigned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse GPUdb::createTable( const CreateTableRequest& request_ ) const
{
    CreateTableResponse actualResponse_;
    submitRequest("/create/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new table or collection. If a new table is being created,
 * the type of the table is given by @a typeId, which must the be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&,CreateTypeResponse&) const}). The
 * table will be created inside a collection if the option
 * @a collection_name is specified. If that collection does
 * not already exist, it will be created.
 * <p>
 * To create a new collection, specify the name of the collection in
 * @a tableName and set the @a is_collection option to
 * @a true; @a typeId will be
 * ignored.
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../concepts/tables.html#replication"
 * target="_top">replicated</a> distribution scheme,
 * have <a href="../../concepts/tables.html#foreign-keys" target="_top">foreign
 * keys</a> to other
 * tables assigned, be assigned a
 * <a href="../../concepts/tables.html#partitioning"
 * target="_top">partitioning</a> scheme, or have a
 * <a href="../../rm/concepts.html#tier-strategies" target="_top">tier
 * strategy</a> assigned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& GPUdb::createTable( const CreateTableRequest& request_,
                                         CreateTableResponse& response_ ) const
{
    submitRequest("/create/table", request_, response_, false);
    return response_;
}


/**
 * Creates a new table or collection. If a new table is being created,
 * the type of the table is given by @a typeId, which must the be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const}).
 * The
 * table will be created inside a collection if the option
 * @a collection_name is specified. If that collection does
 * not already exist, it will be created.
 * <p>
 * To create a new collection, specify the name of the collection in
 * @a tableName and set the @a is_collection option to
 * @a true; @a typeId will be
 * ignored.
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../concepts/tables.html#replication"
 * target="_top">replicated</a> distribution scheme,
 * have <a href="../../concepts/tables.html#foreign-keys" target="_top">foreign
 * keys</a> to other
 * tables assigned, be assigned a
 * <a href="../../concepts/tables.html#partitioning"
 * target="_top">partitioning</a> scheme, or have a
 * <a href="../../rm/concepts.html#tier-strategies" target="_top">tier
 * strategy</a> assigned.
 * 
 * @param tableName  Name of the table to be created. Error for requests with
 *                   existing table of the same name and type id may be
 *                   suppressed by using the @a no_error_if_exists option.  See
 *                   <a href="../../concepts/tables.html"
 *                   target="_top">Tables</a> for naming restrictions.
 * @param typeId  ID of a currently registered type. All objects added to the
 *                newly created table will be of this type.  Ignored if @a
 *                is_collection is @a true.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_no_error_if_exists: If @a
 *                 true, prevents an error from occurring if the table already
 *                 exists and is of the given type.  If a table with the same
 *                 ID but a different type exists, it is still an error.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_collection_name: Name of a
 *                 collection which is to contain the newly created table. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 table will be a top-level table.
 *                         <li> gpudb::create_table_is_collection: Indicates
 *                 whether the new table to be created will be a collection.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li>
 *                 gpudb::create_table_disallow_homogeneous_tables: No longer
 *                 supported; value will be ignored.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_is_replicated: For a table,
 *                 affects the <a
 *                 href="../../concepts/tables.html#distribution"
 *                 target="_top">distribution scheme</a> for the table's data.
 *                 If true and the given type has no explicit <a
 *                 href="../../concepts/tables.html#shard-key"
 *                 target="_top">shard key</a> defined, the table will be <a
 *                 href="../../concepts/tables.html#replication"
 *                 target="_top">replicated</a>.  If false, the table will be
 *                 <a href="../../concepts/tables.html#sharding"
 *                 target="_top">sharded</a> according to the shard key
 *                 specified in the given @a typeId, or <a
 *                 href="../../concepts/tables.html#random-sharding"
 *                 target="_top">randomly sharded</a>, if no shard key is
 *                 specified.  Note that a type containing a shard key cannot
 *                 be used to create a replicated table.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_foreign_keys:
 *                 Semicolon-separated list of <a
 *                 href="../../concepts/tables.html#foreign-keys"
 *                 target="_top">foreign keys</a>, of the format
 *                 '(source_column_name [, ...]) references
 *                 target_table_name(primary_key_column_name [, ...]) [as
 *                 foreign_key_name]'.
 *                         <li> gpudb::create_table_foreign_shard_key: Foreign
 *                 shard key of the format 'source_column references
 *                 shard_by_column from target_table(primary_key_column)'.
 *                         <li> gpudb::create_table_partition_type: <a
 *                 href="../../concepts/tables.html#partitioning"
 *                 target="_top">Partitioning</a> scheme to use.
 *                 <ul>
 *                         <li> gpudb::create_table_RANGE: Use <a
 *                 href="../../concepts/tables.html#partitioning-by-range"
 *                 target="_top">range partitioning</a>.
 *                         <li> gpudb::create_table_INTERVAL: Use <a
 *                 href="../../concepts/tables.html#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>.
 *                         <li> gpudb::create_table_LIST: Use <a
 *                 href="../../concepts/tables.html#partitioning-by-list"
 *                 target="_top">list partitioning</a>.
 *                 </ul>
 *                         <li> gpudb::create_table_partition_keys:
 *                 Comma-separated list of partition keys, which are the
 *                 columns or column expressions by which records will be
 *                 assigned to partitions defined by @a partition_definitions.
 *                         <li> gpudb::create_table_partition_definitions:
 *                 Comma-separated list of partition definitions, whose format
 *                 depends on the choice of @a partition_type.  See <a
 *                 href="../../concepts/tables.html#partitioning-by-range"
 *                 target="_top">range partitioning</a>, <a
 *                 href="../../concepts/tables.html#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>, or <a
 *                 href="../../concepts/tables.html#partitioning-by-list"
 *                 target="_top">list partitioning</a> for example formats.
 *                         <li> gpudb::create_table_is_automatic_partition: If
 *                 true, a new partition will be created for values which don't
 *                 fall into an existing partition.  Currently only supported
 *                 for <a
 *                 href="../../concepts/tables.html#partitioning-by-list"
 *                 target="_top">list partitions</a>.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_ttl: For a table, sets the
 *                 <a href="../../concepts/ttl.html" target="_top">TTL</a> of
 *                 the table specified in @a tableName.
 *                         <li> gpudb::create_table_chunk_size: Indicates the
 *                 chunk size to be used for this table.
 *                         <li> gpudb::create_table_is_result_table: For a
 *                 table, indicates whether the table is an in-memory table. A
 *                 result table cannot contain store_only, text_search, or
 *                 string columns (charN columns are acceptable), and it will
 *                 not be retained if the server is restarted.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_strategy_definition: The <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns. See <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy usage</a> for format and <a
 *                 href="../../rm/usage.html#tier-strategies"
 *                 target="_top">tier strategy examples</a> for examples.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse GPUdb::createTable( const std::string& tableName,
                                        const std::string& typeId,
                                        const std::map<std::string, std::string>& options ) const
{
    CreateTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    CreateTableResponse actualResponse_;
    submitRequest("/create/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new table or collection. If a new table is being created,
 * the type of the table is given by @a typeId, which must the be the ID of
 * a currently registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,CreateTypeResponse&) const}).
 * The
 * table will be created inside a collection if the option
 * @a collection_name is specified. If that collection does
 * not already exist, it will be created.
 * <p>
 * To create a new collection, specify the name of the collection in
 * @a tableName and set the @a is_collection option to
 * @a true; @a typeId will be
 * ignored.
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../concepts/tables.html#replication"
 * target="_top">replicated</a> distribution scheme,
 * have <a href="../../concepts/tables.html#foreign-keys" target="_top">foreign
 * keys</a> to other
 * tables assigned, be assigned a
 * <a href="../../concepts/tables.html#partitioning"
 * target="_top">partitioning</a> scheme, or have a
 * <a href="../../rm/concepts.html#tier-strategies" target="_top">tier
 * strategy</a> assigned.
 * 
 * @param tableName  Name of the table to be created. Error for requests with
 *                   existing table of the same name and type id may be
 *                   suppressed by using the @a no_error_if_exists option.  See
 *                   <a href="../../concepts/tables.html"
 *                   target="_top">Tables</a> for naming restrictions.
 * @param typeId  ID of a currently registered type. All objects added to the
 *                newly created table will be of this type.  Ignored if @a
 *                is_collection is @a true.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_no_error_if_exists: If @a
 *                 true, prevents an error from occurring if the table already
 *                 exists and is of the given type.  If a table with the same
 *                 ID but a different type exists, it is still an error.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_collection_name: Name of a
 *                 collection which is to contain the newly created table. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 table will be a top-level table.
 *                         <li> gpudb::create_table_is_collection: Indicates
 *                 whether the new table to be created will be a collection.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li>
 *                 gpudb::create_table_disallow_homogeneous_tables: No longer
 *                 supported; value will be ignored.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_is_replicated: For a table,
 *                 affects the <a
 *                 href="../../concepts/tables.html#distribution"
 *                 target="_top">distribution scheme</a> for the table's data.
 *                 If true and the given type has no explicit <a
 *                 href="../../concepts/tables.html#shard-key"
 *                 target="_top">shard key</a> defined, the table will be <a
 *                 href="../../concepts/tables.html#replication"
 *                 target="_top">replicated</a>.  If false, the table will be
 *                 <a href="../../concepts/tables.html#sharding"
 *                 target="_top">sharded</a> according to the shard key
 *                 specified in the given @a typeId, or <a
 *                 href="../../concepts/tables.html#random-sharding"
 *                 target="_top">randomly sharded</a>, if no shard key is
 *                 specified.  Note that a type containing a shard key cannot
 *                 be used to create a replicated table.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_foreign_keys:
 *                 Semicolon-separated list of <a
 *                 href="../../concepts/tables.html#foreign-keys"
 *                 target="_top">foreign keys</a>, of the format
 *                 '(source_column_name [, ...]) references
 *                 target_table_name(primary_key_column_name [, ...]) [as
 *                 foreign_key_name]'.
 *                         <li> gpudb::create_table_foreign_shard_key: Foreign
 *                 shard key of the format 'source_column references
 *                 shard_by_column from target_table(primary_key_column)'.
 *                         <li> gpudb::create_table_partition_type: <a
 *                 href="../../concepts/tables.html#partitioning"
 *                 target="_top">Partitioning</a> scheme to use.
 *                 <ul>
 *                         <li> gpudb::create_table_RANGE: Use <a
 *                 href="../../concepts/tables.html#partitioning-by-range"
 *                 target="_top">range partitioning</a>.
 *                         <li> gpudb::create_table_INTERVAL: Use <a
 *                 href="../../concepts/tables.html#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>.
 *                         <li> gpudb::create_table_LIST: Use <a
 *                 href="../../concepts/tables.html#partitioning-by-list"
 *                 target="_top">list partitioning</a>.
 *                 </ul>
 *                         <li> gpudb::create_table_partition_keys:
 *                 Comma-separated list of partition keys, which are the
 *                 columns or column expressions by which records will be
 *                 assigned to partitions defined by @a partition_definitions.
 *                         <li> gpudb::create_table_partition_definitions:
 *                 Comma-separated list of partition definitions, whose format
 *                 depends on the choice of @a partition_type.  See <a
 *                 href="../../concepts/tables.html#partitioning-by-range"
 *                 target="_top">range partitioning</a>, <a
 *                 href="../../concepts/tables.html#partitioning-by-interval"
 *                 target="_top">interval partitioning</a>, or <a
 *                 href="../../concepts/tables.html#partitioning-by-list"
 *                 target="_top">list partitioning</a> for example formats.
 *                         <li> gpudb::create_table_is_automatic_partition: If
 *                 true, a new partition will be created for values which don't
 *                 fall into an existing partition.  Currently only supported
 *                 for <a
 *                 href="../../concepts/tables.html#partitioning-by-list"
 *                 target="_top">list partitions</a>.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_ttl: For a table, sets the
 *                 <a href="../../concepts/ttl.html" target="_top">TTL</a> of
 *                 the table specified in @a tableName.
 *                         <li> gpudb::create_table_chunk_size: Indicates the
 *                 chunk size to be used for this table.
 *                         <li> gpudb::create_table_is_result_table: For a
 *                 table, indicates whether the table is an in-memory table. A
 *                 result table cannot contain store_only, text_search, or
 *                 string columns (charN columns are acceptable), and it will
 *                 not be retained if the server is restarted.
 *                 <ul>
 *                         <li> gpudb::create_table_true
 *                         <li> gpudb::create_table_false
 *                 </ul>
 *                 The default value is gpudb::create_table_false.
 *                         <li> gpudb::create_table_strategy_definition: The <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy</a> for the table and its
 *                 columns. See <a
 *                 href="../../rm/concepts.html#tier-strategies"
 *                 target="_top">tier strategy usage</a> for format and <a
 *                 href="../../rm/usage.html#tier-strategies"
 *                 target="_top">tier strategy examples</a> for examples.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& GPUdb::createTable( const std::string& tableName,
                                         const std::string& typeId,
                                         const std::map<std::string, std::string>& options,
                                         CreateTableResponse& response_ ) const
{
    CreateTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    submitRequest("/create/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a monitor that watches for table modification events such as insert,
 * update or delete on a particular table (identified by @a tableName) and
 * forwards event notifications to subscribers via ZMQ. After this call
 * completes, subscribe to the returned @a topicId on the ZMQ table monitor
 * port (default 9002). Each time a modification operation on the table
 * completes, a multipart message is published for that topic; the first part
 * contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of whether
 * or not there are any subscribers) until deactivated with {@link
 * #clearTableMonitor(const ClearTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse GPUdb::createTableMonitor( const CreateTableMonitorRequest& request_ ) const
{
    CreateTableMonitorResponse actualResponse_;
    submitRequest("/create/tablemonitor", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a monitor that watches for table modification events such as insert,
 * update or delete on a particular table (identified by @a tableName) and
 * forwards event notifications to subscribers via ZMQ. After this call
 * completes, subscribe to the returned @a topicId on the ZMQ table monitor
 * port (default 9002). Each time a modification operation on the table
 * completes, a multipart message is published for that topic; the first part
 * contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of whether
 * or not there are any subscribers) until deactivated with {@link
 * #clearTableMonitor(const ClearTableMonitorRequest&,ClearTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& GPUdb::createTableMonitor( const CreateTableMonitorRequest& request_,
                                                       CreateTableMonitorResponse& response_ ) const
{
    submitRequest("/create/tablemonitor", request_, response_, false);
    return response_;
}


/**
 * Creates a monitor that watches for table modification events such as insert,
 * update or delete on a particular table (identified by @a tableName) and
 * forwards event notifications to subscribers via ZMQ. After this call
 * completes, subscribe to the returned @a topicId on the ZMQ table monitor
 * port (default 9002). Each time a modification operation on the table
 * completes, a multipart message is published for that topic; the first part
 * contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of whether
 * or not there are any subscribers) until deactivated with {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param tableName  Name of the table to monitor. Must not refer to a
 *                   collection.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_event:
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_insert: Get
 *                 notifications of new record insertions. The new row images
 *                 are forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_update: Get
 *                 notifications of update operations. The modified row count
 *                 information is forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_delete: Get
 *                 notifications of delete operations. The deleted row count
 *                 information is forwarded to the subscribers.
 *                 </ul>
 *                 The default value is gpudb::create_table_monitor_insert.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse GPUdb::createTableMonitor( const std::string& tableName,
                                                      const std::map<std::string, std::string>& options ) const
{
    CreateTableMonitorRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    CreateTableMonitorResponse actualResponse_;
    submitRequest("/create/tablemonitor", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a monitor that watches for table modification events such as insert,
 * update or delete on a particular table (identified by @a tableName) and
 * forwards event notifications to subscribers via ZMQ. After this call
 * completes, subscribe to the returned @a topicId on the ZMQ table monitor
 * port (default 9002). Each time a modification operation on the table
 * completes, a multipart message is published for that topic; the first part
 * contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using @a typeSchema. The monitor will continue to run (regardless of whether
 * or not there are any subscribers) until deactivated with {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&,ClearTableMonitorResponse&) const}.
 * 
 * @param tableName  Name of the table to monitor. Must not refer to a
 *                   collection.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_event:
 *                 <ul>
 *                         <li> gpudb::create_table_monitor_insert: Get
 *                 notifications of new record insertions. The new row images
 *                 are forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_update: Get
 *                 notifications of update operations. The modified row count
 *                 information is forwarded to the subscribers.
 *                         <li> gpudb::create_table_monitor_delete: Get
 *                 notifications of delete operations. The deleted row count
 *                 information is forwarded to the subscribers.
 *                 </ul>
 *                 The default value is gpudb::create_table_monitor_insert.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& GPUdb::createTableMonitor( const std::string& tableName,
                                                       const std::map<std::string, std::string>& options,
                                                       CreateTableMonitorResponse& response_ ) const
{
    CreateTableMonitorRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/create/tablemonitor", actualRequest_, response_, false);
    return response_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&) const}.) Once
 * the trigger has been activated, any record added to the listed tables(s) via
 * {@link #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001' but able to be retrieved via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&) const}) for any
 * listening client to collect. Active triggers can be cancelled by using the
 * {@link #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse GPUdb::createTriggerByArea( const CreateTriggerByAreaRequest& request_ ) const
{
    CreateTriggerByAreaResponse actualResponse_;
    submitRequest("/create/trigger/byarea", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the chosen columns' values falling within the specified region will
 * trip the trigger. All such records will be queued at the trigger port (by
 * default '9001' but able to be retrieved via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& GPUdb::createTriggerByArea( const CreateTriggerByAreaRequest& request_,
                                                         CreateTriggerByAreaResponse& response_ ) const
{
    submitRequest("/create/trigger/byarea", request_, response_, false);
    return response_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * columns' values falling within the specified region will trip the trigger.
 * All such records will be queued at the trigger port (by default '9001' but
 * able to be retrieved via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse GPUdb::createTriggerByArea( const std::string& requestId,
                                                        const std::vector<std::string>& tableNames,
                                                        const std::string& xColumnName,
                                                        const std::vector<double>& xVector,
                                                        const std::string& yColumnName,
                                                        const std::vector<double>& yVector,
                                                        const std::map<std::string, std::string>& options ) const
{
    CreateTriggerByAreaRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    CreateTriggerByAreaResponse actualResponse_;
    submitRequest("/create/trigger/byarea", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * columns' values falling within the specified region will trip the trigger.
 * All such records will be queued at the trigger port (by default '9001' but
 * able to be retrieved via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& GPUdb::createTriggerByArea( const std::string& requestId,
                                                         const std::vector<std::string>& tableNames,
                                                         const std::string& xColumnName,
                                                         const std::vector<double>& xVector,
                                                         const std::string& yColumnName,
                                                         const std::vector<double>& yVector,
                                                         const std::map<std::string, std::string>& options,
                                                         CreateTriggerByAreaResponse& response_ ) const
{
    CreateTriggerByAreaRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    submitRequest("/create/trigger/byarea", actualRequest_, response_, false);
    return response_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001' but able to be retrieved via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&) const}) for any
 * listening client to collect. Active triggers can be cancelled by using the
 * {@link #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse GPUdb::createTriggerByRange( const CreateTriggerByRangeRequest& request_ ) const
{
    CreateTriggerByRangeResponse actualResponse_;
    submitRequest("/create/trigger/byrange", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the chosen column_name's value falling within the specified range will
 * trip the trigger. All such records will be queued at the trigger port (by
 * default '9001' but able to be retrieved via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& GPUdb::createTriggerByRange( const CreateTriggerByRangeRequest& request_,
                                                           CreateTriggerByRangeResponse& response_ ) const
{
    submitRequest("/create/trigger/byrange", request_, response_, false);
    return response_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001' but able to be retrieved via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Tables on which the trigger will be active.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse GPUdb::createTriggerByRange( const std::string& requestId,
                                                          const std::vector<std::string>& tableNames,
                                                          const std::string& columnName,
                                                          const double min,
                                                          const double max,
                                                          const std::map<std::string, std::string>& options ) const
{
    CreateTriggerByRangeRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnName = columnName;
    actualRequest_.min = min;
    actualRequest_.max = max;
    actualRequest_.options = options;
    CreateTriggerByRangeResponse actualResponse_;
    submitRequest("/create/trigger/byrange", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001' but able to be retrieved via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const})
 * for any listening client to collect. Active triggers can be cancelled by
 * using the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  User-created ID for the trigger. The ID can be
 *                   alphanumeric, contain symbols, and must contain at least
 *                   one character.
 * @param tableNames  Tables on which the trigger will be active.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& GPUdb::createTriggerByRange( const std::string& requestId,
                                                           const std::vector<std::string>& tableNames,
                                                           const std::string& columnName,
                                                           const double min,
                                                           const double max,
                                                           const std::map<std::string, std::string>& options,
                                                           CreateTriggerByRangeResponse& response_ ) const
{
    CreateTriggerByRangeRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnName = columnName;
    actualRequest_.min = min;
    actualRequest_.max = max;
    actualRequest_.options = options;
    submitRequest("/create/trigger/byrange", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new type describing the layout or schema of a table. The type
 * definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../concepts/tables.html#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary key values that match existing objects will
 * either overwrite (i.e. update) the existing object or will be skipped and
 * not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse GPUdb::createType( const CreateTypeRequest& request_ ) const
{
    CreateTypeResponse actualResponse_;
    submitRequest("/create/type", request_, actualResponse_, false);
    setDecoderIfMissing( actualResponse_.typeId,
                         actualResponse_.label,
                         actualResponse_.typeDefinition,
                         actualResponse_.properties );
    return actualResponse_;
}


/**
 * Creates a new type describing the layout or schema of a table. The type
 * definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../concepts/tables.html#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const
 * inserting} data into a table with a primary key, depending on the parameters
 * in the request, incoming objects with primary key values that match existing
 * objects will either overwrite (i.e. update) the existing object or will be
 * skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& GPUdb::createType( const CreateTypeRequest& request_,
                                       CreateTypeResponse& response_ ) const
{
    submitRequest("/create/type", request_, response_, false);
    setDecoderIfMissing( response_.typeId,
                         response_.label,
                         response_.typeDefinition,
                         response_.properties );
    return response_;
}


/**
 * Creates a new type describing the layout or schema of a table. The type
 * definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../concepts/tables.html#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary key values that match existing objects will
 * either overwrite (i.e. update) the existing object or will be skipped and
 * not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).
 *                    <ul>
 *                            <li> gpudb::create_type_data: Default property
 *                    for all numeric and string type columns; makes the column
 *                    available for GPU queries.
 *                            <li> gpudb::create_type_text_search: Valid only
 *                    for 'string' columns. Enables full text search for string
 *                    columns. Can be set independently of @a data and @a
 *                    store_only.
 *                            <li> gpudb::create_type_store_only: Persist the
 *                    column value but do not make it available to queries
 *                    (e.g. /filter)-i.e. it is mutually exclusive to the @a
 *                    data property. Any 'bytes' type column must have a @a
 *                    store_only property. This property reduces system memory
 *                    usage.
 *                            <li> gpudb::create_type_disk_optimized: Works in
 *                    conjunction with the @a data property for string columns.
 *                    This property reduces system disk usage by disabling
 *                    reverse string lookups. Queries like /filter,
 *                    /filter/bylist, and /filter/byvalue work as usual but
 *                    /aggregate/unique and /aggregate/groupby are not allowed
 *                    on columns with this property.
 *                            <li> gpudb::create_type_timestamp: Valid only for
 *                    'long' columns. Indicates that this field represents a
 *                    timestamp and will be provided in milliseconds since the
 *                    Unix epoch: 00:00:00 Jan 1 1970.  Dates represented by a
 *                    timestamp must fall between the year 1000 and the year
 *                    2900.
 *                            <li> gpudb::create_type_decimal: Valid only for
 *                    'string' columns.  It represents a SQL type NUMERIC(19,
 *                    4) data type.  There can be up to 15 digits before the
 *                    decimal point and up to four digits in the fractional
 *                    part.  The value can be positive or negative (indicated
 *                    by a minus sign at the beginning).  This property is
 *                    mutually exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_date: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    date and will be provided in the format 'YYYY-MM-DD'.
 *                    The allowable range is 1000-01-01 through 2900-01-01.
 *                    This property is mutually exclusive with the @a
 *                    text_search property.
 *                            <li> gpudb::create_type_time: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    time-of-day and will be provided in the format
 *                    'HH:MM:SS.mmm'.  The allowable range is 00:00:00.000
 *                    through 23:59:59.999.  This property is mutually
 *                    exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_datetime: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    datetime and will be provided in the format 'YYYY-MM-DD
 *                    HH:MM:SS.mmm'.  The allowable range is 1000-01-01
 *                    00:00:00.000 through 2900-01-01 23:59:59.999.  This
 *                    property is mutually exclusive with the @a text_search
 *                    property.
 *                            <li> gpudb::create_type_char1: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 1 character.
 *                            <li> gpudb::create_type_char2: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 2 characters.
 *                            <li> gpudb::create_type_char4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 4 characters.
 *                            <li> gpudb::create_type_char8: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 8 characters.
 *                            <li> gpudb::create_type_char16: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 16 characters.
 *                            <li> gpudb::create_type_char32: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 32 characters.
 *                            <li> gpudb::create_type_char64: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 64 characters.
 *                            <li> gpudb::create_type_char128: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 128 characters.
 *                            <li> gpudb::create_type_char256: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 256 characters.
 *                            <li> gpudb::create_type_int8: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -128 and
 *                    +127 (inclusive)
 *                            <li> gpudb::create_type_int16: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -32768
 *                    and +32767 (inclusive)
 *                            <li> gpudb::create_type_ipv4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns representing IPv4 addresses (i.e.
 *                    192.168.1.1). Strings with this property must be of the
 *                    form: A.B.C.D where A, B, C and D are in the range of
 *                    0-255.
 *                            <li> gpudb::create_type_wkt: Valid only for
 *                    'string' and 'bytes' columns. Indicates that this field
 *                    contains geospatial geometry objects in Well-Known Text
 *                    (WKT) or Well-Known Binary (WKB) format.
 *                            <li> gpudb::create_type_primary_key: This
 *                    property indicates that this column will be part of (or
 *                    the entire) <a
 *                    href="../../concepts/tables.html#primary-keys"
 *                    target="_top">primary key</a>.
 *                            <li> gpudb::create_type_shard_key: This property
 *                    indicates that this column will be part of (or the
 *                    entire) <a href="../../concepts/tables.html#shard-keys"
 *                    target="_top">shard key</a>.
 *                            <li> gpudb::create_type_nullable: This property
 *                    indicates that this column is nullable.  However, setting
 *                    this property is insufficient for making the column
 *                    nullable.  The user must declare the type of the column
 *                    as a union between its regular type and 'null' in the
 *                    avro schema for the record type in @a typeDefinition.
 *                    For example, if a column is of type integer and is
 *                    nullable, then the entry for the column in the avro
 *                    schema must be: ['int', 'null'].
 *                    The C++, C#, Java, and Python APIs have built-in
 *                    convenience for bypassing setting the avro schema by
 *                    hand.  For those languages, one can use this property as
 *                    usual and not have to worry about the avro schema for the
 *                    record.
 *                            <li> gpudb::create_type_dict: This property
 *                    indicates that this column should be <a
 *                    href="../../concepts/dictionary_encoding.html"
 *                    target="_top">dictionary encoded</a>. It can only be used
 *                    in conjunction with restricted string (charN), int, long
 *                    or date columns. Dictionary encoding is best for columns
 *                    where the cardinality (the number of unique values) is
 *                    expected to be low. This property can save a large amount
 *                    of memory.
 *                            <li> gpudb::create_type_init_with_now: For
 *                    'date', 'time', 'datetime', or 'timestamp' column types,
 *                    replace empty strings and invalid timestamps with 'NOW()'
 *                    upon insert.
 *                    </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse GPUdb::createType( const std::string& typeDefinition,
                                      const std::string& label,
                                      const std::map<std::string, std::vector<std::string> >& properties,
                                      const std::map<std::string, std::string>& options ) const
{
    CreateTypeRequest actualRequest_;
    actualRequest_.typeDefinition = typeDefinition;
    actualRequest_.label = label;
    actualRequest_.properties = properties;
    actualRequest_.options = options;
    CreateTypeResponse actualResponse_;
    submitRequest("/create/type", actualRequest_, actualResponse_, false);
    setDecoderIfMissing( actualResponse_.typeId,
                         actualResponse_.label,
                         actualResponse_.typeDefinition,
                         actualResponse_.properties );
    return actualResponse_;
}


/**
 * Creates a new type describing the layout or schema of a table. The type
 * definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * A single <a href="../../concepts/tables.html#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../concepts/tables.html#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary key values that match existing objects will
 * either overwrite (i.e. update) the existing object or will be skipped and
 * not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).
 *                    <ul>
 *                            <li> gpudb::create_type_data: Default property
 *                    for all numeric and string type columns; makes the column
 *                    available for GPU queries.
 *                            <li> gpudb::create_type_text_search: Valid only
 *                    for 'string' columns. Enables full text search for string
 *                    columns. Can be set independently of @a data and @a
 *                    store_only.
 *                            <li> gpudb::create_type_store_only: Persist the
 *                    column value but do not make it available to queries
 *                    (e.g. /filter)-i.e. it is mutually exclusive to the @a
 *                    data property. Any 'bytes' type column must have a @a
 *                    store_only property. This property reduces system memory
 *                    usage.
 *                            <li> gpudb::create_type_disk_optimized: Works in
 *                    conjunction with the @a data property for string columns.
 *                    This property reduces system disk usage by disabling
 *                    reverse string lookups. Queries like /filter,
 *                    /filter/bylist, and /filter/byvalue work as usual but
 *                    /aggregate/unique and /aggregate/groupby are not allowed
 *                    on columns with this property.
 *                            <li> gpudb::create_type_timestamp: Valid only for
 *                    'long' columns. Indicates that this field represents a
 *                    timestamp and will be provided in milliseconds since the
 *                    Unix epoch: 00:00:00 Jan 1 1970.  Dates represented by a
 *                    timestamp must fall between the year 1000 and the year
 *                    2900.
 *                            <li> gpudb::create_type_decimal: Valid only for
 *                    'string' columns.  It represents a SQL type NUMERIC(19,
 *                    4) data type.  There can be up to 15 digits before the
 *                    decimal point and up to four digits in the fractional
 *                    part.  The value can be positive or negative (indicated
 *                    by a minus sign at the beginning).  This property is
 *                    mutually exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_date: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    date and will be provided in the format 'YYYY-MM-DD'.
 *                    The allowable range is 1000-01-01 through 2900-01-01.
 *                    This property is mutually exclusive with the @a
 *                    text_search property.
 *                            <li> gpudb::create_type_time: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    time-of-day and will be provided in the format
 *                    'HH:MM:SS.mmm'.  The allowable range is 00:00:00.000
 *                    through 23:59:59.999.  This property is mutually
 *                    exclusive with the @a text_search property.
 *                            <li> gpudb::create_type_datetime: Valid only for
 *                    'string' columns.  Indicates that this field represents a
 *                    datetime and will be provided in the format 'YYYY-MM-DD
 *                    HH:MM:SS.mmm'.  The allowable range is 1000-01-01
 *                    00:00:00.000 through 2900-01-01 23:59:59.999.  This
 *                    property is mutually exclusive with the @a text_search
 *                    property.
 *                            <li> gpudb::create_type_char1: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 1 character.
 *                            <li> gpudb::create_type_char2: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 2 characters.
 *                            <li> gpudb::create_type_char4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 4 characters.
 *                            <li> gpudb::create_type_char8: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 8 characters.
 *                            <li> gpudb::create_type_char16: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 16 characters.
 *                            <li> gpudb::create_type_char32: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 32 characters.
 *                            <li> gpudb::create_type_char64: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 64 characters.
 *                            <li> gpudb::create_type_char128: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 128 characters.
 *                            <li> gpudb::create_type_char256: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns. Strings with this property must be no
 *                    longer than 256 characters.
 *                            <li> gpudb::create_type_int8: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -128 and
 *                    +127 (inclusive)
 *                            <li> gpudb::create_type_int16: This property
 *                    provides optimized memory and query performance for int
 *                    columns. Ints with this property must be between -32768
 *                    and +32767 (inclusive)
 *                            <li> gpudb::create_type_ipv4: This property
 *                    provides optimized memory, disk and query performance for
 *                    string columns representing IPv4 addresses (i.e.
 *                    192.168.1.1). Strings with this property must be of the
 *                    form: A.B.C.D where A, B, C and D are in the range of
 *                    0-255.
 *                            <li> gpudb::create_type_wkt: Valid only for
 *                    'string' and 'bytes' columns. Indicates that this field
 *                    contains geospatial geometry objects in Well-Known Text
 *                    (WKT) or Well-Known Binary (WKB) format.
 *                            <li> gpudb::create_type_primary_key: This
 *                    property indicates that this column will be part of (or
 *                    the entire) <a
 *                    href="../../concepts/tables.html#primary-keys"
 *                    target="_top">primary key</a>.
 *                            <li> gpudb::create_type_shard_key: This property
 *                    indicates that this column will be part of (or the
 *                    entire) <a href="../../concepts/tables.html#shard-keys"
 *                    target="_top">shard key</a>.
 *                            <li> gpudb::create_type_nullable: This property
 *                    indicates that this column is nullable.  However, setting
 *                    this property is insufficient for making the column
 *                    nullable.  The user must declare the type of the column
 *                    as a union between its regular type and 'null' in the
 *                    avro schema for the record type in @a typeDefinition.
 *                    For example, if a column is of type integer and is
 *                    nullable, then the entry for the column in the avro
 *                    schema must be: ['int', 'null'].
 *                    The C++, C#, Java, and Python APIs have built-in
 *                    convenience for bypassing setting the avro schema by
 *                    hand.  For those languages, one can use this property as
 *                    usual and not have to worry about the avro schema for the
 *                    record.
 *                            <li> gpudb::create_type_dict: This property
 *                    indicates that this column should be <a
 *                    href="../../concepts/dictionary_encoding.html"
 *                    target="_top">dictionary encoded</a>. It can only be used
 *                    in conjunction with restricted string (charN), int, long
 *                    or date columns. Dictionary encoding is best for columns
 *                    where the cardinality (the number of unique values) is
 *                    expected to be low. This property can save a large amount
 *                    of memory.
 *                            <li> gpudb::create_type_init_with_now: For
 *                    'date', 'time', 'datetime', or 'timestamp' column types,
 *                    replace empty strings and invalid timestamps with 'NOW()'
 *                    upon insert.
 *                    </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& GPUdb::createType( const std::string& typeDefinition,
                                       const std::string& label,
                                       const std::map<std::string, std::vector<std::string> >& properties,
                                       const std::map<std::string, std::string>& options,
                                       CreateTypeResponse& response_ ) const
{
    CreateTypeRequest actualRequest_;
    actualRequest_.typeDefinition = typeDefinition;
    actualRequest_.label = label;
    actualRequest_.properties = properties;
    actualRequest_.options = options;
    submitRequest("/create/type", actualRequest_, response_, false);
    setDecoderIfMissing( response_.typeId,
                         response_.label,
                         response_.typeDefinition,
                         response_.properties );
    return response_;
}


/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../concepts/unions.html" target="_top">Union</a>.  For limitations,
 * see <a href="../../concepts/unions.html#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../concepts/intersect.html" target="_top">Intersect</a>.
 * For limitations, see <a href="../../concepts/intersect.html#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../concepts/except.html" target="_top">Except</a>.  For
 * limitations, see <a href="../../concepts/except.html#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a
 * href="../../concepts/filtered_views.html" target="_top">filtered views</a>
 * on a single table, creates a single filtered view containing all of the
 * unique records across all of the given filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUnionResponse GPUdb::createUnion( const CreateUnionRequest& request_ ) const
{
    CreateUnionResponse actualResponse_;
    submitRequest("/create/union", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../concepts/unions.html" target="_top">Union</a>.  For limitations,
 * see <a href="../../concepts/unions.html#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../concepts/intersect.html" target="_top">Intersect</a>.
 * For limitations, see <a href="../../concepts/intersect.html#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../concepts/except.html" target="_top">Except</a>.  For
 * limitations, see <a href="../../concepts/except.html#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a
 * href="../../concepts/filtered_views.html" target="_top">filtered views</a>
 * on a single table, creates a single filtered view containing all of the
 * unique records across all of the given filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUnionResponse& GPUdb::createUnion( const CreateUnionRequest& request_,
                                         CreateUnionResponse& response_ ) const
{
    submitRequest("/create/union", request_, response_, false);
    return response_;
}


/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../concepts/unions.html" target="_top">Union</a>.  For limitations,
 * see <a href="../../concepts/unions.html#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../concepts/intersect.html" target="_top">Intersect</a>.
 * For limitations, see <a href="../../concepts/intersect.html#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../concepts/except.html" target="_top">Except</a>.  For
 * limitations, see <a href="../../concepts/except.html#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a
 * href="../../concepts/filtered_views.html" target="_top">filtered views</a>
 * on a single table, creates a single filtered view containing all of the
 * unique records across all of the given filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param tableName  Name of the table to be created. Has the same naming
 *                   restrictions as <a href="../../concepts/tables.html"
 *                   target="_top">tables</a>.
 * @param tableNames  The list of table names to merge. Must contain the names
 *                    of one or more existing tables.
 * @param inputColumnNames  The list of columns from each of the corresponding
 *                          input tables.
 * @param outputColumnNames  The list of names of the columns to be stored in
 *                           the output table.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_union_collection_name: Name of a
 *                 collection which is to contain the output table. If the
 *                 collection provided is non-existent, the collection will be
 *                 automatically created. If empty, the output table will be a
 *                 top-level table.  The default value is ''.
 *                         <li> gpudb::create_union_materialize_on_gpu: If @a
 *                 true, then the columns of the output table will be cached on
 *                 the GPU.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_mode: If @a merge_views,
 *                 then this operation will merge the provided views. All @a
 *                 tableNames must be views from the same underlying base
 *                 table.
 *                 <ul>
 *                         <li> gpudb::create_union_union_all: Retains all rows
 *                 from the specified tables.
 *                         <li> gpudb::create_union_union: Retains all unique
 *                 rows from the specified tables (synonym for @a
 *                 union_distinct).
 *                         <li> gpudb::create_union_union_distinct: Retains all
 *                 unique rows from the specified tables.
 *                         <li> gpudb::create_union_except: Retains all unique
 *                 rows from the first table that do not appear in the second
 *                 table (only works on 2 tables).
 *                         <li> gpudb::create_union_except_all: Retains all
 *                 rows(including duplicates) from the first table that do not
 *                 appear in the second table (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect: Retains all
 *                 unique rows that appear in both of the specified tables
 *                 (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect_all: Retains all
 *                 rows(including duplicates) that appear in both of the
 *                 specified tables (only works on 2 tables).
 *                         <li> gpudb::create_union_merge_views: Merge two or
 *                 more views (or views of views) of the same base data set
 *                 into a new view. If this mode is selected @a
 *                 inputColumnNames AND @a outputColumnNames must be empty. The
 *                 resulting view would match the results of a SQL OR
 *                 operation, e.g., if filter 1 creates a view using the
 *                 expression 'x = 20' and filter 2 creates a view using the
 *                 expression 'x <= 10', then the merge views operation creates
 *                 a new view using the expression 'x = 20 OR x <= 10'.
 *                 </ul>
 *                 The default value is gpudb::create_union_union_all.
 *                         <li> gpudb::create_union_chunk_size: Indicates the
 *                 chunk size to be used for this table.
 *                         <li> gpudb::create_union_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the output table.  The columns specified must be present
 *                 in @a outputColumnNames.
 *                         <li> gpudb::create_union_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a tableName.
 *                         <li> gpudb::create_union_persist: If @a true, then
 *                 the table specified in @a tableName will be persisted and
 *                 will not expire unless a @a ttl is specified.   If @a false,
 *                 then the table will be an in-memory table and will expire
 *                 unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_view_id: view the output
 *                 table will be a part of.  The default value is ''.
 *                         <li> gpudb::create_union_force_replicated: If @a
 *                 true, then the table specified in @a tableName will be
 *                 replicated even if the source tables are not.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUnionResponse GPUdb::createUnion( const std::string& tableName,
                                        const std::vector<std::string>& tableNames,
                                        const std::vector<std::vector<std::string> >& inputColumnNames,
                                        const std::vector<std::string>& outputColumnNames,
                                        const std::map<std::string, std::string>& options ) const
{
    CreateUnionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputColumnNames = outputColumnNames;
    actualRequest_.options = options;
    CreateUnionResponse actualResponse_;
    submitRequest("/create/union", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../concepts/unions.html" target="_top">Union</a>.  For limitations,
 * see <a href="../../concepts/unions.html#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../concepts/intersect.html" target="_top">Intersect</a>.
 * For limitations, see <a href="../../concepts/intersect.html#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../concepts/except.html" target="_top">Except</a>.  For
 * limitations, see <a href="../../concepts/except.html#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a
 * href="../../concepts/filtered_views.html" target="_top">filtered views</a>
 * on a single table, creates a single filtered view containing all of the
 * unique records across all of the given filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../concepts/types.html#data-handling"
 * target="_top">store-only</a>.
 * 
 * @param tableName  Name of the table to be created. Has the same naming
 *                   restrictions as <a href="../../concepts/tables.html"
 *                   target="_top">tables</a>.
 * @param tableNames  The list of table names to merge. Must contain the names
 *                    of one or more existing tables.
 * @param inputColumnNames  The list of columns from each of the corresponding
 *                          input tables.
 * @param outputColumnNames  The list of names of the columns to be stored in
 *                           the output table.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_union_collection_name: Name of a
 *                 collection which is to contain the output table. If the
 *                 collection provided is non-existent, the collection will be
 *                 automatically created. If empty, the output table will be a
 *                 top-level table.  The default value is ''.
 *                         <li> gpudb::create_union_materialize_on_gpu: If @a
 *                 true, then the columns of the output table will be cached on
 *                 the GPU.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_mode: If @a merge_views,
 *                 then this operation will merge the provided views. All @a
 *                 tableNames must be views from the same underlying base
 *                 table.
 *                 <ul>
 *                         <li> gpudb::create_union_union_all: Retains all rows
 *                 from the specified tables.
 *                         <li> gpudb::create_union_union: Retains all unique
 *                 rows from the specified tables (synonym for @a
 *                 union_distinct).
 *                         <li> gpudb::create_union_union_distinct: Retains all
 *                 unique rows from the specified tables.
 *                         <li> gpudb::create_union_except: Retains all unique
 *                 rows from the first table that do not appear in the second
 *                 table (only works on 2 tables).
 *                         <li> gpudb::create_union_except_all: Retains all
 *                 rows(including duplicates) from the first table that do not
 *                 appear in the second table (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect: Retains all
 *                 unique rows that appear in both of the specified tables
 *                 (only works on 2 tables).
 *                         <li> gpudb::create_union_intersect_all: Retains all
 *                 rows(including duplicates) that appear in both of the
 *                 specified tables (only works on 2 tables).
 *                         <li> gpudb::create_union_merge_views: Merge two or
 *                 more views (or views of views) of the same base data set
 *                 into a new view. If this mode is selected @a
 *                 inputColumnNames AND @a outputColumnNames must be empty. The
 *                 resulting view would match the results of a SQL OR
 *                 operation, e.g., if filter 1 creates a view using the
 *                 expression 'x = 20' and filter 2 creates a view using the
 *                 expression 'x <= 10', then the merge views operation creates
 *                 a new view using the expression 'x = 20 OR x <= 10'.
 *                 </ul>
 *                 The default value is gpudb::create_union_union_all.
 *                         <li> gpudb::create_union_chunk_size: Indicates the
 *                 chunk size to be used for this table.
 *                         <li> gpudb::create_union_create_indexes:
 *                 Comma-separated list of columns on which to create indexes
 *                 on the output table.  The columns specified must be present
 *                 in @a outputColumnNames.
 *                         <li> gpudb::create_union_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 table specified in @a tableName.
 *                         <li> gpudb::create_union_persist: If @a true, then
 *                 the table specified in @a tableName will be persisted and
 *                 will not expire unless a @a ttl is specified.   If @a false,
 *                 then the table will be an in-memory table and will expire
 *                 unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                         <li> gpudb::create_union_view_id: view the output
 *                 table will be a part of.  The default value is ''.
 *                         <li> gpudb::create_union_force_replicated: If @a
 *                 true, then the table specified in @a tableName will be
 *                 replicated even if the source tables are not.
 *                 <ul>
 *                         <li> gpudb::create_union_true
 *                         <li> gpudb::create_union_false
 *                 </ul>
 *                 The default value is gpudb::create_union_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUnionResponse& GPUdb::createUnion( const std::string& tableName,
                                         const std::vector<std::string>& tableNames,
                                         const std::vector<std::vector<std::string> >& inputColumnNames,
                                         const std::vector<std::string>& outputColumnNames,
                                         const std::map<std::string, std::string>& options,
                                         CreateUnionResponse& response_ ) const
{
    CreateUnionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputColumnNames = outputColumnNames;
    actualRequest_.options = options;
    submitRequest("/create/union", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserExternalResponse GPUdb::createUserExternal( const CreateUserExternalRequest& request_ ) const
{
    CreateUserExternalResponse actualResponse_;
    submitRequest("/create/user/external", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserExternalResponse& GPUdb::createUserExternal( const CreateUserExternalRequest& request_,
                                                       CreateUserExternalResponse& response_ ) const
{
    submitRequest("/create/user/external", request_, response_, false);
    return response_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param name  Name of the user to be created. Must exactly match the user's
 *              name in the external LDAP, prefixed with a @. Must not be the
 *              same name as an existing user.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserExternalResponse GPUdb::createUserExternal( const std::string& name,
                                                      const std::map<std::string, std::string>& options ) const
{
    CreateUserExternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    CreateUserExternalResponse actualResponse_;
    submitRequest("/create/user/external", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param name  Name of the user to be created. Must exactly match the user's
 *              name in the external LDAP, prefixed with a @. Must not be the
 *              same name as an existing user.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserExternalResponse& GPUdb::createUserExternal( const std::string& name,
                                                       const std::map<std::string, std::string>& options,
                                                       CreateUserExternalResponse& response_ ) const
{
    CreateUserExternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/create/user/external", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserInternalResponse GPUdb::createUserInternal( const CreateUserInternalRequest& request_ ) const
{
    CreateUserInternalResponse actualResponse_;
    submitRequest("/create/user/internal", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserInternalResponse& GPUdb::createUserInternal( const CreateUserInternalRequest& request_,
                                                       CreateUserInternalResponse& response_ ) const
{
    submitRequest("/create/user/internal", request_, response_, false);
    return response_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param name  Name of the user to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param password  Initial password of the user to be created. May be an empty
 *                  string for no password.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_user_internal_resource_group:
 *                 Name of an existing resource group to associate with this
 *                 user
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserInternalResponse GPUdb::createUserInternal( const std::string& name,
                                                      const std::string& password,
                                                      const std::map<std::string, std::string>& options ) const
{
    CreateUserInternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.password = password;
    actualRequest_.options = options;
    CreateUserInternalResponse actualResponse_;
    submitRequest("/create/user/internal", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 * 
 * @param name  Name of the user to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role.
 * @param password  Initial password of the user to be created. May be an empty
 *                  string for no password.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::create_user_internal_resource_group:
 *                 Name of an existing resource group to associate with this
 *                 user
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserInternalResponse& GPUdb::createUserInternal( const std::string& name,
                                                       const std::string& password,
                                                       const std::map<std::string, std::string>& options,
                                                       CreateUserInternalResponse& response_ ) const
{
    CreateUserInternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.password = password;
    actualRequest_.options = options;
    submitRequest("/create/user/internal", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteGraphResponse GPUdb::deleteGraph( const DeleteGraphRequest& request_ ) const
{
    DeleteGraphResponse actualResponse_;
    submitRequest("/delete/graph", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteGraphResponse& GPUdb::deleteGraph( const DeleteGraphRequest& request_,
                                         DeleteGraphResponse& response_ ) const
{
    submitRequest("/delete/graph", request_, response_, false);
    return response_;
}


/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param graphName  Name of the graph to be deleted.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_graph_delete_persist: If set to
 *                 @a true, the graph is removed from the server and persist.
 *                 If set to @a false, the graph is removed from the server but
 *                 is left in persist. The graph can be reloaded from persist
 *                 if it is recreated with the same 'graph_name'.
 *                 <ul>
 *                         <li> gpudb::delete_graph_true
 *                         <li> gpudb::delete_graph_false
 *                 </ul>
 *                 The default value is gpudb::delete_graph_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteGraphResponse GPUdb::deleteGraph( const std::string& graphName,
                                        const std::map<std::string, std::string>& options ) const
{
    DeleteGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.options = options;
    DeleteGraphResponse actualResponse_;
    submitRequest("/delete/graph", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing graph from the graph server and/or persist.
 * 
 * @param graphName  Name of the graph to be deleted.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_graph_delete_persist: If set to
 *                 @a true, the graph is removed from the server and persist.
 *                 If set to @a false, the graph is removed from the server but
 *                 is left in persist. The graph can be reloaded from persist
 *                 if it is recreated with the same 'graph_name'.
 *                 <ul>
 *                         <li> gpudb::delete_graph_true
 *                         <li> gpudb::delete_graph_false
 *                 </ul>
 *                 The default value is gpudb::delete_graph_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteGraphResponse& GPUdb::deleteGraph( const std::string& graphName,
                                         const std::map<std::string, std::string>& options,
                                         DeleteGraphResponse& response_ ) const
{
    DeleteGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.options = options;
    submitRequest("/delete/graph", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteProcResponse GPUdb::deleteProc( const DeleteProcRequest& request_ ) const
{
    DeleteProcResponse actualResponse_;
    submitRequest("/delete/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteProcResponse& GPUdb::deleteProc( const DeleteProcRequest& request_,
                                       DeleteProcResponse& response_ ) const
{
    submitRequest("/delete/proc", request_, response_, false);
    return response_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param procName  Name of the proc to be deleted. Must be the name of a
 *                  currently existing proc.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteProcResponse GPUdb::deleteProc( const std::string& procName,
                                      const std::map<std::string, std::string>& options ) const
{
    DeleteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    DeleteProcResponse actualResponse_;
    submitRequest("/delete/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param procName  Name of the proc to be deleted. Must be the name of a
 *                  currently existing proc.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteProcResponse& GPUdb::deleteProc( const std::string& procName,
                                       const std::map<std::string, std::string>& options,
                                       DeleteProcResponse& response_ ) const
{
    DeleteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/delete/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a collection or a view.  The operation is synchronous meaning that a
 * response will not be available until the request is completely processed and
 * all the matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse GPUdb::deleteRecords( const DeleteRecordsRequest& request_ ) const
{
    DeleteRecordsResponse actualResponse_;
    submitRequest("/delete/records", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a collection or a view.  The operation is synchronous meaning that a
 * response will not be available until the request is completely processed and
 * all the matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& GPUdb::deleteRecords( const DeleteRecordsRequest& request_,
                                             DeleteRecordsResponse& response_ ) const
{
    submitRequest("/delete/records", request_, response_, false);
    return response_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a collection or a view.  The operation is synchronous meaning that a
 * response will not be available until the request is completely processed and
 * all the matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records. The set
 *                   must be a currently existing table and not a collection or
 *                   a view.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided <a
 *                     href="../../concepts/expressions.html"
 *                     target="_top">here</a>. Specifying one or more @a
 *                     expressions is mutually exclusive to specifying @a
 *                     record_id in the @a options.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_records_global_expression: An
 *                 optional global expression to reduce the search space of the
 *                 @a expressions.  The default value is ''.
 *                         <li> gpudb::delete_records_record_id: A record ID
 *                 identifying a single record, obtained at the time of
 *                 /insert/records or by calling /get/records/fromcollection
 *                 with the *return_record_ids* option. This option cannot be
 *                 used to delete records from <a
 *                 href="../../concepts/tables.html#replication"
 *                 target="_top">replicated</a> tables.
 *                         <li> gpudb::delete_records_delete_all_records: If
 *                 set to @a true, all records in the table will be deleted. If
 *                 set to @a false, then the option is effectively ignored.
 *                 <ul>
 *                         <li> gpudb::delete_records_true
 *                         <li> gpudb::delete_records_false
 *                 </ul>
 *                 The default value is gpudb::delete_records_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse GPUdb::deleteRecords( const std::string& tableName,
                                            const std::vector<std::string>& expressions,
                                            const std::map<std::string, std::string>& options ) const
{
    DeleteRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    DeleteRecordsResponse actualResponse_;
    submitRequest("/delete/records", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records), a single record identified by @a record_id
 * options, or all records when using @a delete_all_records.  Note that the
 * three selection criteria are mutually exclusive.  This operation cannot be
 * run on a collection or a view.  The operation is synchronous meaning that a
 * response will not be available until the request is completely processed and
 * all the matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records. The set
 *                   must be a currently existing table and not a collection or
 *                   a view.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided <a
 *                     href="../../concepts/expressions.html"
 *                     target="_top">here</a>. Specifying one or more @a
 *                     expressions is mutually exclusive to specifying @a
 *                     record_id in the @a options.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::delete_records_global_expression: An
 *                 optional global expression to reduce the search space of the
 *                 @a expressions.  The default value is ''.
 *                         <li> gpudb::delete_records_record_id: A record ID
 *                 identifying a single record, obtained at the time of
 *                 /insert/records or by calling /get/records/fromcollection
 *                 with the *return_record_ids* option. This option cannot be
 *                 used to delete records from <a
 *                 href="../../concepts/tables.html#replication"
 *                 target="_top">replicated</a> tables.
 *                         <li> gpudb::delete_records_delete_all_records: If
 *                 set to @a true, all records in the table will be deleted. If
 *                 set to @a false, then the option is effectively ignored.
 *                 <ul>
 *                         <li> gpudb::delete_records_true
 *                         <li> gpudb::delete_records_false
 *                 </ul>
 *                 The default value is gpudb::delete_records_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& GPUdb::deleteRecords( const std::string& tableName,
                                             const std::vector<std::string>& expressions,
                                             const std::map<std::string, std::string>& options,
                                             DeleteRecordsResponse& response_ ) const
{
    DeleteRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    submitRequest("/delete/records", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes a resource group.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteResourceGroupResponse GPUdb::deleteResourceGroup( const DeleteResourceGroupRequest& request_ ) const
{
    DeleteResourceGroupResponse actualResponse_;
    submitRequest("/delete/resourcegroup", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes a resource group.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteResourceGroupResponse& GPUdb::deleteResourceGroup( const DeleteResourceGroupRequest& request_,
                                                         DeleteResourceGroupResponse& response_ ) const
{
    submitRequest("/delete/resourcegroup", request_, response_, false);
    return response_;
}


/**
 * Deletes a resource group.
 * 
 * @param name  Name of the resource group to be deleted.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteResourceGroupResponse GPUdb::deleteResourceGroup( const std::string& name,
                                                        const std::map<std::string, std::string>& options ) const
{
    DeleteResourceGroupRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    DeleteResourceGroupResponse actualResponse_;
    submitRequest("/delete/resourcegroup", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes a resource group.
 * 
 * @param name  Name of the resource group to be deleted.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteResourceGroupResponse& GPUdb::deleteResourceGroup( const std::string& name,
                                                         const std::map<std::string, std::string>& options,
                                                         DeleteResourceGroupResponse& response_ ) const
{
    DeleteResourceGroupRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/delete/resourcegroup", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes an existing role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRoleResponse GPUdb::deleteRole( const DeleteRoleRequest& request_ ) const
{
    DeleteRoleResponse actualResponse_;
    submitRequest("/delete/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRoleResponse& GPUdb::deleteRole( const DeleteRoleRequest& request_,
                                       DeleteRoleResponse& response_ ) const
{
    submitRequest("/delete/role", request_, response_, false);
    return response_;
}


/**
 * Deletes an existing role.
 * 
 * @param name  Name of the role to be deleted. Must be an existing role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRoleResponse GPUdb::deleteRole( const std::string& name,
                                      const std::map<std::string, std::string>& options ) const
{
    DeleteRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    DeleteRoleResponse actualResponse_;
    submitRequest("/delete/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing role.
 * 
 * @param name  Name of the role to be deleted. Must be an existing role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRoleResponse& GPUdb::deleteRole( const std::string& name,
                                       const std::map<std::string, std::string>& options,
                                       DeleteRoleResponse& response_ ) const
{
    DeleteRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/delete/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes an existing user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteUserResponse GPUdb::deleteUser( const DeleteUserRequest& request_ ) const
{
    DeleteUserResponse actualResponse_;
    submitRequest("/delete/user", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteUserResponse& GPUdb::deleteUser( const DeleteUserRequest& request_,
                                       DeleteUserResponse& response_ ) const
{
    submitRequest("/delete/user", request_, response_, false);
    return response_;
}


/**
 * Deletes an existing user.
 * 
 * @param name  Name of the user to be deleted. Must be an existing user.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteUserResponse GPUdb::deleteUser( const std::string& name,
                                      const std::map<std::string, std::string>& options ) const
{
    DeleteUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    DeleteUserResponse actualResponse_;
    submitRequest("/delete/user", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing user.
 * 
 * @param name  Name of the user to be deleted. Must be an existing user.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteUserResponse& GPUdb::deleteUser( const std::string& name,
                                       const std::map<std::string, std::string>& options,
                                       DeleteUserResponse& response_ ) const
{
    DeleteUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/delete/user", actualRequest_, response_, false);
    return response_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse GPUdb::executeProc( const ExecuteProcRequest& request_ ) const
{
    ExecuteProcResponse actualResponse_;
    submitRequest("/execute/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& GPUdb::executeProc( const ExecuteProcRequest& request_,
                                         ExecuteProcResponse& response_ ) const
{
    submitRequest("/execute/proc", request_, response_, false);
    return response_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param procName  Name of the proc to execute. Must be the name of a
 *                  currently existing proc.
 * @param params  A map containing named parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.
 * @param binParams  A map containing named binary parameters to pass to the
 *                   proc. Each key/value pair specifies the name of a
 *                   parameter and its value.
 * @param inputTableNames  Names of the tables containing data to be passed to
 *                         the proc. Each name specified must be the name of a
 *                         currently existing table. If no table names are
 *                         specified, no data will be passed to the proc.
 * @param inputColumnNames  Map of table names from @a inputTableNames to lists
 *                          of names of columns from those tables that will be
 *                          passed to the proc. Each column name specified must
 *                          be the name of an existing column in the
 *                          corresponding table. If a table name from @a
 *                          inputTableNames is not included, all columns from
 *                          that table will be passed to the proc.
 * @param outputTableNames  Names of the tables to which output data from the
 *                          proc will be written. If a specified table does not
 *                          exist, it will automatically be created with the
 *                          same schema as the corresponding table (by order)
 *                          from @a inputTableNames, excluding any primary and
 *                          shard keys. If a specified table is a
 *                          non-persistent result table, it must not have
 *                          primary or shard keys. If no table names are
 *                          specified, no output data can be returned from the
 *                          proc.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_proc_cache_input: A
 *                 comma-delimited list of table names from @a inputTableNames
 *                 from which input data will be cached for use in subsequent
 *                 calls to /execute/proc with the @a use_cached_input option.
 *                 Cached input data will be retained until the proc status is
 *                 cleared with the /show/proc/status option of
 *                 /show/proc/status and all proc instances using the cached
 *                 data have completed.  The default value is ''.
 *                         <li> gpudb::execute_proc_use_cached_input: A
 *                 comma-delimited list of run IDs (as returned from prior
 *                 calls to /execute/proc) of running or completed proc
 *                 instances from which input data cached using the @a
 *                 cache_input option will be used. Cached input data will not
 *                 be used for any tables specified in @a inputTableNames, but
 *                 data from all other tables cached for the specified run IDs
 *                 will be passed to the proc. If the same table was cached for
 *                 multiple specified run IDs, the cached data from the first
 *                 run ID specified in the list that includes that table will
 *                 be used.  The default value is ''.
 *                         <li> gpudb::execute_proc_kifs_input_dirs: A
 *                 comma-delimited list of KiFS directories whose local files
 *                 will be made directly accessible to the proc through the
 *                 API. (All KiFS files, local or not, are also accessible
 *                 through the file system below the KiFS mount point.) Each
 *                 name specified must the name of an existing KiFS directory.
 *                 The default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse GPUdb::executeProc( const std::string& procName,
                                        const std::map<std::string, std::string>& params,
                                        const std::map<std::string, std::vector<uint8_t> >& binParams,
                                        const std::vector<std::string>& inputTableNames,
                                        const std::map<std::string, std::vector<std::string> >& inputColumnNames,
                                        const std::vector<std::string>& outputTableNames,
                                        const std::map<std::string, std::string>& options ) const
{
    ExecuteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.params = params;
    actualRequest_.binParams = binParams;
    actualRequest_.inputTableNames = inputTableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputTableNames = outputTableNames;
    actualRequest_.options = options;
    ExecuteProcResponse actualResponse_;
    submitRequest("/execute/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param procName  Name of the proc to execute. Must be the name of a
 *                  currently existing proc.
 * @param params  A map containing named parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.
 * @param binParams  A map containing named binary parameters to pass to the
 *                   proc. Each key/value pair specifies the name of a
 *                   parameter and its value.
 * @param inputTableNames  Names of the tables containing data to be passed to
 *                         the proc. Each name specified must be the name of a
 *                         currently existing table. If no table names are
 *                         specified, no data will be passed to the proc.
 * @param inputColumnNames  Map of table names from @a inputTableNames to lists
 *                          of names of columns from those tables that will be
 *                          passed to the proc. Each column name specified must
 *                          be the name of an existing column in the
 *                          corresponding table. If a table name from @a
 *                          inputTableNames is not included, all columns from
 *                          that table will be passed to the proc.
 * @param outputTableNames  Names of the tables to which output data from the
 *                          proc will be written. If a specified table does not
 *                          exist, it will automatically be created with the
 *                          same schema as the corresponding table (by order)
 *                          from @a inputTableNames, excluding any primary and
 *                          shard keys. If a specified table is a
 *                          non-persistent result table, it must not have
 *                          primary or shard keys. If no table names are
 *                          specified, no output data can be returned from the
 *                          proc.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_proc_cache_input: A
 *                 comma-delimited list of table names from @a inputTableNames
 *                 from which input data will be cached for use in subsequent
 *                 calls to /execute/proc with the @a use_cached_input option.
 *                 Cached input data will be retained until the proc status is
 *                 cleared with the /show/proc/status option of
 *                 /show/proc/status and all proc instances using the cached
 *                 data have completed.  The default value is ''.
 *                         <li> gpudb::execute_proc_use_cached_input: A
 *                 comma-delimited list of run IDs (as returned from prior
 *                 calls to /execute/proc) of running or completed proc
 *                 instances from which input data cached using the @a
 *                 cache_input option will be used. Cached input data will not
 *                 be used for any tables specified in @a inputTableNames, but
 *                 data from all other tables cached for the specified run IDs
 *                 will be passed to the proc. If the same table was cached for
 *                 multiple specified run IDs, the cached data from the first
 *                 run ID specified in the list that includes that table will
 *                 be used.  The default value is ''.
 *                         <li> gpudb::execute_proc_kifs_input_dirs: A
 *                 comma-delimited list of KiFS directories whose local files
 *                 will be made directly accessible to the proc through the
 *                 API. (All KiFS files, local or not, are also accessible
 *                 through the file system below the KiFS mount point.) Each
 *                 name specified must the name of an existing KiFS directory.
 *                 The default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& GPUdb::executeProc( const std::string& procName,
                                         const std::map<std::string, std::string>& params,
                                         const std::map<std::string, std::vector<uint8_t> >& binParams,
                                         const std::vector<std::string>& inputTableNames,
                                         const std::map<std::string, std::vector<std::string> >& inputColumnNames,
                                         const std::vector<std::string>& outputTableNames,
                                         const std::map<std::string, std::string>& options,
                                         ExecuteProcResponse& response_ ) const
{
    ExecuteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.params = params;
    actualRequest_.binParams = binParams;
    actualRequest_.inputTableNames = inputTableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputTableNames = outputTableNames;
    actualRequest_.options = options;
    submitRequest("/execute/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * SQL Request
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawExecuteSqlResponse GPUdb::executeSqlRaw( const ExecuteSqlRequest& request_ ) const
{
    RawExecuteSqlResponse actualResponse_;
    submitRequest("/execute/sql", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * SQL Request
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawExecuteSqlResponse& GPUdb::executeSqlRaw( const ExecuteSqlRequest& request_,
                                             RawExecuteSqlResponse& response_ ) const
{
    submitRequest("/execute/sql", request_, response_, false);
    return response_;
}


/**
 * SQL Request
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteSqlResponse GPUdb::executeSql( const ExecuteSqlRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawExecuteSqlResponse actualResponse_;
    submitRequest("/execute/sql", request_, actualResponse_, false);
    ExecuteSqlResponse response_;
    response_.countAffected = actualResponse_.countAffected;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.pagingTable = actualResponse_.pagingTable;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * SQL Request
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteSqlResponse& GPUdb::executeSql( const ExecuteSqlRequest& request_,
                                       ExecuteSqlResponse& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawExecuteSqlResponse actualResponse_;
    submitRequest("/execute/sql", request_, actualResponse_, false);
    response_.countAffected = actualResponse_.countAffected;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.pagingTable = actualResponse_.pagingTable;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * SQL Request
 * 
 * @param statement  SQL statement (query, DML, or DDL) to be executed
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000), or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be returned.
 * @param requestSchemaStr  Avro schema of @a data.
 * @param data  An array of binary-encoded data for the records to be binded to
 *              the SQL query.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_sql_parallel_execution: If @a
 *                 false, disables the parallel step execution of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_cost_based_optimization: If
 *                 @a false, disables the cost-based optimization of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_plan_cache: If @a false,
 *                 disables plan caching for the given query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_rule_based_optimization: If
 *                 @a false, disables rule-based rewrite optimizations for the
 *                 given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_results_caching: If @a
 *                 false, disables caching of the results of the given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_paging_table: When empty or
 *                 the specified paging table not exists, the system will
 *                 create a paging table and return when query output has more
 *                 records than the user asked. If the paging table exists in
 *                 the system, the records from the paging table are returned
 *                 without evaluating the query.
 *                         <li> gpudb::execute_sql_paging_table_ttl: Sets the
 *                 <a href="../../concepts/ttl.html" target="_top">TTL</a> of
 *                 the paging table.
 *                         <li> gpudb::execute_sql_distributed_joins: If @a
 *                 true, enables the use of distributed joins in servicing the
 *                 given query.  Any query requiring a distributed join will
 *                 succeed, though hints can be used in the query to change the
 *                 distribution of the source data to allow the query to
 *                 succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_distributed_operations: If
 *                 @a true, enables the use of distributed operations in
 *                 servicing the given query.  Any query requiring a
 *                 distributed join will succeed, though hints can be used in
 *                 the query to change the distribution of the source data to
 *                 allow the query to succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_ssq_optimization: If @a
 *                 false, scalar subqueries will be translated into joins
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_late_materialization: If @a
 *                 true, Joins/Filters results  will always be materialized (
 *                 saved to result tables format)
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 intermediate result tables used in query execution.
 *                         <li> gpudb::execute_sql_update_on_existing_pk: Can
 *                 be used to customize behavior when the updated primary key
 *                 value already exists as described in /insert/records.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_preserve_dict_encoding: If
 *                 @a true, then columns that were dict encoded in the source
 *                 table will be dict encoded in the projection table.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_validate_change_column: When
 *                 changing a column using alter table, validate the change
 *                 before applying it. If @a true, then validate all values. A
 *                 value too large (or too long) for the new type will prevent
 *                 any change. If @a false, then when a value is too large or
 *                 long, it will be truncated.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true: true
 *                         <li> gpudb::execute_sql_false: false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_prepare_mode: If @a true,
 *                 compiles a query into an execution plan and saves it in
 *                 query cache. Query execution is not performed and an empty
 *                 response will be returned to user
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteSqlResponse GPUdb::executeSql( const std::string& statement,
                                      const int64_t offset,
                                      const int64_t limit,
                                      const std::string& requestSchemaStr,
                                      const std::vector<std::vector<uint8_t> >& data,
                                      const std::map<std::string, std::string>& options ) const
{
    ExecuteSqlRequest actualRequest_;
    actualRequest_.statement = statement;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.requestSchemaStr = requestSchemaStr;
    actualRequest_.data = data;
    actualRequest_.options = options;
    RawExecuteSqlResponse actualResponse_;
    submitRequest("/execute/sql", actualRequest_, actualResponse_, false);
    ExecuteSqlResponse response_;
    response_.countAffected = actualResponse_.countAffected;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.pagingTable = actualResponse_.pagingTable;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * SQL Request
 * 
 * @param statement  SQL statement (query, DML, or DDL) to be executed
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000), or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be returned.
 * @param requestSchemaStr  Avro schema of @a data.
 * @param data  An array of binary-encoded data for the records to be binded to
 *              the SQL query.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::execute_sql_parallel_execution: If @a
 *                 false, disables the parallel step execution of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_cost_based_optimization: If
 *                 @a false, disables the cost-based optimization of the given
 *                 query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_plan_cache: If @a false,
 *                 disables plan caching for the given query.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_rule_based_optimization: If
 *                 @a false, disables rule-based rewrite optimizations for the
 *                 given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_results_caching: If @a
 *                 false, disables caching of the results of the given query
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_paging_table: When empty or
 *                 the specified paging table not exists, the system will
 *                 create a paging table and return when query output has more
 *                 records than the user asked. If the paging table exists in
 *                 the system, the records from the paging table are returned
 *                 without evaluating the query.
 *                         <li> gpudb::execute_sql_paging_table_ttl: Sets the
 *                 <a href="../../concepts/ttl.html" target="_top">TTL</a> of
 *                 the paging table.
 *                         <li> gpudb::execute_sql_distributed_joins: If @a
 *                 true, enables the use of distributed joins in servicing the
 *                 given query.  Any query requiring a distributed join will
 *                 succeed, though hints can be used in the query to change the
 *                 distribution of the source data to allow the query to
 *                 succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_distributed_operations: If
 *                 @a true, enables the use of distributed operations in
 *                 servicing the given query.  Any query requiring a
 *                 distributed join will succeed, though hints can be used in
 *                 the query to change the distribution of the source data to
 *                 allow the query to succeed.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_ssq_optimization: If @a
 *                 false, scalar subqueries will be translated into joins
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_late_materialization: If @a
 *                 true, Joins/Filters results  will always be materialized (
 *                 saved to result tables format)
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 intermediate result tables used in query execution.
 *                         <li> gpudb::execute_sql_update_on_existing_pk: Can
 *                 be used to customize behavior when the updated primary key
 *                 value already exists as described in /insert/records.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                         <li> gpudb::execute_sql_preserve_dict_encoding: If
 *                 @a true, then columns that were dict encoded in the source
 *                 table will be dict encoded in the projection table.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_validate_change_column: When
 *                 changing a column using alter table, validate the change
 *                 before applying it. If @a true, then validate all values. A
 *                 value too large (or too long) for the new type will prevent
 *                 any change. If @a false, then when a value is too large or
 *                 long, it will be truncated.
 *                 <ul>
 *                         <li> gpudb::execute_sql_true: true
 *                         <li> gpudb::execute_sql_false: false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_true.
 *                         <li> gpudb::execute_sql_prepare_mode: If @a true,
 *                 compiles a query into an execution plan and saves it in
 *                 query cache. Query execution is not performed and an empty
 *                 response will be returned to user
 *                 <ul>
 *                         <li> gpudb::execute_sql_true
 *                         <li> gpudb::execute_sql_false
 *                 </ul>
 *                 The default value is gpudb::execute_sql_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteSqlResponse& GPUdb::executeSql( const std::string& statement,
                                       const int64_t offset,
                                       const int64_t limit,
                                       const std::string& requestSchemaStr,
                                       const std::vector<std::vector<uint8_t> >& data,
                                       const std::map<std::string, std::string>& options,
                                       ExecuteSqlResponse& response_ ) const
{
    ExecuteSqlRequest actualRequest_;
    actualRequest_.statement = statement;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.requestSchemaStr = requestSchemaStr;
    actualRequest_.data = data;
    actualRequest_.options = options;
    RawExecuteSqlResponse actualResponse_;
    submitRequest("/execute/sql", actualRequest_, actualResponse_, false);
    response_.countAffected = actualResponse_.countAffected;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.pagingTable = actualResponse_.pagingTable;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * <a href="../../concepts/filtered_views.html" target="_top">result set</a>
 * with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/expressions.html"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse GPUdb::filter( const FilterRequest& request_ ) const
{
    FilterResponse actualResponse_;
    submitRequest("/filter", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * <a href="../../concepts/filtered_views.html" target="_top">result set</a>
 * with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/expressions.html"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& GPUdb::filter( const FilterRequest& request_,
                               FilterResponse& response_ ) const
{
    submitRequest("/filter", request_, response_, false);
    return response_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * <a href="../../concepts/filtered_views.html" target="_top">result set</a>
 * with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/expressions.html"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param expression  The select expression to filter the specified table.  For
 *                    details see <a href="../../concepts/expressions.html"
 *                    target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                         <li> gpudb::filter_view_id: view this filtered-view
 *                 is part of.  The default value is ''.
 *                         <li> gpudb::filter_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 view specified in @a viewName.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse GPUdb::filter( const std::string& tableName,
                              const std::string& viewName,
                              const std::string& expression,
                              const std::map<std::string, std::string>& options ) const
{
    FilterRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.options = options;
    FilterResponse actualResponse_;
    submitRequest("/filter", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * <a href="../../concepts/filtered_views.html" target="_top">result set</a>
 * with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/expressions.html"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param expression  The select expression to filter the specified table.  For
 *                    details see <a href="../../concepts/expressions.html"
 *                    target="_top">Expressions</a>.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                         <li> gpudb::filter_view_id: view this filtered-view
 *                 is part of.  The default value is ''.
 *                         <li> gpudb::filter_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 view specified in @a viewName.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& GPUdb::filter( const std::string& tableName,
                               const std::string& viewName,
                               const std::string& expression,
                               const std::map<std::string, std::string>& options,
                               FilterResponse& response_ ) const
{
    FilterRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.options = options;
    submitRequest("/filter", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous, meaning that a response will
 * not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse GPUdb::filterByArea( const FilterByAreaRequest& request_ ) const
{
    FilterByAreaResponse actualResponse_;
    submitRequest("/filter/byarea", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous, meaning that a response will
 * not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& GPUdb::filterByArea( const FilterByAreaRequest& request_,
                                           FilterByAreaResponse& response_ ) const
{
    submitRequest("/filter/byarea", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous, meaning that a response will
 * not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created.  If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse GPUdb::filterByArea( const std::string& tableName,
                                          const std::string& viewName,
                                          const std::string& xColumnName,
                                          const std::vector<double>& xVector,
                                          const std::string& yColumnName,
                                          const std::vector<double>& yVector,
                                          const std::map<std::string, std::string>& options ) const
{
    FilterByAreaRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    FilterByAreaResponse actualResponse_;
    submitRequest("/filter/byarea", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous, meaning that a response will
 * not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created.  If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& GPUdb::filterByArea( const std::string& tableName,
                                           const std::string& viewName,
                                           const std::string& xColumnName,
                                           const std::vector<double>& xVector,
                                           const std::string& yColumnName,
                                           const std::vector<double>& yVector,
                                           const std::map<std::string, std::string>& options,
                                           FilterByAreaResponse& response_ ) const
{
    FilterByAreaRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    submitRequest("/filter/byarea", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a named
 * area of interest (NAI/polygon). The operation is synchronous, meaning that a
 * response will not be returned until all the matching objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input NAI restriction
 * specification is created with the name @a viewName passed in as part of the
 * input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaGeometryResponse GPUdb::filterByAreaGeometry( const FilterByAreaGeometryRequest& request_ ) const
{
    FilterByAreaGeometryResponse actualResponse_;
    submitRequest("/filter/byarea/geometry", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a named
 * area of interest (NAI/polygon). The operation is synchronous, meaning that a
 * response will not be returned until all the matching objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input NAI restriction
 * specification is created with the name @a viewName passed in as part of the
 * input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaGeometryResponse& GPUdb::filterByAreaGeometry( const FilterByAreaGeometryRequest& request_,
                                                           FilterByAreaGeometryResponse& response_ ) const
{
    submitRequest("/filter/byarea/geometry", request_, response_, false);
    return response_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a named
 * area of interest (NAI/polygon). The operation is synchronous, meaning that a
 * response will not be returned until all the matching objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input NAI restriction
 * specification is created with the name @a viewName passed in as part of the
 * input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_geometry_collection_name:
 *                 Name of a collection which is to contain the newly created
 *                 view. If the collection provided is non-existent, the
 *                 collection will be automatically created. If empty, then the
 *                 newly created view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaGeometryResponse GPUdb::filterByAreaGeometry( const std::string& tableName,
                                                          const std::string& viewName,
                                                          const std::string& columnName,
                                                          const std::vector<double>& xVector,
                                                          const std::vector<double>& yVector,
                                                          const std::map<std::string, std::string>& options ) const
{
    FilterByAreaGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    FilterByAreaGeometryResponse actualResponse_;
    submitRequest("/filter/byarea/geometry", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a named
 * area of interest (NAI/polygon). The operation is synchronous, meaning that a
 * response will not be returned until all the matching objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input NAI restriction
 * specification is created with the name @a viewName passed in as part of the
 * input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_area_geometry_collection_name:
 *                 Name of a collection which is to contain the newly created
 *                 view. If the collection provided is non-existent, the
 *                 collection will be automatically created. If empty, then the
 *                 newly created view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaGeometryResponse& GPUdb::filterByAreaGeometry( const std::string& tableName,
                                                           const std::string& viewName,
                                                           const std::string& columnName,
                                                           const std::vector<double>& xVector,
                                                           const std::vector<double>& yVector,
                                                           const std::map<std::string, std::string>& options,
                                                           FilterByAreaGeometryResponse& response_ ) const
{
    FilterByAreaGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    submitRequest("/filter/byarea/geometry", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse GPUdb::filterByBox( const FilterByBoxRequest& request_ ) const
{
    FilterByBoxResponse actualResponse_;
    submitRequest("/filter/bybox", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& GPUdb::filterByBox( const FilterByBoxRequest& request_,
                                         FilterByBoxResponse& response_ ) const
{
    submitRequest("/filter/bybox", request_, response_, false);
    return response_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be an existing table.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Has the same naming
 *                  restrictions as <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse GPUdb::filterByBox( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& xColumnName,
                                        const double minX,
                                        const double maxX,
                                        const std::string& yColumnName,
                                        const double minY,
                                        const double maxY,
                                        const std::map<std::string, std::string>& options ) const
{
    FilterByBoxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.options = options;
    FilterByBoxResponse actualResponse_;
    submitRequest("/filter/bybox", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be an existing table.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Has the same naming
 *                  restrictions as <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. Must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& GPUdb::filterByBox( const std::string& tableName,
                                         const std::string& viewName,
                                         const std::string& xColumnName,
                                         const double minX,
                                         const double maxX,
                                         const std::string& yColumnName,
                                         const double minY,
                                         const double maxY,
                                         const std::map<std::string, std::string>& options,
                                         FilterByBoxResponse& response_ ) const
{
    FilterByBoxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.options = options;
    submitRequest("/filter/bybox", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set which
 * satisfies the input NAI restriction specification is also created when a @a
 * viewName is passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxGeometryResponse GPUdb::filterByBoxGeometry( const FilterByBoxGeometryRequest& request_ ) const
{
    FilterByBoxGeometryResponse actualResponse_;
    submitRequest("/filter/bybox/geometry", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set which
 * satisfies the input NAI restriction specification is also created when a @a
 * viewName is passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxGeometryResponse& GPUdb::filterByBoxGeometry( const FilterByBoxGeometryRequest& request_,
                                                         FilterByBoxGeometryResponse& response_ ) const
{
    submitRequest("/filter/bybox/geometry", request_, response_, false);
    return response_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set which
 * satisfies the input NAI restriction specification is also created when a @a
 * viewName is passed in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be an existing table.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Must not be an already
 *                  existing collection, table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param minX  Lower bound for the x-coordinate of the rectangular box.  Must
 *              be less than or equal to @a maxX.
 * @param maxX  Upper bound for the x-coordinate of the rectangular box.  Must
 *              be greater than or equal to @a minX.
 * @param minY  Lower bound for the y-coordinate of the rectangular box. Must
 *              be less than or equal to @a maxY.
 * @param maxY  Upper bound for the y-coordinate of the rectangular box. Must
 *              be greater than or equal to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_geometry_collection_name:
 *                 Name of a collection which is to contain the newly created
 *                 view. If the collection provided is non-existent, the
 *                 collection will be automatically created. If empty, then the
 *                 newly created view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxGeometryResponse GPUdb::filterByBoxGeometry( const std::string& tableName,
                                                        const std::string& viewName,
                                                        const std::string& columnName,
                                                        const double minX,
                                                        const double maxX,
                                                        const double minY,
                                                        const double maxY,
                                                        const std::map<std::string, std::string>& options ) const
{
    FilterByBoxGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.options = options;
    FilterByBoxGeometryResponse actualResponse_;
    submitRequest("/filter/bybox/geometry", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set which
 * satisfies the input NAI restriction specification is also created when a @a
 * viewName is passed in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be an existing table.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Must not be an already
 *                  existing collection, table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param minX  Lower bound for the x-coordinate of the rectangular box.  Must
 *              be less than or equal to @a maxX.
 * @param maxX  Upper bound for the x-coordinate of the rectangular box.  Must
 *              be greater than or equal to @a minX.
 * @param minY  Lower bound for the y-coordinate of the rectangular box. Must
 *              be less than or equal to @a maxY.
 * @param maxY  Upper bound for the y-coordinate of the rectangular box. Must
 *              be greater than or equal to @a minY.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_box_geometry_collection_name:
 *                 Name of a collection which is to contain the newly created
 *                 view. If the collection provided is non-existent, the
 *                 collection will be automatically created. If empty, then the
 *                 newly created view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxGeometryResponse& GPUdb::filterByBoxGeometry( const std::string& tableName,
                                                         const std::string& viewName,
                                                         const std::string& columnName,
                                                         const double minX,
                                                         const double maxX,
                                                         const double minY,
                                                         const double maxY,
                                                         const std::map<std::string, std::string>& options,
                                                         FilterByBoxGeometryResponse& response_ ) const
{
    FilterByBoxGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.options = options;
    submitRequest("/filter/bybox/geometry", actualRequest_, response_, false);
    return response_;
}


/**
 * Applies a geometry filter against a geospatial geometry column in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse GPUdb::filterByGeometry( const FilterByGeometryRequest& request_ ) const
{
    FilterByGeometryResponse actualResponse_;
    submitRequest("/filter/bygeometry", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Applies a geometry filter against a geospatial geometry column in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& GPUdb::filterByGeometry( const FilterByGeometryRequest& request_,
                                                   FilterByGeometryResponse& response_ ) const
{
    submitRequest("/filter/bygeometry", request_, response_, false);
    return response_;
}


/**
 * Applies a geometry filter against a geospatial geometry column in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by geometry will be
 *                   performed.  Must be an existing table, collection or view
 *                   containing a geospatial geometry column.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnName  Name of the column to be used in the filter. Must be a
 *                    geospatial geometry column.
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName.
 * @param operation  The geometric filtering operation to perform
 *                   <ul>
 *                           <li> gpudb::filter_by_geometry_contains: Matches
 *                   records that contain the given WKT in @a inputWkt, i.e.
 *                   the given WKT is within the bounds of a record's geometry.
 *                           <li> gpudb::filter_by_geometry_crosses: Matches
 *                   records that cross the given WKT.
 *                           <li> gpudb::filter_by_geometry_disjoint: Matches
 *                   records that are disjoint from the given WKT.
 *                           <li> gpudb::filter_by_geometry_equals: Matches
 *                   records that are the same as the given WKT.
 *                           <li> gpudb::filter_by_geometry_intersects: Matches
 *                   records that intersect the given WKT.
 *                           <li> gpudb::filter_by_geometry_overlaps: Matches
 *                   records that overlap the given WKT.
 *                           <li> gpudb::filter_by_geometry_touches: Matches
 *                   records that touch the given WKT.
 *                           <li> gpudb::filter_by_geometry_within: Matches
 *                   records that are within the given WKT.
 *                   </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_geometry_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse GPUdb::filterByGeometry( const std::string& tableName,
                                                  const std::string& viewName,
                                                  const std::string& columnName,
                                                  const std::string& inputWkt,
                                                  const std::string& operation,
                                                  const std::map<std::string, std::string>& options ) const
{
    FilterByGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.inputWkt = inputWkt;
    actualRequest_.operation = operation;
    actualRequest_.options = options;
    FilterByGeometryResponse actualResponse_;
    submitRequest("/filter/bygeometry", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Applies a geometry filter against a geospatial geometry column in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by geometry will be
 *                   performed.  Must be an existing table, collection or view
 *                   containing a geospatial geometry column.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnName  Name of the column to be used in the filter. Must be a
 *                    geospatial geometry column.
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName.
 * @param operation  The geometric filtering operation to perform
 *                   <ul>
 *                           <li> gpudb::filter_by_geometry_contains: Matches
 *                   records that contain the given WKT in @a inputWkt, i.e.
 *                   the given WKT is within the bounds of a record's geometry.
 *                           <li> gpudb::filter_by_geometry_crosses: Matches
 *                   records that cross the given WKT.
 *                           <li> gpudb::filter_by_geometry_disjoint: Matches
 *                   records that are disjoint from the given WKT.
 *                           <li> gpudb::filter_by_geometry_equals: Matches
 *                   records that are the same as the given WKT.
 *                           <li> gpudb::filter_by_geometry_intersects: Matches
 *                   records that intersect the given WKT.
 *                           <li> gpudb::filter_by_geometry_overlaps: Matches
 *                   records that overlap the given WKT.
 *                           <li> gpudb::filter_by_geometry_touches: Matches
 *                   records that touch the given WKT.
 *                           <li> gpudb::filter_by_geometry_within: Matches
 *                   records that are within the given WKT.
 *                   </ul>
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_geometry_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& GPUdb::filterByGeometry( const std::string& tableName,
                                                   const std::string& viewName,
                                                   const std::string& columnName,
                                                   const std::string& inputWkt,
                                                   const std::string& operation,
                                                   const std::map<std::string, std::string>& options,
                                                   FilterByGeometryResponse& response_ ) const
{
    FilterByGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.inputWkt = inputWkt;
    actualRequest_.operation = operation;
    actualRequest_.options = options;
    submitRequest("/filter/bygeometry", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous, meaning that a response
 * will not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set (view)
 * which satisfies the input filter specification is also created if a @a
 * viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * both in the respective x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x =
 * 2.3 and y = -31.5", etc. However, a record with "x = 10.1 and y = -31.5" or
 * "x = 2.3 and y = 0.0" would not be returned because the values in the given
 * lists do not correspond.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse GPUdb::filterByList( const FilterByListRequest& request_ ) const
{
    FilterByListResponse actualResponse_;
    submitRequest("/filter/bylist", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous, meaning that a response
 * will not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set (view)
 * which satisfies the input filter specification is also created if a @a
 * viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * both in the respective x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x =
 * 2.3 and y = -31.5", etc. However, a record with "x = 10.1 and y = -31.5" or
 * "x = 2.3 and y = 0.0" would not be returned because the values in the given
 * lists do not correspond.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& GPUdb::filterByList( const FilterByListRequest& request_,
                                           FilterByListResponse& response_ ) const
{
    submitRequest("/filter/bylist", request_, response_, false);
    return response_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous, meaning that a response
 * will not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set (view)
 * which satisfies the input filter specification is also created if a @a
 * viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * both in the respective x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x =
 * 2.3 and y = -31.5", etc. However, a record with "x = 10.1 and y = -31.5" or
 * "x = 2.3 and y = 0.0" would not be returned because the values in the given
 * lists do not correspond.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                         <li> gpudb::filter_by_list_filter_mode: String
 *                 indicating the filter mode, either 'in_list' or
 *                 'not_in_list'.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_in_list: The filter will
 *                 match all items that are in the provided list(s).
 *                         <li> gpudb::filter_by_list_not_in_list: The filter
 *                 will match all items that are not in the provided list(s).
 *                 </ul>
 *                 The default value is gpudb::filter_by_list_in_list.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse GPUdb::filterByList( const std::string& tableName,
                                          const std::string& viewName,
                                          const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                          const std::map<std::string, std::string>& options ) const
{
    FilterByListRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnValuesMap = columnValuesMap;
    actualRequest_.options = options;
    FilterByListResponse actualResponse_;
    submitRequest("/filter/bylist", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous, meaning that a response
 * will not be returned until all the objects are fully available. The response
 * payload provides the count of the resulting set. A new resultant set (view)
 * which satisfies the input filter specification is also created if a @a
 * viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * both in the respective x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x =
 * 2.3 and y = -31.5", etc. However, a record with "x = 10.1 and y = -31.5" or
 * "x = 2.3 and y = 0.0" would not be returned because the values in the given
 * lists do not correspond.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table, or a view (when chaining queries).
 *                   If filtering a collection, all child tables where the
 *                   filter expression is valid will be filtered; the filtered
 *                   result tables will then be placed in a collection
 *                   specified by @a viewName.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                         <li> gpudb::filter_by_list_filter_mode: String
 *                 indicating the filter mode, either 'in_list' or
 *                 'not_in_list'.
 *                 <ul>
 *                         <li> gpudb::filter_by_list_in_list: The filter will
 *                 match all items that are in the provided list(s).
 *                         <li> gpudb::filter_by_list_not_in_list: The filter
 *                 will match all items that are not in the provided list(s).
 *                 </ul>
 *                 The default value is gpudb::filter_by_list_in_list.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& GPUdb::filterByList( const std::string& tableName,
                                           const std::string& viewName,
                                           const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                           const std::map<std::string, std::string>& options,
                                           FilterByListResponse& response_ ) const
{
    FilterByListRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnValuesMap = columnValuesMap;
    actualRequest_.options = options;
    submitRequest("/filter/bylist", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of the
 * request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse GPUdb::filterByRadius( const FilterByRadiusRequest& request_ ) const
{
    FilterByRadiusResponse actualResponse_;
    submitRequest("/filter/byradius", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of the
 * request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& GPUdb::filterByRadius( const FilterByRadiusRequest& request_,
                                               FilterByRadiusResponse& response_ ) const
{
    submitRequest("/filter/byradius", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of the
 * request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse GPUdb::filterByRadius( const std::string& tableName,
                                              const std::string& viewName,
                                              const std::string& xColumnName,
                                              const double xCenter,
                                              const std::string& yColumnName,
                                              const double yCenter,
                                              const double radius,
                                              const std::map<std::string, std::string>& options ) const
{
    FilterByRadiusRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xCenter = xCenter;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yCenter = yCenter;
    actualRequest_.radius = radius;
    actualRequest_.options = options;
    FilterByRadiusResponse actualResponse_;
    submitRequest("/filter/byradius", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a @a viewName is passed in as part of the
 * request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_radius_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& GPUdb::filterByRadius( const std::string& tableName,
                                               const std::string& viewName,
                                               const std::string& xColumnName,
                                               const double xCenter,
                                               const std::string& yColumnName,
                                               const double yCenter,
                                               const double radius,
                                               const std::map<std::string, std::string>& options,
                                               FilterByRadiusResponse& response_ ) const
{
    FilterByRadiusRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xCenter = xCenter;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yCenter = yCenter;
    actualRequest_.radius = radius;
    actualRequest_.options = options;
    submitRequest("/filter/byradius", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a circle
 * with the given radius and center point (i.e. circular NAI). The operation is
 * synchronous, meaning that a response will not be returned until all the
 * objects are fully available. The response payload provides the count of the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusGeometryResponse GPUdb::filterByRadiusGeometry( const FilterByRadiusGeometryRequest& request_ ) const
{
    FilterByRadiusGeometryResponse actualResponse_;
    submitRequest("/filter/byradius/geometry", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a circle
 * with the given radius and center point (i.e. circular NAI). The operation is
 * synchronous, meaning that a response will not be returned until all the
 * objects are fully available. The response payload provides the count of the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusGeometryResponse& GPUdb::filterByRadiusGeometry( const FilterByRadiusGeometryRequest& request_,
                                                               FilterByRadiusGeometryResponse& response_ ) const
{
    submitRequest("/filter/byradius/geometry", request_, response_, false);
    return response_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a circle
 * with the given radius and center point (i.e. circular NAI). The operation is
 * synchronous, meaning that a response will not be returned until all the
 * objects are fully available. The response payload provides the count of the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_radius_geometry_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusGeometryResponse GPUdb::filterByRadiusGeometry( const std::string& tableName,
                                                              const std::string& viewName,
                                                              const std::string& columnName,
                                                              const double xCenter,
                                                              const double yCenter,
                                                              const double radius,
                                                              const std::map<std::string, std::string>& options ) const
{
    FilterByRadiusGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.xCenter = xCenter;
    actualRequest_.yCenter = yCenter;
    actualRequest_.radius = radius;
    actualRequest_.options = options;
    FilterByRadiusGeometryResponse actualResponse_;
    submitRequest("/filter/byradius/geometry", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which geospatial geometry objects from a table intersect a circle
 * with the given radius and center point (i.e. circular NAI). The operation is
 * synchronous, meaning that a response will not be returned until all the
 * objects are fully available. The response payload provides the count of the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI restriction specification is also created if a @a viewName is passed in
 * as part of the request.
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.
 * @param columnName  Name of the geospatial geometry column to be filtered.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::filter_by_radius_geometry_collection_name: Name of a
 *                 collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusGeometryResponse& GPUdb::filterByRadiusGeometry( const std::string& tableName,
                                                               const std::string& viewName,
                                                               const std::string& columnName,
                                                               const double xCenter,
                                                               const double yCenter,
                                                               const double radius,
                                                               const std::map<std::string, std::string>& options,
                                                               FilterByRadiusGeometryResponse& response_ ) const
{
    FilterByRadiusGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.xCenter = xCenter;
    actualRequest_.yCenter = yCenter;
    actualRequest_.radius = radius;
    actualRequest_.options = options;
    submitRequest("/filter/byradius/geometry", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse GPUdb::filterByRange( const FilterByRangeRequest& request_ ) const
{
    FilterByRangeResponse actualResponse_;
    submitRequest("/filter/byrange", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& GPUdb::filterByRange( const FilterByRangeRequest& request_,
                                             FilterByRangeResponse& response_ ) const
{
    submitRequest("/filter/byrange", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed.  Must be an existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnName  Name of a column on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_range_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse GPUdb::filterByRange( const std::string& tableName,
                                            const std::string& viewName,
                                            const std::string& columnName,
                                            const double lowerBound,
                                            const double upperBound,
                                            const std::map<std::string, std::string>& options ) const
{
    FilterByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.lowerBound = lowerBound;
    actualRequest_.upperBound = upperBound;
    actualRequest_.options = options;
    FilterByRangeResponse actualResponse_;
    submitRequest("/filter/byrange", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed.  Must be an existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnName  Name of a column on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_range_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& GPUdb::filterByRange( const std::string& tableName,
                                             const std::string& viewName,
                                             const std::string& columnName,
                                             const double lowerBound,
                                             const double upperBound,
                                             const std::map<std::string, std::string>& options,
                                             FilterByRangeResponse& response_ ) const
{
    FilterByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.lowerBound = lowerBound;
    actualRequest_.upperBound = upperBound;
    actualRequest_.options = options;
    submitRequest("/filter/byrange", actualRequest_, response_, false);
    return response_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse GPUdb::filterBySeries( const FilterBySeriesRequest& request_ ) const
{
    FilterBySeriesResponse actualResponse_;
    submitRequest("/filter/byseries", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& GPUdb::filterBySeries( const FilterBySeriesRequest& request_,
                                               FilterBySeriesResponse& response_ ) const
{
    submitRequest("/filter/byseries", request_, response_, false);
    return response_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed. Must be a currently existing table with
 *                   a <a href="../../geospatial/geo_objects.html"
 *                   target="_top">track</a> present.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                         <li> gpudb::filter_by_series_spatial_radius: A
 *                 positive number passed as a string representing the radius
 *                 of the search area centered around each track point's
 *                 geospatial coordinates. The value is interpreted in meters.
 *                 Required parameter.
 *                         <li> gpudb::filter_by_series_time_radius: A positive
 *                 number passed as a string representing the maximum allowable
 *                 time difference between the timestamps of a filtered object
 *                 and the given track's points. The value is interpreted in
 *                 seconds. Required parameter.
 *                         <li>
 *                 gpudb::filter_by_series_spatial_distance_metric: A string
 *                 representing the coordinate system to use for the spatial
 *                 search criteria. Acceptable values are 'euclidean' and
 *                 'great_circle'. Optional parameter; default is 'euclidean'.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_euclidean
 *                         <li> gpudb::filter_by_series_great_circle
 *                 </ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse GPUdb::filterBySeries( const std::string& tableName,
                                              const std::string& viewName,
                                              const std::string& trackId,
                                              const std::vector<std::string>& targetTrackIds,
                                              const std::map<std::string, std::string>& options ) const
{
    FilterBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.trackId = trackId;
    actualRequest_.targetTrackIds = targetTrackIds;
    actualRequest_.options = options;
    FilterBySeriesResponse actualResponse_;
    submitRequest("/filter/byseries", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed. Must be a currently existing table with
 *                   a <a href="../../geospatial/geo_objects.html"
 *                   target="_top">track</a> present.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                         <li> gpudb::filter_by_series_spatial_radius: A
 *                 positive number passed as a string representing the radius
 *                 of the search area centered around each track point's
 *                 geospatial coordinates. The value is interpreted in meters.
 *                 Required parameter.
 *                         <li> gpudb::filter_by_series_time_radius: A positive
 *                 number passed as a string representing the maximum allowable
 *                 time difference between the timestamps of a filtered object
 *                 and the given track's points. The value is interpreted in
 *                 seconds. Required parameter.
 *                         <li>
 *                 gpudb::filter_by_series_spatial_distance_metric: A string
 *                 representing the coordinate system to use for the spatial
 *                 search criteria. Acceptable values are 'euclidean' and
 *                 'great_circle'. Optional parameter; default is 'euclidean'.
 *                 <ul>
 *                         <li> gpudb::filter_by_series_euclidean
 *                         <li> gpudb::filter_by_series_great_circle
 *                 </ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& GPUdb::filterBySeries( const std::string& tableName,
                                               const std::string& viewName,
                                               const std::string& trackId,
                                               const std::vector<std::string>& targetTrackIds,
                                               const std::map<std::string, std::string>& options,
                                               FilterBySeriesResponse& response_ ) const
{
    FilterBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.trackId = trackId;
    actualRequest_.targetTrackIds = targetTrackIds;
    actualRequest_.options = options;
    submitRequest("/filter/byseries", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The options 'case_sensitive' can be
 * used to modify the behavior for all modes except 'search'. For 'search' mode
 * details and limitations, see <a href="../../concepts/full_text_search.html"
 * target="_top">Full Text Search</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse GPUdb::filterByString( const FilterByStringRequest& request_ ) const
{
    FilterByStringResponse actualResponse_;
    submitRequest("/filter/bystring", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The options 'case_sensitive' can be
 * used to modify the behavior for all modes except 'search'. For 'search' mode
 * details and limitations, see <a href="../../concepts/full_text_search.html"
 * target="_top">Full Text Search</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& GPUdb::filterByString( const FilterByStringRequest& request_,
                                               FilterByStringResponse& response_ ) const
{
    submitRequest("/filter/bystring", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The options 'case_sensitive' can be
 * used to modify the behavior for all modes except 'search'. For 'search' mode
 * details and limitations, see <a href="../../concepts/full_text_search.html"
 * target="_top">Full Text Search</a>.
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed.  Must be an existing table, collection or view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See below for details.
 *              <ul>
 *                      <li> gpudb::filter_by_string_search: Full text search
 *              query with wildcards and boolean operators. Note that for this
 *              mode, no column can be specified in @a columnNames; all string
 *              columns of the table that have text search enabled will be
 *              searched.
 *                      <li> gpudb::filter_by_string_equals: Exact whole-string
 *              match (accelerated).
 *                      <li> gpudb::filter_by_string_contains: Partial
 *              substring match (not accelerated).  If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *                      <li> gpudb::filter_by_string_starts_with: Strings that
 *              start with the given expression (not accelerated). If the
 *              column is a string type (non-charN) and the number of records
 *              is too large, it will return 0.
 *                      <li> gpudb::filter_by_string_regex: Full regular
 *              expression search (not accelerated). If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *              </ul>
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for 'search' mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                         <li> gpudb::filter_by_string_case_sensitive: If
 *                 'false' then string filtering will ignore case. Does not
 *                 apply to 'search' mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_true
 *                         <li> gpudb::filter_by_string_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_string_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse GPUdb::filterByString( const std::string& tableName,
                                              const std::string& viewName,
                                              const std::string& expression,
                                              const std::string& mode,
                                              const std::vector<std::string>& columnNames,
                                              const std::map<std::string, std::string>& options ) const
{
    FilterByStringRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.mode = mode;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    FilterByStringResponse actualResponse_;
    submitRequest("/filter/bystring", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The options 'case_sensitive' can be
 * used to modify the behavior for all modes except 'search'. For 'search' mode
 * details and limitations, see <a href="../../concepts/full_text_search.html"
 * target="_top">Full Text Search</a>.
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed.  Must be an existing table, collection or view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See below for details.
 *              <ul>
 *                      <li> gpudb::filter_by_string_search: Full text search
 *              query with wildcards and boolean operators. Note that for this
 *              mode, no column can be specified in @a columnNames; all string
 *              columns of the table that have text search enabled will be
 *              searched.
 *                      <li> gpudb::filter_by_string_equals: Exact whole-string
 *              match (accelerated).
 *                      <li> gpudb::filter_by_string_contains: Partial
 *              substring match (not accelerated).  If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *                      <li> gpudb::filter_by_string_starts_with: Strings that
 *              start with the given expression (not accelerated). If the
 *              column is a string type (non-charN) and the number of records
 *              is too large, it will return 0.
 *                      <li> gpudb::filter_by_string_regex: Full regular
 *              expression search (not accelerated). If the column is a string
 *              type (non-charN) and the number of records is too large, it
 *              will return 0.
 *              </ul>
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for 'search' mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_collection_name: Name
 *                 of a collection which is to contain the newly created view.
 *                 If the collection provided is non-existent, the collection
 *                 will be automatically created. If empty, then the newly
 *                 created view will be top-level.
 *                         <li> gpudb::filter_by_string_case_sensitive: If
 *                 'false' then string filtering will ignore case. Does not
 *                 apply to 'search' mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_string_true
 *                         <li> gpudb::filter_by_string_false
 *                 </ul>
 *                 The default value is gpudb::filter_by_string_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& GPUdb::filterByString( const std::string& tableName,
                                               const std::string& viewName,
                                               const std::string& expression,
                                               const std::string& mode,
                                               const std::vector<std::string>& columnNames,
                                               const std::map<std::string, std::string>& options,
                                               FilterByStringResponse& response_ ) const
{
    FilterByStringRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.mode = mode;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    submitRequest("/filter/bystring", actualRequest_, response_, false);
    return response_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will not be returned until all objects are fully available in the result
 * view. The return value contains the count (i.e. the size) of the resulting
 * view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse GPUdb::filterByTable( const FilterByTableRequest& request_ ) const
{
    FilterByTableResponse actualResponse_;
    submitRequest("/filter/bytable", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will not be returned until all objects are fully available in the result
 * view. The return value contains the count (i.e. the size) of the resulting
 * view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& GPUdb::filterByTable( const FilterByTableRequest& request_,
                                             FilterByTableResponse& response_ ) const
{
    submitRequest("/filter/bytable", request_, response_, false);
    return response_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will not be returned until all objects are fully available in the result
 * view. The return value contains the count (i.e. the size) of the resulting
 * view.
 * 
 * @param tableName  Name of the table whose data will be filtered. Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName. Must be an
 *                         existing table.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must be a geospatial
 *                               geometry column if in 'spatial' mode;
 *                               otherwise, Must match the type of the @a
 *                               columnName.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                         <li> gpudb::filter_by_table_filter_mode: String
 *                 indicating the filter mode, either @a in_table or @a
 *                 not_in_table.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_in_table
 *                         <li> gpudb::filter_by_table_not_in_table
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_in_table.
 *                         <li> gpudb::filter_by_table_mode: Mode - should be
 *                 either @a spatial or @a normal.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_spatial
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_buffer: Buffer size, in
 *                 meters. Only relevant for @a spatial mode.  The default
 *                 value is '0'.
 *                         <li> gpudb::filter_by_table_buffer_method: Method
 *                 used to buffer polygons.  Only relevant for @a spatial mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_geos: Use geos 1 edge
 *                 per corner algorithm
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_max_partition_size:
 *                 Maximum number of points in a partition. Only relevant for
 *                 @a spatial mode.  The default value is '0'.
 *                         <li> gpudb::filter_by_table_max_partition_score:
 *                 Maximum number of points * edges in a partition. Only
 *                 relevant for @a spatial mode.  The default value is
 *                 '8000000'.
 *                         <li> gpudb::filter_by_table_x_column_name: Name of
 *                 column containing x value of point being filtered in @a
 *                 spatial mode.  The default value is 'x'.
 *                         <li> gpudb::filter_by_table_y_column_name: Name of
 *                 column containing y value of point being filtered in @a
 *                 spatial mode.  The default value is 'y'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse GPUdb::filterByTable( const std::string& tableName,
                                            const std::string& viewName,
                                            const std::string& columnName,
                                            const std::string& sourceTableName,
                                            const std::string& sourceTableColumnName,
                                            const std::map<std::string, std::string>& options ) const
{
    FilterByTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.sourceTableName = sourceTableName;
    actualRequest_.sourceTableColumnName = sourceTableColumnName;
    actualRequest_.options = options;
    FilterByTableResponse actualResponse_;
    submitRequest("/filter/bytable", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will not be returned until all objects are fully available in the result
 * view. The return value contains the count (i.e. the size) of the resulting
 * view.
 * 
 * @param tableName  Name of the table whose data will be filtered. Must be an
 *                   existing table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName. Must be an
 *                         existing table.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must be a geospatial
 *                               geometry column if in 'spatial' mode;
 *                               otherwise, Must match the type of the @a
 *                               columnName.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                         <li> gpudb::filter_by_table_filter_mode: String
 *                 indicating the filter mode, either @a in_table or @a
 *                 not_in_table.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_in_table
 *                         <li> gpudb::filter_by_table_not_in_table
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_in_table.
 *                         <li> gpudb::filter_by_table_mode: Mode - should be
 *                 either @a spatial or @a normal.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_spatial
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_buffer: Buffer size, in
 *                 meters. Only relevant for @a spatial mode.  The default
 *                 value is '0'.
 *                         <li> gpudb::filter_by_table_buffer_method: Method
 *                 used to buffer polygons.  Only relevant for @a spatial mode.
 *                 <ul>
 *                         <li> gpudb::filter_by_table_normal
 *                         <li> gpudb::filter_by_table_geos: Use geos 1 edge
 *                 per corner algorithm
 *                 </ul>
 *                 The default value is gpudb::filter_by_table_normal.
 *                         <li> gpudb::filter_by_table_max_partition_size:
 *                 Maximum number of points in a partition. Only relevant for
 *                 @a spatial mode.  The default value is '0'.
 *                         <li> gpudb::filter_by_table_max_partition_score:
 *                 Maximum number of points * edges in a partition. Only
 *                 relevant for @a spatial mode.  The default value is
 *                 '8000000'.
 *                         <li> gpudb::filter_by_table_x_column_name: Name of
 *                 column containing x value of point being filtered in @a
 *                 spatial mode.  The default value is 'x'.
 *                         <li> gpudb::filter_by_table_y_column_name: Name of
 *                 column containing y value of point being filtered in @a
 *                 spatial mode.  The default value is 'y'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& GPUdb::filterByTable( const std::string& tableName,
                                             const std::string& viewName,
                                             const std::string& columnName,
                                             const std::string& sourceTableName,
                                             const std::string& sourceTableColumnName,
                                             const std::map<std::string, std::string>& options,
                                             FilterByTableResponse& response_ ) const
{
    FilterByTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.sourceTableName = sourceTableName;
    actualRequest_.sourceTableColumnName = sourceTableColumnName;
    actualRequest_.options = options;
    submitRequest("/filter/bytable", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse GPUdb::filterByValue( const FilterByValueRequest& request_ ) const
{
    FilterByValueResponse actualResponse_;
    submitRequest("/filter/byvalue", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& GPUdb::filterByValue( const FilterByValueRequest& request_,
                                             FilterByValueResponse& response_ ) const
{
    submitRequest("/filter/byvalue", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * 
 * @param tableName  Name of an existing table on which to perform the
 *                   calculation.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.
 * @param valueStr  The string value to search for.
 * @param columnName  Name of a column on which the filter by value would be
 *                    applied.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_value_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse GPUdb::filterByValue( const std::string& tableName,
                                            const std::string& viewName,
                                            const bool isString,
                                            const double value,
                                            const std::string& valueStr,
                                            const std::string& columnName,
                                            const std::map<std::string, std::string>& options ) const
{
    FilterByValueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.isString = isString;
    actualRequest_.value = value;
    actualRequest_.valueStr = valueStr;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    FilterByValueResponse actualResponse_;
    submitRequest("/filter/byvalue", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.  Although this
 * functionality can also be accomplished with the standard filter function, it
 * is more efficient.
 * 
 * @param tableName  Name of an existing table on which to perform the
 *                   calculation.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Has the same naming restrictions as
 *                  <a href="../../concepts/tables.html"
 *                  target="_top">tables</a>.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.
 * @param valueStr  The string value to search for.
 * @param columnName  Name of a column on which the filter by value would be
 *                    applied.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::filter_by_value_collection_name: Name of
 *                 a collection which is to contain the newly created view. If
 *                 the collection provided is non-existent, the collection will
 *                 be automatically created. If empty, then the newly created
 *                 view will be top-level.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& GPUdb::filterByValue( const std::string& tableName,
                                             const std::string& viewName,
                                             const bool isString,
                                             const double value,
                                             const std::string& valueStr,
                                             const std::string& columnName,
                                             const std::map<std::string, std::string>& options,
                                             FilterByValueResponse& response_ ) const
{
    FilterByValueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.isString = isString;
    actualRequest_.value = value;
    actualRequest_.valueStr = valueStr;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    submitRequest("/filter/byvalue", actualRequest_, response_, false);
    return response_;
}


/**
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetJobResponse GPUdb::getJob( const GetJobRequest& request_ ) const
{
    GetJobResponse actualResponse_;
    submitRequest("/get/job", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetJobResponse& GPUdb::getJob( const GetJobRequest& request_,
                               GetJobResponse& response_ ) const
{
    submitRequest("/get/job", request_, response_, false);
    return response_;
}


/**
 * 
 * @param jobId  A unique identifier for the job whose status and result is to
 *               be fetched.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetJobResponse GPUdb::getJob( const int64_t jobId,
                              const std::map<std::string, std::string>& options ) const
{
    GetJobRequest actualRequest_;
    actualRequest_.jobId = jobId;
    actualRequest_.options = options;
    GetJobResponse actualResponse_;
    submitRequest("/get/job", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * 
 * @param jobId  A unique identifier for the job whose status and result is to
 *               be fetched.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetJobResponse& GPUdb::getJob( const int64_t jobId,
                               const std::map<std::string, std::string>& options,
                               GetJobResponse& response_ ) const
{
    GetJobRequest actualRequest_;
    actualRequest_.jobId = jobId;
    actualRequest_.options = options;
    submitRequest("/get/job", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary, json or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsResponse GPUdb::getRecordsRaw( const GetRecordsRequest& request_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary, json or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsResponse& GPUdb::getRecordsRaw( const GetRecordsRequest& request_,
                                             RawGetRecordsResponse& response_ ) const
{
    submitRequest("/get/records", request_, response_, false);
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary, json or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsResponse<boost::any> GPUdb::getRecords( const GetRecordsRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary, json or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsResponse<boost::any>& GPUdb::getRecords( const GetRecordsRequest& request_,
                                                   GetRecordsResponse<boost::any>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary, json or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * 
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsResponse<boost::any> GPUdb::getRecords( const std::string& tableName,
                                                  const int64_t offset,
                                                  const int64_t limit,
                                                  const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary, json or geojson.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * 
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_expression: Optional filter
 *                 expression to apply to the table.
 *                         <li> gpudb::get_records_fast_index_lookup: Indicates
 *                 if indexes should be used to perform the lookup for a given
 *                 expression if possible. Only applicable if there is no
 *                 sorting, the expression contains only equivalence
 *                 comparisons based on existing tables indexes and the range
 *                 of requested values is from [0 to END_OF_SET].
 *                 <ul>
 *                         <li> gpudb::get_records_true
 *                         <li> gpudb::get_records_false
 *                 </ul>
 *                 The default value is gpudb::get_records_true.
 *                         <li> gpudb::get_records_sort_by: Optional column
 *                 that the data should be sorted by. Empty by default (i.e. no
 *                 sorting is applied).
 *                         <li> gpudb::get_records_sort_order: String
 *                 indicating how the returned values should be sorted -
 *                 ascending or descending. If sort_order is provided, sort_by
 *                 has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_ascending
 *                         <li> gpudb::get_records_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_ascending.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsResponse<boost::any>& GPUdb::getRecords( const std::string& tableName,
                                                   const int64_t offset,
                                                   const int64_t limit,
                                                   const std::map<std::string, std::string>& options,
                                                   GetRecordsResponse<boost::any>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->m_threadCount, this->m_executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * For a given table, retrieves the values from the requested column(s). Maps
 * of column name to the array of values as well as the column data type are
 * returned. This endpoint supports pagination with the @a offset and @a limit
 * parameters.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #createProjection(const CreateProjectionRequest&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a view) is modified (records are inserted, updated, or deleted) during a
 * call to the endpoint, the records or values retrieved may differ between
 * calls based on the type of the update, e.g., the contiguity across pages
 * cannot be relied upon.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsByColumnResponse GPUdb::getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_ ) const
{
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * For a given table, retrieves the values from the requested column(s). Maps
 * of column name to the array of values as well as the column data type are
 * returned. This endpoint supports pagination with the @a offset and @a limit
 * parameters.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #createProjection(const CreateProjectionRequest&,CreateProjectionResponse&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a view) is modified (records are inserted, updated, or deleted) during a
 * call to the endpoint, the records or values retrieved may differ between
 * calls based on the type of the update, e.g., the contiguity across pages
 * cannot be relied upon.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsByColumnResponse& GPUdb::getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_,
                                                             RawGetRecordsByColumnResponse& response_ ) const
{
    submitRequest("/get/records/bycolumn", request_, response_, false);
    return response_;
}


/**
 * For a given table, retrieves the values from the requested column(s). Maps
 * of column name to the array of values as well as the column data type are
 * returned. This endpoint supports pagination with the @a offset and @a limit
 * parameters.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #createProjection(const CreateProjectionRequest&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a view) is modified (records are inserted, updated, or deleted) during a
 * call to the endpoint, the records or values retrieved may differ between
 * calls based on the type of the update, e.g., the contiguity across pages
 * cannot be relied upon.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse GPUdb::getRecordsByColumn( const GetRecordsByColumnRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", request_, actualResponse_, false);
    GetRecordsByColumnResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * For a given table, retrieves the values from the requested column(s). Maps
 * of column name to the array of values as well as the column data type are
 * returned. This endpoint supports pagination with the @a offset and @a limit
 * parameters.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #createProjection(const CreateProjectionRequest&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a view) is modified (records are inserted, updated, or deleted) during a
 * call to the endpoint, the records or values retrieved may differ between
 * calls based on the type of the update, e.g., the contiguity across pages
 * cannot be relied upon.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& GPUdb::getRecordsByColumn( const GetRecordsByColumnRequest& request_,
                                                       GetRecordsByColumnResponse& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * For a given table, retrieves the values from the requested column(s). Maps
 * of column name to the array of values as well as the column data type are
 * returned. This endpoint supports pagination with the @a offset and @a limit
 * parameters.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #createProjection(const std::string&,const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a view) is modified (records are inserted, updated, or deleted) during a
 * call to the endpoint, the records or values retrieved may differ between
 * calls based on the type of the update, e.g., the contiguity across pages
 * cannot be relied upon.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param tableName  Name of the table on which this operation will be
 *                   performed. The table cannot be a parent set.
 * @param columnNames  The list of column values to retrieve.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000), or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be returned.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_expression:
 *                 Optional filter expression to apply to the table.
 *                         <li> gpudb::get_records_by_column_sort_by: Optional
 *                 column that the data should be sorted by. Used in
 *                 conjunction with @a sort_order. The @a order_by option can
 *                 be used in lieu of @a sort_by / @a sort_order.  The default
 *                 value is ''.
 *                         <li> gpudb::get_records_by_column_sort_order: String
 *                 indicating how the returned values should be sorted - @a
 *                 ascending or @a descending. If @a sort_order is provided, @a
 *                 sort_by has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_ascending
 *                         <li> gpudb::get_records_by_column_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_ascending.
 *                         <li> gpudb::get_records_by_column_order_by:
 *                 Comma-separated list of the columns to be sorted by as well
 *                 as the sort direction, e.g., 'timestamp asc, x desc'.  The
 *                 default value is ''.
 *                         <li>
 *                 gpudb::get_records_by_column_convert_wkts_to_wkbs: If true,
 *                 then WKT string columns will be returned as WKB bytes.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_true
 *                         <li> gpudb::get_records_by_column_false
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse GPUdb::getRecordsByColumn( const std::string& tableName,
                                                      const std::vector<std::string>& columnNames,
                                                      const int64_t offset,
                                                      const int64_t limit,
                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsByColumnRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", actualRequest_, actualResponse_, false);
    GetRecordsByColumnResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * For a given table, retrieves the values from the requested column(s). Maps
 * of column name to the array of values as well as the column data type are
 * returned. This endpoint supports pagination with the @a offset and @a limit
 * parameters.
 * <p>
 * <a href="../../concepts/window.html" target="_top">Window functions</a>,
 * which can perform operations like moving averages, are available through
 * this endpoint as well as {@link
 * #createProjection(const std::string&,const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a view) is modified (records are inserted, updated, or deleted) during a
 * call to the endpoint, the records or values retrieved may differ between
 * calls based on the type of the update, e.g., the contiguity across pages
 * cannot be relied upon.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../api/index.html#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * 
 * @param tableName  Name of the table on which this operation will be
 *                   performed. The table cannot be a parent set.
 * @param columnNames  The list of column values to retrieve.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000), or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be returned.
 * @param options
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_expression:
 *                 Optional filter expression to apply to the table.
 *                         <li> gpudb::get_records_by_column_sort_by: Optional
 *                 column that the data should be sorted by. Used in
 *                 conjunction with @a sort_order. The @a order_by option can
 *                 be used in lieu of @a sort_by / @a sort_order.  The default
 *                 value is ''.
 *                         <li> gpudb::get_records_by_column_sort_order: String
 *                 indicating how the returned values should be sorted - @a
 *                 ascending or @a descending. If @a sort_order is provided, @a
 *                 sort_by has to be provided.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_ascending
 *                         <li> gpudb::get_records_by_column_descending
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_ascending.
 *                         <li> gpudb::get_records_by_column_order_by:
 *                 Comma-separated list of the columns to be sorted by as well
 *                 as the sort direction, e.g., 'timestamp asc, x desc'.  The
 *                 default value is ''.
 *                         <li>
 *                 gpudb::get_records_by_column_convert_wkts_to_wkbs: If true,
 *                 then WKT string columns will be returned as WKB bytes.
 *                 <ul>
 *                         <li> gpudb::get_records_by_column_true
 *                         <li> gpudb::get_records_by_column_false
 *                 </ul>
 *                 The default value is gpudb::get_records_by_column_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& GPUdb::getRecordsByColumn( const std::string& tableName,
                                                       const std::vector<std::string>& columnNames,
                                                       const int64_t offset,
                                                       const int64_t limit,
                                                       const std::map<std::string, std::string>& options,
                                                       GetRecordsByColumnResponse& response_ ) const
{
    GetRecordsByColumnRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data, response_.dataTypePtr );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link #getRecordsRaw(const GetRecordsRequest&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsBySeriesResponse GPUdb::getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecordsRaw(const GetRecordsRequest&,RawGetRecordsResponse&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsBySeriesResponse& GPUdb::getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_,
                                                             RawGetRecordsBySeriesResponse& response_ ) const
{
    submitRequest("/get/records/byseries", request_, response_, false);
    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link #getRecords(const GetRecordsRequest&) const} this
 * returns records grouped by series/track. So if @a offset is 0 and @a limit
 * is 5 this operation would return the first 5 series/tracks in @a tableName.
 * Each series/track will be returned sorted by their TIMESTAMP column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any> GPUdb::getRecordsBySeries( const GetRecordsBySeriesRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<boost::any> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const GetRecordsRequest&,GetRecordsResponse<boost::any>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any>& GPUdb::getRecordsBySeries( const GetRecordsBySeriesRequest& request_,
                                                                   GetRecordsBySeriesResponse<boost::any>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any> GPUdb::getRecordsBySeries( const std::string& tableName,
                                                                  const std::string& worldTableName,
                                                                  const int32_t offset,
                                                                  const int32_t limit,
                                                                  const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<boost::any> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&,GetRecordsResponse<boost::any>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  The minimum allowed value is 0. The maximum
 *                allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any>& GPUdb::getRecordsBySeries( const std::string& tableName,
                                                                   const std::string& worldTableName,
                                                                   const int32_t offset,
                                                                   const int32_t limit,
                                                                   const std::map<std::string, std::string>& options,
                                                                   GetRecordsBySeriesResponse<boost::any>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->m_threadCount, this->m_executor);
    }

    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsFromCollectionResponse GPUdb::getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsFromCollectionResponse& GPUdb::getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_,
                                                                         RawGetRecordsFromCollectionResponse& response_ ) const
{
    submitRequest("/get/records/fromcollection", request_, response_, false);
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any> GPUdb::getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->m_threadCount, this->m_executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->m_threadCount, this->m_executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any>& GPUdb::getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_,
                                                                               GetRecordsFromCollectionResponse<boost::any>& response_ ) const
{
    if (request_.encoding != "binary")
        throw GPUdbException( "This function only supports binary encoding" );

    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->m_threadCount, this->m_executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->m_threadCount, this->m_executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If
 *                 'true' then return the internal record ID along with each
 *                 returned record. Default is 'false'.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any> GPUdb::getRecordsFromCollection( const std::string& tableName,
                                                                              const int64_t offset,
                                                                              const int64_t limit,
                                                                              const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->m_threadCount, this->m_executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->m_threadCount, this->m_executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.
 * @param options
 *                 <ul>
 *                         <li>
 *                 gpudb::get_records_from_collection_return_record_ids: If
 *                 'true' then return the internal record ID along with each
 *                 returned record. Default is 'false'.
 *                 <ul>
 *                         <li> gpudb::get_records_from_collection_true
 *                         <li> gpudb::get_records_from_collection_false
 *                 </ul>
 *                 The default value is
 *                 gpudb::get_records_from_collection_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any>& GPUdb::getRecordsFromCollection( const std::string& tableName,
                                                                               const int64_t offset,
                                                                               const int64_t limit,
                                                                               const std::map<std::string, std::string>& options,
                                                                               GetRecordsFromCollectionResponse<boost::any>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->m_threadCount, this->m_executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->m_threadCount, this->m_executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    response_.info = actualResponse_.info;
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetVectortileResponse GPUdb::getVectortile( const GetVectortileRequest& request_ ) const
{
    GetVectortileResponse actualResponse_;
    submitRequest("/get/vectortile", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetVectortileResponse& GPUdb::getVectortile( const GetVectortileRequest& request_,
                                             GetVectortileResponse& response_ ) const
{
    submitRequest("/get/vectortile", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param columnNames
 * @param layers
 * @param tileX
 * @param tileY
 * @param zoom
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetVectortileResponse GPUdb::getVectortile( const std::vector<std::string>& tableNames,
                                            const std::vector<std::string>& columnNames,
                                            const std::map<std::string, std::vector<std::string> >& layers,
                                            const int32_t tileX,
                                            const int32_t tileY,
                                            const int32_t zoom,
                                            const std::map<std::string, std::string>& options ) const
{
    GetVectortileRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnNames = columnNames;
    actualRequest_.layers = layers;
    actualRequest_.tileX = tileX;
    actualRequest_.tileY = tileY;
    actualRequest_.zoom = zoom;
    actualRequest_.options = options;
    GetVectortileResponse actualResponse_;
    submitRequest("/get/vectortile", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param columnNames
 * @param layers
 * @param tileX
 * @param tileY
 * @param zoom
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetVectortileResponse& GPUdb::getVectortile( const std::vector<std::string>& tableNames,
                                             const std::vector<std::string>& columnNames,
                                             const std::map<std::string, std::vector<std::string> >& layers,
                                             const int32_t tileX,
                                             const int32_t tileY,
                                             const int32_t zoom,
                                             const std::map<std::string, std::string>& options,
                                             GetVectortileResponse& response_ ) const
{
    GetVectortileRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnNames = columnNames;
    actualRequest_.layers = layers;
    actualRequest_.tileX = tileX;
    actualRequest_.tileY = tileY;
    actualRequest_.zoom = zoom;
    actualRequest_.options = options;
    submitRequest("/get/vectortile", actualRequest_, response_, false);
    return response_;
}


/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionProcResponse GPUdb::grantPermissionProc( const GrantPermissionProcRequest& request_ ) const
{
    GrantPermissionProcResponse actualResponse_;
    submitRequest("/grant/permission/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionProcResponse& GPUdb::grantPermissionProc( const GrantPermissionProcRequest& request_,
                                                         GrantPermissionProcResponse& response_ ) const
{
    submitRequest("/grant/permission/proc", request_, response_, false);
    return response_;
}


/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string to grant
 *                  access to all procs.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionProcResponse GPUdb::grantPermissionProc( const std::string& name,
                                                        const std::string& permission,
                                                        const std::string& procName,
                                                        const std::map<std::string, std::string>& options ) const
{
    GrantPermissionProcRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    GrantPermissionProcResponse actualResponse_;
    submitRequest("/grant/permission/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a proc-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string to grant
 *                  access to all procs.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionProcResponse& GPUdb::grantPermissionProc( const std::string& name,
                                                         const std::string& permission,
                                                         const std::string& procName,
                                                         const std::map<std::string, std::string>& options,
                                                         GrantPermissionProcResponse& response_ ) const
{
    GrantPermissionProcRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/grant/permission/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionSystemResponse GPUdb::grantPermissionSystem( const GrantPermissionSystemRequest& request_ ) const
{
    GrantPermissionSystemResponse actualResponse_;
    submitRequest("/grant/permission/system", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionSystemResponse& GPUdb::grantPermissionSystem( const GrantPermissionSystemRequest& request_,
                                                             GrantPermissionSystemResponse& response_ ) const
{
    submitRequest("/grant/permission/system", request_, response_, false);
    return response_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_system_system_admin:
 *                    Full access to all data and system functions.
 *                            <li> gpudb::grant_permission_system_system_write:
 *                    Read and write access to all tables.
 *                            <li> gpudb::grant_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionSystemResponse GPUdb::grantPermissionSystem( const std::string& name,
                                                            const std::string& permission,
                                                            const std::map<std::string, std::string>& options ) const
{
    GrantPermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    GrantPermissionSystemResponse actualResponse_;
    submitRequest("/grant/permission/system", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_system_system_admin:
 *                    Full access to all data and system functions.
 *                            <li> gpudb::grant_permission_system_system_write:
 *                    Read and write access to all tables.
 *                            <li> gpudb::grant_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionSystemResponse& GPUdb::grantPermissionSystem( const std::string& name,
                                                             const std::string& permission,
                                                             const std::map<std::string, std::string>& options,
                                                             GrantPermissionSystemResponse& response_ ) const
{
    GrantPermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    submitRequest("/grant/permission/system", actualRequest_, response_, false);
    return response_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionTableResponse GPUdb::grantPermissionTable( const GrantPermissionTableRequest& request_ ) const
{
    GrantPermissionTableResponse actualResponse_;
    submitRequest("/grant/permission/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionTableResponse& GPUdb::grantPermissionTable( const GrantPermissionTableRequest& request_,
                                                           GrantPermissionTableResponse& response_ ) const
{
    submitRequest("/grant/permission/table", request_, response_, false);
    return response_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::grant_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::grant_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::grant_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::grant_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view. If a
 *                   collection, the permission also applies to tables and
 *                   views in the collection.
 * @param filterExpression  Reserved for future use.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionTableResponse GPUdb::grantPermissionTable( const std::string& name,
                                                          const std::string& permission,
                                                          const std::string& tableName,
                                                          const std::string& filterExpression,
                                                          const std::map<std::string, std::string>& options ) const
{
    GrantPermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.filterExpression = filterExpression;
    actualRequest_.options = options;
    GrantPermissionTableResponse actualResponse_;
    submitRequest("/grant/permission/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role.
 *                    <ul>
 *                            <li> gpudb::grant_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::grant_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::grant_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::grant_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::grant_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view. If a
 *                   collection, the permission also applies to tables and
 *                   views in the collection.
 * @param filterExpression  Reserved for future use.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionTableResponse& GPUdb::grantPermissionTable( const std::string& name,
                                                           const std::string& permission,
                                                           const std::string& tableName,
                                                           const std::string& filterExpression,
                                                           const std::map<std::string, std::string>& options,
                                                           GrantPermissionTableResponse& response_ ) const
{
    GrantPermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.filterExpression = filterExpression;
    actualRequest_.options = options;
    submitRequest("/grant/permission/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantRoleResponse GPUdb::grantRole( const GrantRoleRequest& request_ ) const
{
    GrantRoleResponse actualResponse_;
    submitRequest("/grant/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantRoleResponse& GPUdb::grantRole( const GrantRoleRequest& request_,
                                     GrantRoleResponse& response_ ) const
{
    submitRequest("/grant/role", request_, response_, false);
    return response_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param role  Name of the role in which membership will be granted. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be granted membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantRoleResponse GPUdb::grantRole( const std::string& role,
                                    const std::string& member,
                                    const std::map<std::string, std::string>& options ) const
{
    GrantRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    GrantRoleResponse actualResponse_;
    submitRequest("/grant/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param role  Name of the role in which membership will be granted. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be granted membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantRoleResponse& GPUdb::grantRole( const std::string& role,
                                     const std::string& member,
                                     const std::map<std::string, std::string>& options,
                                     GrantRoleResponse& response_ ) const
{
    GrantRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    submitRequest("/grant/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasProcResponse GPUdb::hasProc( const HasProcRequest& request_ ) const
{
    HasProcResponse actualResponse_;
    submitRequest("/has/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasProcResponse& GPUdb::hasProc( const HasProcRequest& request_,
                                 HasProcResponse& response_ ) const
{
    submitRequest("/has/proc", request_, response_, false);
    return response_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param procName  Name of the proc to check for existence.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasProcResponse GPUdb::hasProc( const std::string& procName,
                                const std::map<std::string, std::string>& options ) const
{
    HasProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    HasProcResponse actualResponse_;
    submitRequest("/has/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param procName  Name of the proc to check for existence.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasProcResponse& GPUdb::hasProc( const std::string& procName,
                                 const std::map<std::string, std::string>& options,
                                 HasProcResponse& response_ ) const
{
    HasProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/has/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Checks for the existence of a table with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse GPUdb::hasTable( const HasTableRequest& request_ ) const
{
    HasTableResponse actualResponse_;
    submitRequest("/has/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks for the existence of a table with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& GPUdb::hasTable( const HasTableRequest& request_,
                                   HasTableResponse& response_ ) const
{
    submitRequest("/has/table", request_, response_, false);
    return response_;
}


/**
 * Checks for the existence of a table with the given name.
 * 
 * @param tableName  Name of the table to check for existence.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse GPUdb::hasTable( const std::string& tableName,
                                  const std::map<std::string, std::string>& options ) const
{
    HasTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    HasTableResponse actualResponse_;
    submitRequest("/has/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks for the existence of a table with the given name.
 * 
 * @param tableName  Name of the table to check for existence.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& GPUdb::hasTable( const std::string& tableName,
                                   const std::map<std::string, std::string>& options,
                                   HasTableResponse& response_ ) const
{
    HasTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/has/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Check for the existence of a type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse GPUdb::hasType( const HasTypeRequest& request_ ) const
{
    HasTypeResponse actualResponse_;
    submitRequest("/has/type", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Check for the existence of a type.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& GPUdb::hasType( const HasTypeRequest& request_,
                                 HasTypeResponse& response_ ) const
{
    submitRequest("/has/type", request_, response_, false);
    return response_;
}


/**
 * Check for the existence of a type.
 * 
 * @param typeId  Id of the type returned in response to /create/type request.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse GPUdb::hasType( const std::string& typeId,
                                const std::map<std::string, std::string>& options ) const
{
    HasTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    HasTypeResponse actualResponse_;
    submitRequest("/has/type", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Check for the existence of a type.
 * 
 * @param typeId  Id of the type returned in response to /create/type request.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& GPUdb::hasType( const std::string& typeId,
                                 const std::map<std::string, std::string>& options,
                                 HasTypeResponse& response_ ) const
{
    HasTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    submitRequest("/has/type", actualRequest_, response_, false);
    return response_;
}


/**
 * Adds multiple records to the specified table. The operation is synchronous,
 * meaning that a response will not be returned until all the records are fully
 * inserted and available. The response payload provides the counts of the
 * number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record collision policy
 * for inserting into a table with a <a
 * href="../../concepts/tables.html#primary-keys" target="_top">primary
 * key</a>, but is ignored if no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the database should return
 * the unique identifiers of inserted records.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsResponse GPUdb::insertRecordsRaw( const RawInsertRecordsRequest& request_ ) const
{
    InsertRecordsResponse actualResponse_;
    submitRequest("/insert/records", request_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Adds multiple records to the specified table. The operation is synchronous,
 * meaning that a response will not be returned until all the records are fully
 * inserted and available. The response payload provides the counts of the
 * number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's behavior.
 * <p>
 * The @a update_on_existing_pk option specifies the record collision policy
 * for inserting into a table with a <a
 * href="../../concepts/tables.html#primary-keys" target="_top">primary
 * key</a>, but is ignored if no primary key exists.
 * <p>
 * The @a return_record_ids option indicates that the database should return
 * the unique identifiers of inserted records.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsResponse& GPUdb::insertRecordsRaw( const RawInsertRecordsRequest& request_,
                                                InsertRecordsResponse& response_ ) const
{
    submitRequest("/insert/records", request_, response_, true);
    return response_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse GPUdb::insertRecordsRandom( const InsertRecordsRandomRequest& request_ ) const
{
    InsertRecordsRandomResponse actualResponse_;
    submitRequest("/insert/records/random", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& GPUdb::insertRecordsRandom( const InsertRecordsRandomRequest& request_,
                                                         InsertRecordsRandomResponse& response_ ) const
{
    submitRequest("/insert/records/random", request_, response_, false);
    return response_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param tableName  Table to which random records will be added. Must be an
 *                   existing table.  Also, must be an individual table, not a
 *                   collection of tables, nor a view of a table.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  These parameters take on
 *                 different meanings depending on the type of the column.
 *                 Below follows a more detailed description of the map:
 *                 <ul>
 *                         <li> gpudb::insert_records_random_seed: If provided,
 *                 the internal random number generator will be initialized
 *                 with the given value.  The minimum is 0.  This allows for
 *                 the same set of random numbers to be generated across
 *                 invocation of this endpoint in case the user wants to repeat
 *                 the test.  Since @a options, is a map of maps, we need an
 *                 internal map to provide the seed value.  For example, to
 *                 pass 100 as the seed value through this parameter, you need
 *                 something equivalent to: 'options' = {'seed': { 'value': 100
 *                 } }
 *                 <ul>
 *                         <li> gpudb::insert_records_random_value: Pass the
 *                 seed value here.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_all: This key
 *                 indicates that the specifications relayed in the internal
 *                 map are to be applied to all columns of the records.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified, then generate the given percentage of the
 *                 count as nulls for all nullable columns.  This option will
 *                 be ignored for non-nullable columns.  The value must be
 *                 within the range [0, 1.0].  The default value is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_attr_name: Use the
 *                 desired column name in place of @a attr_name, and set the
 *                 following parameters for the column specified. This
 *                 overrides any parameter set by @a all.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified and if this column is nullable, then generate
 *                 the given percentage of the count as nulls.  This option
 *                 will result in an error if the column is not nullable.  The
 *                 value must be within the range [0, 1.0].  The default value
 *                 is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_track_length: This
 *                 key-map pair is only valid for track data sets (an error is
 *                 thrown otherwise).  No nulls would be generated for nullable
 *                 columns.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: Minimum
 *                 possible length for generated series; default is 100 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, min must be less
 *                 than or equal to max.
 *                         <li> gpudb::insert_records_random_max: Maximum
 *                 possible length for generated series; default is 500 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, max must be greater
 *                 than or equal to min.
 *                 </ul>
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse GPUdb::insertRecordsRandom( const std::string& tableName,
                                                        const int64_t count,
                                                        const std::map<std::string, std::map<std::string, double> >& options ) const
{
    InsertRecordsRandomRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.count = count;
    actualRequest_.options = options;
    InsertRecordsRandomResponse actualResponse_;
    submitRequest("/insert/records/random", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 * 
 * @param tableName  Table to which random records will be added. Must be an
 *                   existing table.  Also, must be an individual table, not a
 *                   collection of tables, nor a view of a table.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  These parameters take on
 *                 different meanings depending on the type of the column.
 *                 Below follows a more detailed description of the map:
 *                 <ul>
 *                         <li> gpudb::insert_records_random_seed: If provided,
 *                 the internal random number generator will be initialized
 *                 with the given value.  The minimum is 0.  This allows for
 *                 the same set of random numbers to be generated across
 *                 invocation of this endpoint in case the user wants to repeat
 *                 the test.  Since @a options, is a map of maps, we need an
 *                 internal map to provide the seed value.  For example, to
 *                 pass 100 as the seed value through this parameter, you need
 *                 something equivalent to: 'options' = {'seed': { 'value': 100
 *                 } }
 *                 <ul>
 *                         <li> gpudb::insert_records_random_value: Pass the
 *                 seed value here.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_all: This key
 *                 indicates that the specifications relayed in the internal
 *                 map are to be applied to all columns of the records.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified, then generate the given percentage of the
 *                 count as nulls for all nullable columns.  This option will
 *                 be ignored for non-nullable columns.  The value must be
 *                 within the range [0, 1.0].  The default value is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_attr_name: Use the
 *                 desired column name in place of @a attr_name, and set the
 *                 following parameters for the column specified. This
 *                 overrides any parameter set by @a all.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: For numerical
 *                 columns, the minimum of the generated values is set to this
 *                 value.  Default is -99999.  For point, shape, and track
 *                 columns, min for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 -180.0 and -90.0. For the 'TIMESTAMP' column, the default
 *                 minimum corresponds to Jan 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 0). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [0, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_max: For numerical
 *                 columns, the maximum of the generated values is set to this
 *                 value. Default is 99999. For point, shape, and track
 *                 columns, max for numeric 'x' and 'y' columns needs to be
 *                 within [-180, 180] and [-90, 90], respectively. The default
 *                 minimum possible values for these columns in such cases are
 *                 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [0, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track, then
 *                 those parameters will not be set; however, an error will not
 *                 be thrown in such a case. It is the responsibility of the
 *                 user to use the @a all parameter judiciously.
 *                         <li> gpudb::insert_records_random_interval: If
 *                 specified, generate values for all columns evenly spaced
 *                 with the given interval value. If a max value is specified
 *                 for a given column the data is randomly generated between
 *                 min and max and decimated down to the interval. If no max is
 *                 provided the data is linerally generated starting at the
 *                 minimum value (instead of generating random data). For
 *                 non-decimated string-type columns the interval value is
 *                 ignored. Instead the values are generated following the
 *                 pattern: 'attrname_creationIndex#', i.e. the column name
 *                 suffixed with an underscore and a running counter (starting
 *                 at 0). For string types with limited size (eg char4) the
 *                 prefix is dropped. No nulls will be generated for nullable
 *                 columns.
 *                         <li> gpudb::insert_records_random_null_percentage:
 *                 If specified and if this column is nullable, then generate
 *                 the given percentage of the count as nulls.  This option
 *                 will result in an error if the column is not nullable.  The
 *                 value must be within the range [0, 1.0].  The default value
 *                 is 5% (0.05).
 *                         <li> gpudb::insert_records_random_cardinality: If
 *                 specified, limit the randomly generated values to a fixed
 *                 set. Not allowed on a column with interval specified, and is
 *                 not applicable to WKT or Track-specific columns. The value
 *                 must be greater than 0. This option is disabled by default.
 *                 </ul>
 *                         <li> gpudb::insert_records_random_track_length: This
 *                 key-map pair is only valid for track data sets (an error is
 *                 thrown otherwise).  No nulls would be generated for nullable
 *                 columns.
 *                 <ul>
 *                         <li> gpudb::insert_records_random_min: Minimum
 *                 possible length for generated series; default is 100 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, min must be less
 *                 than or equal to max.
 *                         <li> gpudb::insert_records_random_max: Maximum
 *                 possible length for generated series; default is 500 records
 *                 per series. Must be an integral value within the range [1,
 *                 500]. If both min and max are specified, max must be greater
 *                 than or equal to min.
 *                 </ul>
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& GPUdb::insertRecordsRandom( const std::string& tableName,
                                                         const int64_t count,
                                                         const std::map<std::string, std::map<std::string, double> >& options,
                                                         InsertRecordsRandomResponse& response_ ) const
{
    InsertRecordsRandomRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.count = count;
    actualRequest_.options = options;
    submitRequest("/insert/records/random", actualRequest_, response_, false);
    return response_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../api/rest/wms_rest.html" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse GPUdb::insertSymbol( const InsertSymbolRequest& request_ ) const
{
    InsertSymbolResponse actualResponse_;
    submitRequest("/insert/symbol", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../api/rest/wms_rest.html" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& GPUdb::insertSymbol( const InsertSymbolRequest& request_,
                                           InsertSymbolResponse& response_ ) const
{
    submitRequest("/insert/symbol", request_, response_, false);
    return response_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../api/rest/wms_rest.html" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'.
 *                      <ul>
 *                              <li> gpudb::insert_symbol_svg
 *                              <li> gpudb::insert_symbol_svg_path
 *                      </ul>
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::insert_symbol_color: If @a symbolFormat
 *                 is 'svg' this is ignored. If @a symbolFormat is 'svg_path'
 *                 then this option specifies the color (in RRGGBB hex format)
 *                 of the path. For example, to have the path rendered in red,
 *                 used 'FF0000'. If 'color' is not provided then '00FF00'
 *                 (i.e. green) is used by default.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse GPUdb::insertSymbol( const std::string& symbolId,
                                          const std::string& symbolFormat,
                                          const std::vector<uint8_t>& symbolData,
                                          const std::map<std::string, std::string>& options ) const
{
    InsertSymbolRequest actualRequest_;
    actualRequest_.symbolId = symbolId;
    actualRequest_.symbolFormat = symbolFormat;
    actualRequest_.symbolData = symbolData;
    actualRequest_.options = options;
    InsertSymbolResponse actualResponse_;
    submitRequest("/insert/symbol", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../api/rest/wms_rest.html" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'.
 *                      <ul>
 *                              <li> gpudb::insert_symbol_svg
 *                              <li> gpudb::insert_symbol_svg_path
 *                      </ul>
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::insert_symbol_color: If @a symbolFormat
 *                 is 'svg' this is ignored. If @a symbolFormat is 'svg_path'
 *                 then this option specifies the color (in RRGGBB hex format)
 *                 of the path. For example, to have the path rendered in red,
 *                 used 'FF0000'. If 'color' is not provided then '00FF00'
 *                 (i.e. green) is used by default.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& GPUdb::insertSymbol( const std::string& symbolId,
                                           const std::string& symbolFormat,
                                           const std::vector<uint8_t>& symbolData,
                                           const std::map<std::string, std::string>& options,
                                           InsertSymbolResponse& response_ ) const
{
    InsertSymbolRequest actualRequest_;
    actualRequest_.symbolId = symbolId;
    actualRequest_.symbolFormat = symbolFormat;
    actualRequest_.symbolData = symbolData;
    actualRequest_.options = options;
    submitRequest("/insert/symbol", actualRequest_, response_, false);
    return response_;
}


/**
 * Kills a running proc instance.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

KillProcResponse GPUdb::killProc( const KillProcRequest& request_ ) const
{
    KillProcResponse actualResponse_;
    submitRequest("/kill/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Kills a running proc instance.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

KillProcResponse& GPUdb::killProc( const KillProcRequest& request_,
                                   KillProcResponse& response_ ) const
{
    submitRequest("/kill/proc", request_, response_, false);
    return response_;
}


/**
 * Kills a running proc instance.
 * 
 * @param runId  The run ID of the running proc instance. If the run ID is not
 *               found or the proc instance has already completed, this does
 *               nothing. If not specified, all running proc instances will be
 *               killed.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

KillProcResponse GPUdb::killProc( const std::string& runId,
                                  const std::map<std::string, std::string>& options ) const
{
    KillProcRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    KillProcResponse actualResponse_;
    submitRequest("/kill/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Kills a running proc instance.
 * 
 * @param runId  The run ID of the running proc instance. If the run ID is not
 *               found or the proc instance has already completed, this does
 *               nothing. If not specified, all running proc instances will be
 *               killed.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

KillProcResponse& GPUdb::killProc( const std::string& runId,
                                   const std::map<std::string, std::string>& options,
                                   KillProcResponse& response_ ) const
{
    KillProcRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    submitRequest("/kill/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Lists basic information about one or all graphs that exist on the graph
 * server.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ListGraphResponse GPUdb::listGraph( const ListGraphRequest& request_ ) const
{
    ListGraphResponse actualResponse_;
    submitRequest("/list/graph", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Lists basic information about one or all graphs that exist on the graph
 * server.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ListGraphResponse& GPUdb::listGraph( const ListGraphRequest& request_,
                                     ListGraphResponse& response_ ) const
{
    submitRequest("/list/graph", request_, response_, false);
    return response_;
}


/**
 * Lists basic information about one or all graphs that exist on the graph
 * server.
 * 
 * @param graphName  Name of the graph on which to retrieve information. If
 *                   empty, information about all graphs is returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ListGraphResponse GPUdb::listGraph( const std::string& graphName,
                                    const std::map<std::string, std::string>& options ) const
{
    ListGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.options = options;
    ListGraphResponse actualResponse_;
    submitRequest("/list/graph", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Lists basic information about one or all graphs that exist on the graph
 * server.
 * 
 * @param graphName  Name of the graph on which to retrieve information. If
 *                   empty, information about all graphs is returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ListGraphResponse& GPUdb::listGraph( const std::string& graphName,
                                     const std::map<std::string, std::string>& options,
                                     ListGraphResponse& response_ ) const
{
    ListGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.options = options;
    submitRequest("/list/graph", actualRequest_, response_, false);
    return response_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse GPUdb::lockTable( const LockTableRequest& request_ ) const
{
    LockTableResponse actualResponse_;
    submitRequest("/lock/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& GPUdb::lockTable( const LockTableRequest& request_,
                                     LockTableResponse& response_ ) const
{
    submitRequest("/lock/table", request_, response_, false);
    return response_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param tableName  Name of the table to be locked. It must be a currently
 *                   existing table, collection, or view.
 * @param lockType  The type of lock being applied to the table. Setting it to
 *                  @a status will return the current lock status of the table
 *                  without changing it.
 *                  <ul>
 *                          <li> gpudb::lock_table_status: Show locked status
 *                          <li> gpudb::lock_table_no_access: Allow no
 *                  read/write operations
 *                          <li> gpudb::lock_table_read_only: Allow only read
 *                  operations
 *                          <li> gpudb::lock_table_write_only: Allow only write
 *                  operations
 *                          <li> gpudb::lock_table_read_write: Allow all
 *                  read/write operations
 *                  </ul>
 *                  The default value is gpudb::lock_table_status.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse GPUdb::lockTable( const std::string& tableName,
                                    const std::string& lockType,
                                    const std::map<std::string, std::string>& options ) const
{
    LockTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.lockType = lockType;
    actualRequest_.options = options;
    LockTableResponse actualResponse_;
    submitRequest("/lock/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a read_write, indicating all operations are permitted.  A user
 * may request a @a read_only or a @a write_only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a no_access then no operations are permitted
 * on the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param tableName  Name of the table to be locked. It must be a currently
 *                   existing table, collection, or view.
 * @param lockType  The type of lock being applied to the table. Setting it to
 *                  @a status will return the current lock status of the table
 *                  without changing it.
 *                  <ul>
 *                          <li> gpudb::lock_table_status: Show locked status
 *                          <li> gpudb::lock_table_no_access: Allow no
 *                  read/write operations
 *                          <li> gpudb::lock_table_read_only: Allow only read
 *                  operations
 *                          <li> gpudb::lock_table_write_only: Allow only write
 *                  operations
 *                          <li> gpudb::lock_table_read_write: Allow all
 *                  read/write operations
 *                  </ul>
 *                  The default value is gpudb::lock_table_status.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& GPUdb::lockTable( const std::string& tableName,
                                     const std::string& lockType,
                                     const std::map<std::string, std::string>& options,
                                     LockTableResponse& response_ ) const
{
    LockTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.lockType = lockType;
    actualRequest_.options = options;
    submitRequest("/lock/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Matches a directed route implied by a given set of latitude/longitude points
 * to an existing underlying road network graph using a given solution type.
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MatchGraphResponse GPUdb::matchGraph( const MatchGraphRequest& request_ ) const
{
    MatchGraphResponse actualResponse_;
    submitRequest("/match/graph", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Matches a directed route implied by a given set of latitude/longitude points
 * to an existing underlying road network graph using a given solution type.
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MatchGraphResponse& GPUdb::matchGraph( const MatchGraphRequest& request_,
                                       MatchGraphResponse& response_ ) const
{
    submitRequest("/match/graph", request_, response_, false);
    return response_;
}


/**
 * Matches a directed route implied by a given set of latitude/longitude points
 * to an existing underlying road network graph using a given solution type.
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param graphName  Name of the underlying geospatial graph resource to match
 *                   to using @a samplePoints.
 * @param samplePoints  Sample points used to match to an underlying geospatial
 *                      graph. Sample points must be specified using <a
 *                      href="../../graph_solver/network_graph_solver.html#match-identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#match-combinations"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with: existing column names, e.g., 'table.column AS
 *                      SAMPLE_X'; expressions, e.g., 'ST_MAKEPOINT(table.x,
 *                      table.y) AS SAMPLE_WKTPOINT'; or raw values, e.g., '{1,
 *                      2, 10} AS SAMPLE_TRIPID'.
 * @param solveMethod  The type of solver to use for graph matching.
 *                     <ul>
 *                             <li> gpudb::match_graph_markov_chain: Matches @a
 *                     samplePoints to the graph using the Hidden Markov Model
 *                     (HMM)-based method, which conducts a range-tree
 *                     closest-edge search to find the best combinations of
 *                     possible road segments (@a num_segments) for each sample
 *                     point to create the best route. The route is secured one
 *                     point at a time while looking ahead @a chain_width
 *                     number of points, so the prediction is corrected after
 *                     each point. This solution type is the most accurate but
 *                     also the most computationally intensive.
 *                             <li> gpudb::match_graph_incremental_weighted:
 *                     Matches @a samplePoints to the graph using time and/or
 *                     distance between points to influence one or more
 *                     shortest paths across the sample points.
 *                             <li> gpudb::match_graph_match_od_pairs: Matches
 *                     @a samplePoints to find the most probable path between
 *                     origin and destination pairs with cost constraints
 *                     </ul>
 *                     The default value is gpudb::match_graph_markov_chain.
 * @param solutionTable  The name of the table used to store the results; this
 *                       table contains a <a
 *                       href="../../geospatial/geo_objects.html#geospatial-tracks"
 *                       target="_top">track</a> of geospatial points for the
 *                       matched portion of the graph, a track ID, and a score
 *                       value. Also outputs a details table containing a trip
 *                       ID (that matches the track ID), the latitude/longitude
 *                       pair, the timestamp the point was recorded at, and an
 *                       edge ID corresponding to the matched road segment. Has
 *                       the same naming restrictions as <a
 *                       href="../../concepts/tables.html"
 *                       target="_top">tables</a>. Must not be an existing
 *                       table of the same name.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::match_graph_gps_noise: GPS noise value
 *                 (in meters) to remove redundant sample points. Use -1 to
 *                 disable noise reduction. The default value accounts for 95%
 *                 of point variation (+ or -5 meters).  The default value is
 *                 '5.0'.
 *                         <li> gpudb::match_graph_num_segments: Maximum number
 *                 of potentially matching road segments for each sample point.
 *                 For the @a markov_chain solver, the default is 3; for the @a
 *                 incremental_weighted, the default is 5.  The default value
 *                 is ''.
 *                         <li> gpudb::match_graph_search_radius: Maximum
 *                 search radius used when snapping sample points onto
 *                 potentially matching surrounding segments. The default value
 *                 corresponds to approximately 100 meters.  The default value
 *                 is '0.001'.
 *                         <li> gpudb::match_graph_chain_width: For the @a
 *                 markov_chain solver only. Length of the sample points
 *                 lookahead window within the Markov kernel; the larger the
 *                 number, the more accurate the solution.  The default value
 *                 is '9'.
 *                         <li> gpudb::match_graph_max_solve_length: For the @a
 *                 incremental_weighted solver only. Maximum number of samples
 *                 along the path on which to solve.  The default value is
 *                 '200'.
 *                         <li> gpudb::match_graph_time_window_width: For the
 *                 @a incremental_weighted solver only. Time window, also known
 *                 as sampling period, in which points are favored. To
 *                 determine the raw window value, the @a time_window_width
 *                 value is multiplied by the mean sample time (in seconds)
 *                 across all points, e.g., if @a time_window_width is 30 and
 *                 the mean sample time is 2 seconds, points that are sampled
 *                 greater than 60 seconds after the previous point are no
 *                 longer favored in the solution.  The default value is '30'.
 *                         <li> gpudb::match_graph_detect_loops: For the @a
 *                 incremental_weighted solver only. If @a true, a loop will be
 *                 detected and traversed even if it would make a shorter path
 *                 to ignore the loop.
 *                 <ul>
 *                         <li> gpudb::match_graph_true
 *                         <li> gpudb::match_graph_false
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_source: Optional WKT
 *                 starting point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the starting point.  The default value is 'POINT
 *                 NULL'.
 *                         <li> gpudb::match_graph_destination: Optional WKT
 *                 ending point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the destination point.  The default value is
 *                 'POINT NULL'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MatchGraphResponse GPUdb::matchGraph( const std::string& graphName,
                                      const std::vector<std::string>& samplePoints,
                                      const std::string& solveMethod,
                                      const std::string& solutionTable,
                                      const std::map<std::string, std::string>& options ) const
{
    MatchGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.samplePoints = samplePoints;
    actualRequest_.solveMethod = solveMethod;
    actualRequest_.solutionTable = solutionTable;
    actualRequest_.options = options;
    MatchGraphResponse actualResponse_;
    submitRequest("/match/graph", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Matches a directed route implied by a given set of latitude/longitude points
 * to an existing underlying road network graph using a given solution type.
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 * 
 * @param graphName  Name of the underlying geospatial graph resource to match
 *                   to using @a samplePoints.
 * @param samplePoints  Sample points used to match to an underlying geospatial
 *                      graph. Sample points must be specified using <a
 *                      href="../../graph_solver/network_graph_solver.html#match-identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#match-combinations"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with: existing column names, e.g., 'table.column AS
 *                      SAMPLE_X'; expressions, e.g., 'ST_MAKEPOINT(table.x,
 *                      table.y) AS SAMPLE_WKTPOINT'; or raw values, e.g., '{1,
 *                      2, 10} AS SAMPLE_TRIPID'.
 * @param solveMethod  The type of solver to use for graph matching.
 *                     <ul>
 *                             <li> gpudb::match_graph_markov_chain: Matches @a
 *                     samplePoints to the graph using the Hidden Markov Model
 *                     (HMM)-based method, which conducts a range-tree
 *                     closest-edge search to find the best combinations of
 *                     possible road segments (@a num_segments) for each sample
 *                     point to create the best route. The route is secured one
 *                     point at a time while looking ahead @a chain_width
 *                     number of points, so the prediction is corrected after
 *                     each point. This solution type is the most accurate but
 *                     also the most computationally intensive.
 *                             <li> gpudb::match_graph_incremental_weighted:
 *                     Matches @a samplePoints to the graph using time and/or
 *                     distance between points to influence one or more
 *                     shortest paths across the sample points.
 *                             <li> gpudb::match_graph_match_od_pairs: Matches
 *                     @a samplePoints to find the most probable path between
 *                     origin and destination pairs with cost constraints
 *                     </ul>
 *                     The default value is gpudb::match_graph_markov_chain.
 * @param solutionTable  The name of the table used to store the results; this
 *                       table contains a <a
 *                       href="../../geospatial/geo_objects.html#geospatial-tracks"
 *                       target="_top">track</a> of geospatial points for the
 *                       matched portion of the graph, a track ID, and a score
 *                       value. Also outputs a details table containing a trip
 *                       ID (that matches the track ID), the latitude/longitude
 *                       pair, the timestamp the point was recorded at, and an
 *                       edge ID corresponding to the matched road segment. Has
 *                       the same naming restrictions as <a
 *                       href="../../concepts/tables.html"
 *                       target="_top">tables</a>. Must not be an existing
 *                       table of the same name.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::match_graph_gps_noise: GPS noise value
 *                 (in meters) to remove redundant sample points. Use -1 to
 *                 disable noise reduction. The default value accounts for 95%
 *                 of point variation (+ or -5 meters).  The default value is
 *                 '5.0'.
 *                         <li> gpudb::match_graph_num_segments: Maximum number
 *                 of potentially matching road segments for each sample point.
 *                 For the @a markov_chain solver, the default is 3; for the @a
 *                 incremental_weighted, the default is 5.  The default value
 *                 is ''.
 *                         <li> gpudb::match_graph_search_radius: Maximum
 *                 search radius used when snapping sample points onto
 *                 potentially matching surrounding segments. The default value
 *                 corresponds to approximately 100 meters.  The default value
 *                 is '0.001'.
 *                         <li> gpudb::match_graph_chain_width: For the @a
 *                 markov_chain solver only. Length of the sample points
 *                 lookahead window within the Markov kernel; the larger the
 *                 number, the more accurate the solution.  The default value
 *                 is '9'.
 *                         <li> gpudb::match_graph_max_solve_length: For the @a
 *                 incremental_weighted solver only. Maximum number of samples
 *                 along the path on which to solve.  The default value is
 *                 '200'.
 *                         <li> gpudb::match_graph_time_window_width: For the
 *                 @a incremental_weighted solver only. Time window, also known
 *                 as sampling period, in which points are favored. To
 *                 determine the raw window value, the @a time_window_width
 *                 value is multiplied by the mean sample time (in seconds)
 *                 across all points, e.g., if @a time_window_width is 30 and
 *                 the mean sample time is 2 seconds, points that are sampled
 *                 greater than 60 seconds after the previous point are no
 *                 longer favored in the solution.  The default value is '30'.
 *                         <li> gpudb::match_graph_detect_loops: For the @a
 *                 incremental_weighted solver only. If @a true, a loop will be
 *                 detected and traversed even if it would make a shorter path
 *                 to ignore the loop.
 *                 <ul>
 *                         <li> gpudb::match_graph_true
 *                         <li> gpudb::match_graph_false
 *                 </ul>
 *                 The default value is gpudb::match_graph_true.
 *                         <li> gpudb::match_graph_source: Optional WKT
 *                 starting point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the starting point.  The default value is 'POINT
 *                 NULL'.
 *                         <li> gpudb::match_graph_destination: Optional WKT
 *                 ending point from @a samplePoints for the solver. The
 *                 default behavior for the endpoint is to use time to
 *                 determine the destination point.  The default value is
 *                 'POINT NULL'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MatchGraphResponse& GPUdb::matchGraph( const std::string& graphName,
                                       const std::vector<std::string>& samplePoints,
                                       const std::string& solveMethod,
                                       const std::string& solutionTable,
                                       const std::map<std::string, std::string>& options,
                                       MatchGraphResponse& response_ ) const
{
    MatchGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.samplePoints = samplePoints;
    actualRequest_.solveMethod = solveMethod;
    actualRequest_.solutionTable = solutionTable;
    actualRequest_.options = options;
    submitRequest("/match/graph", actualRequest_, response_, false);
    return response_;
}


/**
 * Create a new empty result table (specified by @a tableName), and insert all
 * records from source tables (specified by @a sourceTableNames) based on the
 * field mapping information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see <a
 * href="../../concepts/merge_records.html" target="_top">Merge Records</a>.
 * For limitations, see <a
 * href="../../concepts/merge_records.html#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps of
 * target table column names to source table columns. The array of @a fieldMaps
 * must match one-to-one with the @a sourceTableNames, e.g., there's a map
 * present in @a fieldMaps for each table listed in @a sourceTableNames.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MergeRecordsResponse GPUdb::mergeRecords( const MergeRecordsRequest& request_ ) const
{
    MergeRecordsResponse actualResponse_;
    submitRequest("/merge/records", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Create a new empty result table (specified by @a tableName), and insert all
 * records from source tables (specified by @a sourceTableNames) based on the
 * field mapping information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see <a
 * href="../../concepts/merge_records.html" target="_top">Merge Records</a>.
 * For limitations, see <a
 * href="../../concepts/merge_records.html#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps of
 * target table column names to source table columns. The array of @a fieldMaps
 * must match one-to-one with the @a sourceTableNames, e.g., there's a map
 * present in @a fieldMaps for each table listed in @a sourceTableNames.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MergeRecordsResponse& GPUdb::mergeRecords( const MergeRecordsRequest& request_,
                                           MergeRecordsResponse& response_ ) const
{
    submitRequest("/merge/records", request_, response_, false);
    return response_;
}


/**
 * Create a new empty result table (specified by @a tableName), and insert all
 * records from source tables (specified by @a sourceTableNames) based on the
 * field mapping information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see <a
 * href="../../concepts/merge_records.html" target="_top">Merge Records</a>.
 * For limitations, see <a
 * href="../../concepts/merge_records.html#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps of
 * target table column names to source table columns. The array of @a fieldMaps
 * must match one-to-one with the @a sourceTableNames, e.g., there's a map
 * present in @a fieldMaps for each table listed in @a sourceTableNames.
 * 
 * @param tableName  The new result table name for the records to be merged.
 *                   Must NOT be an existing table.
 * @param sourceTableNames  The list of source table names to get the records
 *                          from. Must be existing table names.
 * @param fieldMaps  Contains a list of source/target column mappings, one
 *                   mapping for each source table listed in @a
 *                   sourceTableNames being merged into the target table
 *                   specified by @a tableName.  Each mapping contains the
 *                   target column names (as keys) that the data in the mapped
 *                   source columns or column <a
 *                   href="../../concepts/expressions.html"
 *                   target="_top">expressions</a> (as values) will be merged
 *                   into.  All of the source columns being merged into a given
 *                   target column must match in type, as that type will
 *                   determine the type of the new target column.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::merge_records_collection_name: Name of a
 *                 collection which is to contain the newly created merged
 *                 table specified by @a tableName. If the collection provided
 *                 is non-existent, the collection will be automatically
 *                 created. If empty, then the newly created merged table will
 *                 be a top-level table.
 *                         <li> gpudb::merge_records_is_replicated: Indicates
 *                 the <a href="../../concepts/tables.html#distribution"
 *                 target="_top">distribution scheme</a> for the data of the
 *                 merged table specified in @a tableName.  If true, the table
 *                 will be <a href="../../concepts/tables.html#replication"
 *                 target="_top">replicated</a>.  If false, the table will be
 *                 <a href="../../concepts/tables.html#random-sharding"
 *                 target="_top">randomly sharded</a>.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_false.
 *                         <li> gpudb::merge_records_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 merged table specified in @a tableName.
 *                         <li> gpudb::merge_records_persist: If @a true, then
 *                 the table specified in @a tableName will be persisted and
 *                 will not expire unless a @a ttl is specified.   If @a false,
 *                 then the table will be an in-memory table and will expire
 *                 unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_true.
 *                         <li> gpudb::merge_records_chunk_size: Indicates the
 *                 chunk size to be used for the merged table specified in @a
 *                 tableName.
 *                         <li> gpudb::merge_records_view_id: view this result
 *                 table is part of.  The default value is ''.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

MergeRecordsResponse GPUdb::mergeRecords( const std::string& tableName,
                                          const std::vector<std::string>& sourceTableNames,
                                          const std::vector<std::map<std::string, std::string> >& fieldMaps,
                                          const std::map<std::string, std::string>& options ) const
{
    MergeRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.sourceTableNames = sourceTableNames;
    actualRequest_.fieldMaps = fieldMaps;
    actualRequest_.options = options;
    MergeRecordsResponse actualResponse_;
    submitRequest("/merge/records", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Create a new empty result table (specified by @a tableName), and insert all
 * records from source tables (specified by @a sourceTableNames) based on the
 * field mapping information (specified by @a fieldMaps).
 * <p>
 * For merge records details and examples, see <a
 * href="../../concepts/merge_records.html" target="_top">Merge Records</a>.
 * For limitations, see <a
 * href="../../concepts/merge_records.html#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by @a fieldMaps) holds the user-specified maps of
 * target table column names to source table columns. The array of @a fieldMaps
 * must match one-to-one with the @a sourceTableNames, e.g., there's a map
 * present in @a fieldMaps for each table listed in @a sourceTableNames.
 * 
 * @param tableName  The new result table name for the records to be merged.
 *                   Must NOT be an existing table.
 * @param sourceTableNames  The list of source table names to get the records
 *                          from. Must be existing table names.
 * @param fieldMaps  Contains a list of source/target column mappings, one
 *                   mapping for each source table listed in @a
 *                   sourceTableNames being merged into the target table
 *                   specified by @a tableName.  Each mapping contains the
 *                   target column names (as keys) that the data in the mapped
 *                   source columns or column <a
 *                   href="../../concepts/expressions.html"
 *                   target="_top">expressions</a> (as values) will be merged
 *                   into.  All of the source columns being merged into a given
 *                   target column must match in type, as that type will
 *                   determine the type of the new target column.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::merge_records_collection_name: Name of a
 *                 collection which is to contain the newly created merged
 *                 table specified by @a tableName. If the collection provided
 *                 is non-existent, the collection will be automatically
 *                 created. If empty, then the newly created merged table will
 *                 be a top-level table.
 *                         <li> gpudb::merge_records_is_replicated: Indicates
 *                 the <a href="../../concepts/tables.html#distribution"
 *                 target="_top">distribution scheme</a> for the data of the
 *                 merged table specified in @a tableName.  If true, the table
 *                 will be <a href="../../concepts/tables.html#replication"
 *                 target="_top">replicated</a>.  If false, the table will be
 *                 <a href="../../concepts/tables.html#random-sharding"
 *                 target="_top">randomly sharded</a>.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_false.
 *                         <li> gpudb::merge_records_ttl: Sets the <a
 *                 href="../../concepts/ttl.html" target="_top">TTL</a> of the
 *                 merged table specified in @a tableName.
 *                         <li> gpudb::merge_records_persist: If @a true, then
 *                 the table specified in @a tableName will be persisted and
 *                 will not expire unless a @a ttl is specified.   If @a false,
 *                 then the table will be an in-memory table and will expire
 *                 unless a @a ttl is specified otherwise.
 *                 <ul>
 *                         <li> gpudb::merge_records_true
 *                         <li> gpudb::merge_records_false
 *                 </ul>
 *                 The default value is gpudb::merge_records_true.
 *                         <li> gpudb::merge_records_chunk_size: Indicates the
 *                 chunk size to be used for the merged table specified in @a
 *                 tableName.
 *                         <li> gpudb::merge_records_view_id: view this result
 *                 table is part of.  The default value is ''.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

MergeRecordsResponse& GPUdb::mergeRecords( const std::string& tableName,
                                           const std::vector<std::string>& sourceTableNames,
                                           const std::vector<std::map<std::string, std::string> >& fieldMaps,
                                           const std::map<std::string, std::string>& options,
                                           MergeRecordsResponse& response_ ) const
{
    MergeRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.sourceTableNames = sourceTableNames;
    actualRequest_.fieldMaps = fieldMaps;
    actualRequest_.options = options;
    submitRequest("/merge/records", actualRequest_, response_, false);
    return response_;
}


/**
 * Employs a topological query on a network graph generated a-priori by {@link
 * #createGraph(const CreateGraphRequest&) const} and returns a list of
 * adjacent edge(s) or node(s), also known as an adjacency list, depending on
 * what's been provided to the endpoint; providing edges will return nodes and
 * providing nodes will return edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See <a
 * href="../../graph_solver/network_graph_solver.html#query-identifiers"
 * target="_top">Query Identifiers</a> for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable empty.
 * To return the adjacency list in a table and not in the response, provide a
 * value to @a adjacencyTable and set @a export_query_results to @a false. To
 * return the adjacency list both in a table and the response, provide a value
 * to @a adjacencyTable and set @a export_query_results to @a true.
 * <p>
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solver</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

QueryGraphResponse GPUdb::queryGraph( const QueryGraphRequest& request_ ) const
{
    QueryGraphResponse actualResponse_;
    submitRequest("/query/graph", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Employs a topological query on a network graph generated a-priori by {@link
 * #createGraph(const CreateGraphRequest&,CreateGraphResponse&) const} and
 * returns a list of adjacent edge(s) or node(s), also known as an adjacency
 * list, depending on what's been provided to the endpoint; providing edges
 * will return nodes and providing nodes will return edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See <a
 * href="../../graph_solver/network_graph_solver.html#query-identifiers"
 * target="_top">Query Identifiers</a> for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable empty.
 * To return the adjacency list in a table and not in the response, provide a
 * value to @a adjacencyTable and set @a export_query_results to @a false. To
 * return the adjacency list both in a table and the response, provide a value
 * to @a adjacencyTable and set @a export_query_results to @a true.
 * <p>
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solver</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

QueryGraphResponse& GPUdb::queryGraph( const QueryGraphRequest& request_,
                                       QueryGraphResponse& response_ ) const
{
    submitRequest("/query/graph", request_, response_, false);
    return response_;
}


/**
 * Employs a topological query on a network graph generated a-priori by {@link
 * #createGraph(const std::string&,const bool,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}
 * and returns a list of adjacent edge(s) or node(s), also known as an
 * adjacency list, depending on what's been provided to the endpoint; providing
 * edges will return nodes and providing nodes will return edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See <a
 * href="../../graph_solver/network_graph_solver.html#query-identifiers"
 * target="_top">Query Identifiers</a> for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable empty.
 * To return the adjacency list in a table and not in the response, provide a
 * value to @a adjacencyTable and set @a export_query_results to @a false. To
 * return the adjacency list both in a table and the response, provide a value
 * to @a adjacencyTable and set @a export_query_results to @a true.
 * <p>
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solver</a> for more information.
 * 
 * @param graphName  Name of the graph resource to query.
 * @param queries  Nodes or edges to be queried specified using <a
 *                 href="../../graph_solver/network_graph_solver.html#query-identifiers"
 *                 target="_top">query identifiers</a>. Identifiers can be used
 *                 with existing column names, e.g., 'table.column AS
 *                 QUERY_NODE_ID', raw values, e.g., '{0, 2} AS QUERY_NODE_ID',
 *                 or expressions, e.g., 'ST_MAKEPOINT(table.x, table.y) AS
 *                 QUERY_NODE_WKTPOINT'. Multiple values can be provided as
 *                 long as the same identifier is used for all values. If using
 *                 raw values in an identifier combination, the number of
 *                 values specified must match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 * @param adjacencyTable  Name of the table to store the resulting adjacencies.
 *                        If left blank, the query results are instead returned
 *                        in the response even if @a export_query_results is
 *                        set to @a false. If the 'QUERY_TARGET_NODE_LABEL' <a
 *                        href="../../graph_solver/network_graph_solver.html#query-identifiers"
 *                        target="_top">query identifier</a> is used in @a
 *                        queries, then two additional columns will be
 *                        available: 'PATH_ID' and 'RING_ID'. See
 *                                    <a
 *                        href="../../graph_solver/network_graph_solver.html#using-labels"
 *                        target="_top">Using Labels</a> for more information.
 * @param rings  Only applicable when querying nodes. Sets the number of rings
 *               around the node to query for adjacency, with '1' being the
 *               edges directly attached to the queried node. Also known as
 *               number of hops. For example, if it is set to '2', the edge(s)
 *               directly attached to the queried node(s) will be returned; in
 *               addition, the edge(s) attached to the node(s) attached to the
 *               initial ring of edge(s) surrounding the queried node(s) will
 *               be returned. This setting can be '0' in which case if the node
 *               type id label, it'll then query for all that has the same
 *               property.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::query_graph_force_undirected: This
 *                 parameter is only applicable if the queried graph @a
 *                 graphName is directed and when querying nodes. If set to @a
 *                 true, all inbound edges and outbound edges relative to the
 *                 node will be returned. If set to @a false, only outbound
 *                 edges relative to the node will be returned.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_limit: When specified,
 *                 limits the number of query results. Note that if the @a
 *                 target_nodes_table is provided, the size of the
 *                 corresponding table will be limited by the @a limit value.
 *                 The default value is an empty std::map.
 *                         <li> gpudb::query_graph_target_nodes_table: Name of
 *                 the table to store the list of the final nodes reached
 *                 during the traversal. If this value is not given it'll
 *                 default to adjacemcy_table+'_nodes'.  The default value is
 *                 ''.
 *                         <li> gpudb::query_graph_restriction_threshold_value:
 *                 Value-based restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 solution.
 *                         <li> gpudb::query_graph_export_query_results:
 *                 Returns query results in the response. If set to @a true,
 *                 the @a adjacencyListIntArray (if the query was based on
 *                 IDs), @{adjacency_list_string_array} (if the query was based
 *                 on names), or @{output_adjacency_list_wkt_array} (if the
 *                 query was based on WKTs) will be populated with the results.
 *                 If set to @a false, none of the arrays will be populated.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_enable_graph_draw: If set to
 *                 @a true, adds a WKT-type column named 'QUERY_EDGE_WKTLINE'
 *                 to the given @a adjacencyTable and inputs WKT values from
 *                 the source graph (if available) or auto-generated WKT values
 *                 (if there are no WKT values in the source graph). A
 *                 subsequent call to the <a
 *                 href="../../api/rest/wms_rest.html" target="_top">/wms</a>
 *                 endpoint can then be made to display the query results on a
 *                 map.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_and_labels: If set to @a
 *                 true, the result of the query has entities that satisfy all
 *                 of the target labels, instead of any.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

QueryGraphResponse GPUdb::queryGraph( const std::string& graphName,
                                      const std::vector<std::string>& queries,
                                      const std::vector<std::string>& restrictions,
                                      const std::string& adjacencyTable,
                                      const int32_t rings,
                                      const std::map<std::string, std::string>& options ) const
{
    QueryGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.queries = queries;
    actualRequest_.restrictions = restrictions;
    actualRequest_.adjacencyTable = adjacencyTable;
    actualRequest_.rings = rings;
    actualRequest_.options = options;
    QueryGraphResponse actualResponse_;
    submitRequest("/query/graph", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Employs a topological query on a network graph generated a-priori by {@link
 * #createGraph(const std::string&,const bool,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::vector<std::string>&,const std::map<std::string, std::string>&,CreateGraphResponse&) const}
 * and returns a list of adjacent edge(s) or node(s), also known as an
 * adjacency list, depending on what's been provided to the endpoint; providing
 * edges will return nodes and providing nodes will return edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to @a queries. This field can be populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See <a
 * href="../../graph_solver/network_graph_solver.html#query-identifiers"
 * target="_top">Query Identifiers</a> for more information.
 * <p>
 * To return the adjacency list in the response, leave @a adjacencyTable empty.
 * To return the adjacency list in a table and not in the response, provide a
 * value to @a adjacencyTable and set @a export_query_results to @a false. To
 * return the adjacency list both in a table and the response, provide a value
 * to @a adjacencyTable and set @a export_query_results to @a true.
 * <p>
 * See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solver</a> for more information.
 * 
 * @param graphName  Name of the graph resource to query.
 * @param queries  Nodes or edges to be queried specified using <a
 *                 href="../../graph_solver/network_graph_solver.html#query-identifiers"
 *                 target="_top">query identifiers</a>. Identifiers can be used
 *                 with existing column names, e.g., 'table.column AS
 *                 QUERY_NODE_ID', raw values, e.g., '{0, 2} AS QUERY_NODE_ID',
 *                 or expressions, e.g., 'ST_MAKEPOINT(table.x, table.y) AS
 *                 QUERY_NODE_WKTPOINT'. Multiple values can be provided as
 *                 long as the same identifier is used for all values. If using
 *                 raw values in an identifier combination, the number of
 *                 values specified must match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination.
 * @param adjacencyTable  Name of the table to store the resulting adjacencies.
 *                        If left blank, the query results are instead returned
 *                        in the response even if @a export_query_results is
 *                        set to @a false. If the 'QUERY_TARGET_NODE_LABEL' <a
 *                        href="../../graph_solver/network_graph_solver.html#query-identifiers"
 *                        target="_top">query identifier</a> is used in @a
 *                        queries, then two additional columns will be
 *                        available: 'PATH_ID' and 'RING_ID'. See
 *                                    <a
 *                        href="../../graph_solver/network_graph_solver.html#using-labels"
 *                        target="_top">Using Labels</a> for more information.
 * @param rings  Only applicable when querying nodes. Sets the number of rings
 *               around the node to query for adjacency, with '1' being the
 *               edges directly attached to the queried node. Also known as
 *               number of hops. For example, if it is set to '2', the edge(s)
 *               directly attached to the queried node(s) will be returned; in
 *               addition, the edge(s) attached to the node(s) attached to the
 *               initial ring of edge(s) surrounding the queried node(s) will
 *               be returned. This setting can be '0' in which case if the node
 *               type id label, it'll then query for all that has the same
 *               property.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::query_graph_force_undirected: This
 *                 parameter is only applicable if the queried graph @a
 *                 graphName is directed and when querying nodes. If set to @a
 *                 true, all inbound edges and outbound edges relative to the
 *                 node will be returned. If set to @a false, only outbound
 *                 edges relative to the node will be returned.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_limit: When specified,
 *                 limits the number of query results. Note that if the @a
 *                 target_nodes_table is provided, the size of the
 *                 corresponding table will be limited by the @a limit value.
 *                 The default value is an empty std::map.
 *                         <li> gpudb::query_graph_target_nodes_table: Name of
 *                 the table to store the list of the final nodes reached
 *                 during the traversal. If this value is not given it'll
 *                 default to adjacemcy_table+'_nodes'.  The default value is
 *                 ''.
 *                         <li> gpudb::query_graph_restriction_threshold_value:
 *                 Value-based restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 solution.
 *                         <li> gpudb::query_graph_export_query_results:
 *                 Returns query results in the response. If set to @a true,
 *                 the @a adjacencyListIntArray (if the query was based on
 *                 IDs), @{adjacency_list_string_array} (if the query was based
 *                 on names), or @{output_adjacency_list_wkt_array} (if the
 *                 query was based on WKTs) will be populated with the results.
 *                 If set to @a false, none of the arrays will be populated.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_enable_graph_draw: If set to
 *                 @a true, adds a WKT-type column named 'QUERY_EDGE_WKTLINE'
 *                 to the given @a adjacencyTable and inputs WKT values from
 *                 the source graph (if available) or auto-generated WKT values
 *                 (if there are no WKT values in the source graph). A
 *                 subsequent call to the <a
 *                 href="../../api/rest/wms_rest.html" target="_top">/wms</a>
 *                 endpoint can then be made to display the query results on a
 *                 map.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                         <li> gpudb::query_graph_and_labels: If set to @a
 *                 true, the result of the query has entities that satisfy all
 *                 of the target labels, instead of any.
 *                 <ul>
 *                         <li> gpudb::query_graph_true
 *                         <li> gpudb::query_graph_false
 *                 </ul>
 *                 The default value is gpudb::query_graph_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

QueryGraphResponse& GPUdb::queryGraph( const std::string& graphName,
                                       const std::vector<std::string>& queries,
                                       const std::vector<std::string>& restrictions,
                                       const std::string& adjacencyTable,
                                       const int32_t rings,
                                       const std::map<std::string, std::string>& options,
                                       QueryGraphResponse& response_ ) const
{
    QueryGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.queries = queries;
    actualRequest_.restrictions = restrictions;
    actualRequest_.adjacencyTable = adjacencyTable;
    actualRequest_.rings = rings;
    actualRequest_.options = options;
    submitRequest("/query/graph", actualRequest_, response_, false);
    return response_;
}


/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionProcResponse GPUdb::revokePermissionProc( const RevokePermissionProcRequest& request_ ) const
{
    RevokePermissionProcResponse actualResponse_;
    submitRequest("/revoke/permission/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionProcResponse& GPUdb::revokePermissionProc( const RevokePermissionProcRequest& request_,
                                                           RevokePermissionProcResponse& response_ ) const
{
    submitRequest("/revoke/permission/proc", request_, response_, false);
    return response_;
}


/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string if the
 *                  permission grants access to all procs.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionProcResponse GPUdb::revokePermissionProc( const std::string& name,
                                                          const std::string& permission,
                                                          const std::string& procName,
                                                          const std::map<std::string, std::string>& options ) const
{
    RevokePermissionProcRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    RevokePermissionProcResponse actualResponse_;
    submitRequest("/revoke/permission/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a proc-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_proc_proc_execute:
 *                    Execute access to the proc.
 *                    </ul>
 * @param procName  Name of the proc to which the permission grants access.
 *                  Must be an existing proc, or an empty string if the
 *                  permission grants access to all procs.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionProcResponse& GPUdb::revokePermissionProc( const std::string& name,
                                                           const std::string& permission,
                                                           const std::string& procName,
                                                           const std::map<std::string, std::string>& options,
                                                           RevokePermissionProcResponse& response_ ) const
{
    RevokePermissionProcRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/revoke/permission/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionSystemResponse GPUdb::revokePermissionSystem( const RevokePermissionSystemRequest& request_ ) const
{
    RevokePermissionSystemResponse actualResponse_;
    submitRequest("/revoke/permission/system", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionSystemResponse& GPUdb::revokePermissionSystem( const RevokePermissionSystemRequest& request_,
                                                               RevokePermissionSystemResponse& response_ ) const
{
    submitRequest("/revoke/permission/system", request_, response_, false);
    return response_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_system_system_admin: Full access
 *                    to all data and system functions.
 *                            <li>
 *                    gpudb::revoke_permission_system_system_write: Read and
 *                    write access to all tables.
 *                            <li> gpudb::revoke_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionSystemResponse GPUdb::revokePermissionSystem( const std::string& name,
                                                              const std::string& permission,
                                                              const std::map<std::string, std::string>& options ) const
{
    RevokePermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    RevokePermissionSystemResponse actualResponse_;
    submitRequest("/revoke/permission/system", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li>
 *                    gpudb::revoke_permission_system_system_admin: Full access
 *                    to all data and system functions.
 *                            <li>
 *                    gpudb::revoke_permission_system_system_write: Read and
 *                    write access to all tables.
 *                            <li> gpudb::revoke_permission_system_system_read:
 *                    Read-only access to all tables.
 *                    </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionSystemResponse& GPUdb::revokePermissionSystem( const std::string& name,
                                                               const std::string& permission,
                                                               const std::map<std::string, std::string>& options,
                                                               RevokePermissionSystemResponse& response_ ) const
{
    RevokePermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    submitRequest("/revoke/permission/system", actualRequest_, response_, false);
    return response_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionTableResponse GPUdb::revokePermissionTable( const RevokePermissionTableRequest& request_ ) const
{
    RevokePermissionTableResponse actualResponse_;
    submitRequest("/revoke/permission/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionTableResponse& GPUdb::revokePermissionTable( const RevokePermissionTableRequest& request_,
                                                             RevokePermissionTableResponse& response_ ) const
{
    submitRequest("/revoke/permission/table", request_, response_, false);
    return response_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::revoke_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::revoke_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::revoke_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::revoke_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionTableResponse GPUdb::revokePermissionTable( const std::string& name,
                                                            const std::string& permission,
                                                            const std::string& tableName,
                                                            const std::map<std::string, std::string>& options ) const
{
    RevokePermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    RevokePermissionTableResponse actualResponse_;
    submitRequest("/revoke/permission/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role.
 *                    <ul>
 *                            <li> gpudb::revoke_permission_table_table_admin:
 *                    Full read/write and administrative access to the table.
 *                            <li> gpudb::revoke_permission_table_table_insert:
 *                    Insert access to the table.
 *                            <li> gpudb::revoke_permission_table_table_update:
 *                    Update access to the table.
 *                            <li> gpudb::revoke_permission_table_table_delete:
 *                    Delete access to the table.
 *                            <li> gpudb::revoke_permission_table_table_read:
 *                    Read access to the table.
 *                    </ul>
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionTableResponse& GPUdb::revokePermissionTable( const std::string& name,
                                                             const std::string& permission,
                                                             const std::string& tableName,
                                                             const std::map<std::string, std::string>& options,
                                                             RevokePermissionTableResponse& response_ ) const
{
    RevokePermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/revoke/permission/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokeRoleResponse GPUdb::revokeRole( const RevokeRoleRequest& request_ ) const
{
    RevokeRoleResponse actualResponse_;
    submitRequest("/revoke/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokeRoleResponse& GPUdb::revokeRole( const RevokeRoleRequest& request_,
                                       RevokeRoleResponse& response_ ) const
{
    submitRequest("/revoke/role", request_, response_, false);
    return response_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param role  Name of the role in which membership will be revoked. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be revoked membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokeRoleResponse GPUdb::revokeRole( const std::string& role,
                                      const std::string& member,
                                      const std::map<std::string, std::string>& options ) const
{
    RevokeRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    RevokeRoleResponse actualResponse_;
    submitRequest("/revoke/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param role  Name of the role in which membership will be revoked. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be revoked membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokeRoleResponse& GPUdb::revokeRole( const std::string& role,
                                       const std::string& member,
                                       const std::map<std::string, std::string>& options,
                                       RevokeRoleResponse& response_ ) const
{
    RevokeRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    submitRequest("/revoke/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Shows information and characteristics of graphs that exist on the graph
 * server, depending on the options specified.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowGraphResponse GPUdb::showGraph( const ShowGraphRequest& request_ ) const
{
    ShowGraphResponse actualResponse_;
    submitRequest("/show/graph", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows information and characteristics of graphs that exist on the graph
 * server, depending on the options specified.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowGraphResponse& GPUdb::showGraph( const ShowGraphRequest& request_,
                                     ShowGraphResponse& response_ ) const
{
    submitRequest("/show/graph", request_, response_, false);
    return response_;
}


/**
 * Shows information and characteristics of graphs that exist on the graph
 * server, depending on the options specified.
 * 
 * @param graphName  Name of the graph on which to retrieve information. If
 *                   empty, information about all graphs is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_graph_show_original_request: If set
 *                 to @a true, the request that was originally used.
 *                 <ul>
 *                         <li> gpudb::show_graph_true
 *                         <li> gpudb::show_graph_false
 *                 </ul>
 *                 The default value is gpudb::show_graph_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowGraphResponse GPUdb::showGraph( const std::string& graphName,
                                    const std::map<std::string, std::string>& options ) const
{
    ShowGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.options = options;
    ShowGraphResponse actualResponse_;
    submitRequest("/show/graph", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows information and characteristics of graphs that exist on the graph
 * server, depending on the options specified.
 * 
 * @param graphName  Name of the graph on which to retrieve information. If
 *                   empty, information about all graphs is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_graph_show_original_request: If set
 *                 to @a true, the request that was originally used.
 *                 <ul>
 *                         <li> gpudb::show_graph_true
 *                         <li> gpudb::show_graph_false
 *                 </ul>
 *                 The default value is gpudb::show_graph_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowGraphResponse& GPUdb::showGraph( const std::string& graphName,
                                     const std::map<std::string, std::string>& options,
                                     ShowGraphResponse& response_ ) const
{
    ShowGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.options = options;
    submitRequest("/show/graph", actualRequest_, response_, false);
    return response_;
}


/**
 * Shows information about a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcResponse GPUdb::showProc( const ShowProcRequest& request_ ) const
{
    ShowProcResponse actualResponse_;
    submitRequest("/show/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows information about a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcResponse& GPUdb::showProc( const ShowProcRequest& request_,
                                   ShowProcResponse& response_ ) const
{
    submitRequest("/show/proc", request_, response_, false);
    return response_;
}


/**
 * Shows information about a proc.
 * 
 * @param procName  Name of the proc to show information about. If specified,
 *                  must be the name of a currently existing proc. If not
 *                  specified, information about all procs will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_include_files: If set to @a
 *                 true, the files that make up the proc will be returned. If
 *                 set to @a false, the files will not be returned.
 *                 <ul>
 *                         <li> gpudb::show_proc_true
 *                         <li> gpudb::show_proc_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcResponse GPUdb::showProc( const std::string& procName,
                                  const std::map<std::string, std::string>& options ) const
{
    ShowProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    ShowProcResponse actualResponse_;
    submitRequest("/show/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows information about a proc.
 * 
 * @param procName  Name of the proc to show information about. If specified,
 *                  must be the name of a currently existing proc. If not
 *                  specified, information about all procs will be returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_include_files: If set to @a
 *                 true, the files that make up the proc will be returned. If
 *                 set to @a false, the files will not be returned.
 *                 <ul>
 *                         <li> gpudb::show_proc_true
 *                         <li> gpudb::show_proc_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcResponse& GPUdb::showProc( const std::string& procName,
                                   const std::map<std::string, std::string>& options,
                                   ShowProcResponse& response_ ) const
{
    ShowProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/show/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const ExecuteProcRequest&) const}) and data segment ID
 * (each invocation of the proc command on a data segment is assigned a data
 * segment ID).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcStatusResponse GPUdb::showProcStatus( const ShowProcStatusRequest& request_ ) const
{
    ShowProcStatusResponse actualResponse_;
    submitRequest("/show/proc/status", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const ExecuteProcRequest&,ExecuteProcResponse&) const}) and
 * data segment ID (each invocation of the proc command on a data segment is
 * assigned a data segment ID).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcStatusResponse& GPUdb::showProcStatus( const ShowProcStatusRequest& request_,
                                               ShowProcStatusResponse& response_ ) const
{
    submitRequest("/show/proc/status", request_, response_, false);
    return response_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const std::string&,const std::map<std::string, std::string>&,const std::map<std::string, std::vector<uint8_t> >&,const std::vector<std::string>&,const std::map<std::string, std::vector<std::string> >&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const})
 * and data segment ID (each invocation of the proc command on a data segment
 * is assigned a data segment ID).
 * 
 * @param runId  The run ID of a specific running or completed proc instance
 *               for which the status will be returned. If the run ID is not
 *               found, nothing will be returned. If not specified, the
 *               statuses of all running and completed proc instances will be
 *               returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_clear_complete: If set
 *                 to @a true, if a proc instance has completed (either
 *                 successfully or unsuccessfully) then its status will be
 *                 cleared and no longer returned in subsequent calls.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_true
 *                         <li> gpudb::show_proc_status_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_status_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcStatusResponse GPUdb::showProcStatus( const std::string& runId,
                                              const std::map<std::string, std::string>& options ) const
{
    ShowProcStatusRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    ShowProcStatusResponse actualResponse_;
    submitRequest("/show/proc/status", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const std::string&,const std::map<std::string, std::string>&,const std::map<std::string, std::vector<uint8_t> >&,const std::vector<std::string>&,const std::map<std::string, std::vector<std::string> >&,const std::vector<std::string>&,const std::map<std::string, std::string>&,ExecuteProcResponse&) const})
 * and data segment ID (each invocation of the proc command on a data segment
 * is assigned a data segment ID).
 * 
 * @param runId  The run ID of a specific running or completed proc instance
 *               for which the status will be returned. If the run ID is not
 *               found, nothing will be returned. If not specified, the
 *               statuses of all running and completed proc instances will be
 *               returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_clear_complete: If set
 *                 to @a true, if a proc instance has completed (either
 *                 successfully or unsuccessfully) then its status will be
 *                 cleared and no longer returned in subsequent calls.
 *                 <ul>
 *                         <li> gpudb::show_proc_status_true
 *                         <li> gpudb::show_proc_status_false
 *                 </ul>
 *                 The default value is gpudb::show_proc_status_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcStatusResponse& GPUdb::showProcStatus( const std::string& runId,
                                               const std::map<std::string, std::string>& options,
                                               ShowProcStatusResponse& response_ ) const
{
    ShowProcStatusRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    submitRequest("/show/proc/status", actualRequest_, response_, false);
    return response_;
}


/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceStatisticsResponse GPUdb::showResourceStatistics( const ShowResourceStatisticsRequest& request_ ) const
{
    ShowResourceStatisticsResponse actualResponse_;
    submitRequest("/show/resource/statistics", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceStatisticsResponse& GPUdb::showResourceStatistics( const ShowResourceStatisticsRequest& request_,
                                                               ShowResourceStatisticsResponse& response_ ) const
{
    submitRequest("/show/resource/statistics", request_, response_, false);
    return response_;
}


/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceStatisticsResponse GPUdb::showResourceStatistics( const std::map<std::string, std::string>& options ) const
{
    ShowResourceStatisticsRequest actualRequest_;
    actualRequest_.options = options;
    ShowResourceStatisticsResponse actualResponse_;
    submitRequest("/show/resource/statistics", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 * 
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceStatisticsResponse& GPUdb::showResourceStatistics( const std::map<std::string, std::string>& options,
                                                               ShowResourceStatisticsResponse& response_ ) const
{
    ShowResourceStatisticsRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/show/resource/statistics", actualRequest_, response_, false);
    return response_;
}


/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceGroupsResponse GPUdb::showResourceGroups( const ShowResourceGroupsRequest& request_ ) const
{
    ShowResourceGroupsResponse actualResponse_;
    submitRequest("/show/resourcegroups", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceGroupsResponse& GPUdb::showResourceGroups( const ShowResourceGroupsRequest& request_,
                                                       ShowResourceGroupsResponse& response_ ) const
{
    submitRequest("/show/resourcegroups", request_, response_, false);
    return response_;
}


/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param names  List of names of groups to be shown. A single entry with an
 *               empty string returns all groups.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::show_resource_groups_show_default_values: If @a true
 *                 include values of fields that are based on the default
 *                 resource group.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                         <li> gpudb::show_resource_groups_show_default_group:
 *                 If @a true include the default resource group in the
 *                 response.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowResourceGroupsResponse GPUdb::showResourceGroups( const std::vector<std::string>& names,
                                                      const std::map<std::string, std::string>& options ) const
{
    ShowResourceGroupsRequest actualRequest_;
    actualRequest_.names = names;
    actualRequest_.options = options;
    ShowResourceGroupsResponse actualResponse_;
    submitRequest("/show/resourcegroups", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 * 
 * @param names  List of names of groups to be shown. A single entry with an
 *               empty string returns all groups.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li>
 *                 gpudb::show_resource_groups_show_default_values: If @a true
 *                 include values of fields that are based on the default
 *                 resource group.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                         <li> gpudb::show_resource_groups_show_default_group:
 *                 If @a true include the default resource group in the
 *                 response.
 *                 <ul>
 *                         <li> gpudb::show_resource_groups_true
 *                         <li> gpudb::show_resource_groups_false
 *                 </ul>
 *                 The default value is gpudb::show_resource_groups_true.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowResourceGroupsResponse& GPUdb::showResourceGroups( const std::vector<std::string>& names,
                                                       const std::map<std::string, std::string>& options,
                                                       ShowResourceGroupsResponse& response_ ) const
{
    ShowResourceGroupsRequest actualRequest_;
    actualRequest_.names = names;
    actualRequest_.options = options;
    submitRequest("/show/resourcegroups", actualRequest_, response_, false);
    return response_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSecurityResponse GPUdb::showSecurity( const ShowSecurityRequest& request_ ) const
{
    ShowSecurityResponse actualResponse_;
    submitRequest("/show/security", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSecurityResponse& GPUdb::showSecurity( const ShowSecurityRequest& request_,
                                           ShowSecurityResponse& response_ ) const
{
    submitRequest("/show/security", request_, response_, false);
    return response_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param names  A list of names of users and/or roles about which security
 *               information is requested. If none are provided, information
 *               about all users and roles will be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSecurityResponse GPUdb::showSecurity( const std::vector<std::string>& names,
                                          const std::map<std::string, std::string>& options ) const
{
    ShowSecurityRequest actualRequest_;
    actualRequest_.names = names;
    actualRequest_.options = options;
    ShowSecurityResponse actualResponse_;
    submitRequest("/show/security", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param names  A list of names of users and/or roles about which security
 *               information is requested. If none are provided, information
 *               about all users and roles will be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSecurityResponse& GPUdb::showSecurity( const std::vector<std::string>& names,
                                           const std::map<std::string, std::string>& options,
                                           ShowSecurityResponse& response_ ) const
{
    ShowSecurityRequest actualRequest_;
    actualRequest_.names = names;
    actualRequest_.options = options;
    submitRequest("/show/security", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves the collected column statistics for the specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowStatisticsResponse GPUdb::showStatistics( const ShowStatisticsRequest& request_ ) const
{
    ShowStatisticsResponse actualResponse_;
    submitRequest("/show/statistics", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the collected column statistics for the specified table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowStatisticsResponse& GPUdb::showStatistics( const ShowStatisticsRequest& request_,
                                               ShowStatisticsResponse& response_ ) const
{
    submitRequest("/show/statistics", request_, response_, false);
    return response_;
}


/**
 * Retrieves the collected column statistics for the specified table.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowStatisticsResponse GPUdb::showStatistics( const std::vector<std::string>& tableNames,
                                              const std::map<std::string, std::string>& options ) const
{
    ShowStatisticsRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    ShowStatisticsResponse actualResponse_;
    submitRequest("/show/statistics", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the collected column statistics for the specified table.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowStatisticsResponse& GPUdb::showStatistics( const std::vector<std::string>& tableNames,
                                               const std::map<std::string, std::string>& options,
                                               ShowStatisticsResponse& response_ ) const
{
    ShowStatisticsRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    submitRequest("/show/statistics", actualRequest_, response_, false);
    return response_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse GPUdb::showSystemProperties( const ShowSystemPropertiesRequest& request_ ) const
{
    ShowSystemPropertiesResponse actualResponse_;
    submitRequest("/show/system/properties", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& GPUdb::showSystemProperties( const ShowSystemPropertiesRequest& request_,
                                                           ShowSystemPropertiesResponse& response_ ) const
{
    submitRequest("/show/system/properties", request_, response_, false);
    return response_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_system_properties_properties: A
 *                 list of comma separated names of properties requested. If
 *                 not specified, all properties will be returned.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse GPUdb::showSystemProperties( const std::map<std::string, std::string>& options ) const
{
    ShowSystemPropertiesRequest actualRequest_;
    actualRequest_.options = options;
    ShowSystemPropertiesResponse actualResponse_;
    submitRequest("/show/system/properties", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_system_properties_properties: A
 *                 list of comma separated names of properties requested. If
 *                 not specified, all properties will be returned.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& GPUdb::showSystemProperties( const std::map<std::string, std::string>& options,
                                                           ShowSystemPropertiesResponse& response_ ) const
{
    ShowSystemPropertiesRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/show/system/properties", actualRequest_, response_, false);
    return response_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse GPUdb::showSystemStatus( const ShowSystemStatusRequest& request_ ) const
{
    ShowSystemStatusResponse actualResponse_;
    submitRequest("/show/system/status", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& GPUdb::showSystemStatus( const ShowSystemStatusRequest& request_,
                                                   ShowSystemStatusResponse& response_ ) const
{
    submitRequest("/show/system/status", request_, response_, false);
    return response_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse GPUdb::showSystemStatus( const std::map<std::string, std::string>& options ) const
{
    ShowSystemStatusRequest actualRequest_;
    actualRequest_.options = options;
    ShowSystemStatusResponse actualResponse_;
    submitRequest("/show/system/status", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& GPUdb::showSystemStatus( const std::map<std::string, std::string>& options,
                                                   ShowSystemStatusResponse& response_ ) const
{
    ShowSystemStatusRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/show/system/status", actualRequest_, response_, false);
    return response_;
}


/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse GPUdb::showSystemTiming( const ShowSystemTimingRequest& request_ ) const
{
    ShowSystemTimingResponse actualResponse_;
    submitRequest("/show/system/timing", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& GPUdb::showSystemTiming( const ShowSystemTimingRequest& request_,
                                                   ShowSystemTimingResponse& response_ ) const
{
    submitRequest("/show/system/timing", request_, response_, false);
    return response_;
}


/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse GPUdb::showSystemTiming( const std::map<std::string, std::string>& options ) const
{
    ShowSystemTimingRequest actualRequest_;
    actualRequest_.options = options;
    ShowSystemTimingResponse actualResponse_;
    submitRequest("/show/system/timing", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& GPUdb::showSystemTiming( const std::map<std::string, std::string>& options,
                                                   ShowSystemTimingResponse& response_ ) const
{
    ShowSystemTimingRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/show/system/timing", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and collection in the database, set
 * @a tableName to '*' and @a show_children to @a true.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse GPUdb::showTable( const ShowTableRequest& request_ ) const
{
    ShowTableResponse actualResponse_;
    submitRequest("/show/table", request_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.typeLabels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and collection in the database, set
 * @a tableName to '*' and @a show_children to @a true.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& GPUdb::showTable( const ShowTableRequest& request_,
                                     ShowTableResponse& response_ ) const
{
    submitRequest("/show/table", request_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.typeLabels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and collection in the database, set
 * @a tableName to '*' and @a show_children to @a true.
 * 
 * @param tableName  Name of the table for which to retrieve the information.
 *                   If blank, then information about all collections and
 *                   top-level tables and views is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_table_force_synchronous: If @a true
 *                 then the table sizes will wait for read lock before
 *                 returning.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_get_sizes: If @a true then
 *                 the table sizes will be returned; blank, otherwise.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_show_children: If @a
 *                 tableName is a collection, then @a true will return
 *                 information about the children of the collection, and @a
 *                 false will return information about the collection itself.
 *                 If @a tableName is a table or view, @a show_children must be
 *                 @a false. If @a tableName is empty, then @a show_children
 *                 must be @a true.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_no_error_if_not_exists: If @a
 *                 false will return an error if the provided @a tableName does
 *                 not exist. If @a true then it will return an empty result.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_get_column_info: If @a true
 *                 then column info (memory usage, etc) will be returned.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse GPUdb::showTable( const std::string& tableName,
                                    const std::map<std::string, std::string>& options ) const
{
    ShowTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    ShowTableResponse actualResponse_;
    submitRequest("/show/table", actualRequest_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.typeLabels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and collection in the database, set
 * @a tableName to '*' and @a show_children to @a true.
 * 
 * @param tableName  Name of the table for which to retrieve the information.
 *                   If blank, then information about all collections and
 *                   top-level tables and views is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_table_force_synchronous: If @a true
 *                 then the table sizes will wait for read lock before
 *                 returning.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_get_sizes: If @a true then
 *                 the table sizes will be returned; blank, otherwise.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_show_children: If @a
 *                 tableName is a collection, then @a true will return
 *                 information about the children of the collection, and @a
 *                 false will return information about the collection itself.
 *                 If @a tableName is a table or view, @a show_children must be
 *                 @a false. If @a tableName is empty, then @a show_children
 *                 must be @a true.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_true.
 *                         <li> gpudb::show_table_no_error_if_not_exists: If @a
 *                 false will return an error if the provided @a tableName does
 *                 not exist. If @a true then it will return an empty result.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                         <li> gpudb::show_table_get_column_info: If @a true
 *                 then column info (memory usage, etc) will be returned.
 *                 <ul>
 *                         <li> gpudb::show_table_true
 *                         <li> gpudb::show_table_false
 *                 </ul>
 *                 The default value is gpudb::show_table_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& GPUdb::showTable( const std::string& tableName,
                                     const std::map<std::string, std::string>& options,
                                     ShowTableResponse& response_ ) const
{
    ShowTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/show/table", actualRequest_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.typeLabels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse GPUdb::showTableMetadata( const ShowTableMetadataRequest& request_ ) const
{
    ShowTableMetadataResponse actualResponse_;
    submitRequest("/show/table/metadata", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& GPUdb::showTableMetadata( const ShowTableMetadataRequest& request_,
                                                     ShowTableMetadataResponse& response_ ) const
{
    submitRequest("/show/table/metadata", request_, response_, false);
    return response_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse GPUdb::showTableMetadata( const std::vector<std::string>& tableNames,
                                                    const std::map<std::string, std::string>& options ) const
{
    ShowTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    ShowTableMetadataResponse actualResponse_;
    submitRequest("/show/table/metadata", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist, or an error is returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& GPUdb::showTableMetadata( const std::vector<std::string>& tableNames,
                                                     const std::map<std::string, std::string>& options,
                                                     ShowTableMetadataResponse& response_ ) const
{
    ShowTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    submitRequest("/show/table/metadata", actualRequest_, response_, false);
    return response_;
}


/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse GPUdb::showTablesByType( const ShowTablesByTypeRequest& request_ ) const
{
    ShowTablesByTypeResponse actualResponse_;
    submitRequest("/show/tables/bytype", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& GPUdb::showTablesByType( const ShowTablesByTypeRequest& request_,
                                                   ShowTablesByTypeResponse& response_ ) const
{
    submitRequest("/show/tables/bytype", request_, response_, false);
    return response_;
}


/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse GPUdb::showTablesByType( const std::string& typeId,
                                                  const std::string& label,
                                                  const std::map<std::string, std::string>& options ) const
{
    ShowTablesByTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    ShowTablesByTypeResponse actualResponse_;
    submitRequest("/show/tables/bytype", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& GPUdb::showTablesByType( const std::string& typeId,
                                                   const std::string& label,
                                                   const std::map<std::string, std::string>& options,
                                                   ShowTablesByTypeResponse& response_ ) const
{
    ShowTablesByTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    submitRequest("/show/tables/bytype", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse GPUdb::showTriggers( const ShowTriggersRequest& request_ ) const
{
    ShowTriggersResponse actualResponse_;
    submitRequest("/show/triggers", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& GPUdb::showTriggers( const ShowTriggersRequest& request_,
                                           ShowTriggersResponse& response_ ) const
{
    submitRequest("/show/triggers", request_, response_, false);
    return response_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param triggerIds  List of IDs of the triggers whose information is to be
 *                    retrieved. An empty list means information will be
 *                    retrieved on all active triggers.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse GPUdb::showTriggers( const std::vector<std::string>& triggerIds,
                                          const std::map<std::string, std::string>& options ) const
{
    ShowTriggersRequest actualRequest_;
    actualRequest_.triggerIds = triggerIds;
    actualRequest_.options = options;
    ShowTriggersResponse actualResponse_;
    submitRequest("/show/triggers", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 * 
 * @param triggerIds  List of IDs of the triggers whose information is to be
 *                    retrieved. An empty list means information will be
 *                    retrieved on all active triggers.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& GPUdb::showTriggers( const std::vector<std::string>& triggerIds,
                                           const std::map<std::string, std::string>& options,
                                           ShowTriggersResponse& response_ ) const
{
    ShowTriggersRequest actualRequest_;
    actualRequest_.triggerIds = triggerIds;
    actualRequest_.options = options;
    submitRequest("/show/triggers", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse GPUdb::showTypes( const ShowTypesRequest& request_ ) const
{
    ShowTypesResponse actualResponse_;
    submitRequest("/show/types", request_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.labels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& GPUdb::showTypes( const ShowTypesRequest& request_,
                                     ShowTypesResponse& response_ ) const
{
    submitRequest("/show/types", request_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.labels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_types_no_join_types: When set to
 *                 'true', no join types will be included.
 *                 <ul>
 *                         <li> gpudb::show_types_true
 *                         <li> gpudb::show_types_false
 *                 </ul>
 *                 The default value is gpudb::show_types_false.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse GPUdb::showTypes( const std::string& typeId,
                                    const std::string& label,
                                    const std::map<std::string, std::string>& options ) const
{
    ShowTypesRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    ShowTypesResponse actualResponse_;
    submitRequest("/show/types", actualRequest_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.labels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> gpudb::show_types_no_join_types: When set to
 *                 'true', no join types will be included.
 *                 <ul>
 *                         <li> gpudb::show_types_true
 *                         <li> gpudb::show_types_false
 *                 </ul>
 *                 The default value is gpudb::show_types_false.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& GPUdb::showTypes( const std::string& typeId,
                                     const std::string& label,
                                     const std::map<std::string, std::string>& options,
                                     ShowTypesResponse& response_ ) const
{
    ShowTypesRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    submitRequest("/show/types", actualRequest_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.labels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Solves an existing graph for a type of problem (e.g., shortest path, page
 * rank, travelling salesman, etc.) using source nodes, destination nodes, and
 * additional, optional weights and restrictions. See <a
 * href="../../graph_solver/network_graph_solver.html" target="_top">Network
 * Graph Solvers</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

SolveGraphResponse GPUdb::solveGraph( const SolveGraphRequest& request_ ) const
{
    SolveGraphResponse actualResponse_;
    submitRequest("/solve/graph", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Solves an existing graph for a type of problem (e.g., shortest path, page
 * rank, travelling salesman, etc.) using source nodes, destination nodes, and
 * additional, optional weights and restrictions. See <a
 * href="../../graph_solver/network_graph_solver.html" target="_top">Network
 * Graph Solvers</a> for more information.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

SolveGraphResponse& GPUdb::solveGraph( const SolveGraphRequest& request_,
                                       SolveGraphResponse& response_ ) const
{
    submitRequest("/solve/graph", request_, response_, false);
    return response_;
}


/**
 * Solves an existing graph for a type of problem (e.g., shortest path, page
 * rank, travelling salesman, etc.) using source nodes, destination nodes, and
 * additional, optional weights and restrictions. See <a
 * href="../../graph_solver/network_graph_solver.html" target="_top">Network
 * Graph Solvers</a> for more information.
 * 
 * @param graphName  Name of the graph resource to solve.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing graph. Weights must be specified using <a
 *                        href="../../graph_solver/network_graph_solver.html#identifiers"
 *                        target="_top">identifiers</a>; identifiers are
 *                        grouped as <a
 *                        href="../../graph_solver/network_graph_solver.html#id-combos"
 *                        target="_top">combinations</a>. Identifiers can be
 *                        used with existing column names, e.g., 'table.column
 *                        AS WEIGHTS_EDGE_ID', expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or raw
 *                        values, e.g., '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'.
 *                        Any provided weights will be added (in the case of
 *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with (in
 *                        the case of 'WEIGHTS_FACTORSPECIFIED') the existing
 *                        weight(s). If using raw values in an identifier
 *                        combination, the number of values specified must
 *                        match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination. If
 *                      @a remove_previous_restrictions is set to @a true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. If @a remove_previous_restrictions is set
 *                      to @a false, any provided restrictions will be added
 *                      (in the case of 'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param solverType  The type of solver to use for the graph.
 *                    <ul>
 *                            <li> gpudb::solve_graph_SHORTEST_PATH: Solves for
 *                    the optimal (shortest) path based on weights and
 *                    restrictions from one source to destinations nodes. Also
 *                    known as the Dijkstra solver.
 *                            <li> gpudb::solve_graph_PAGE_RANK: Solves for the
 *                    probability of each destination node being visited based
 *                    on the links of the graph topology. Weights are not
 *                    required to use this solver.
 *                            <li> gpudb::solve_graph_PROBABILITY_RANK: Solves
 *                    for the transitional probability (Hidden Markov) for each
 *                    node based on the weights (probability assigned over
 *                    given edges).
 *                            <li> gpudb::solve_graph_CENTRALITY: Solves for
 *                    the degree of a node to depict how many pairs of
 *                    individuals that would have to go through the node to
 *                    reach one another in the minimum number of hops. Also
 *                    known as betweenness.
 *                            <li> gpudb::solve_graph_MULTIPLE_ROUTING: Solves
 *                    for finding the minimum cost cumulative path for a
 *                    round-trip starting from the given source and visiting
 *                    each given destination node once then returning to the
 *                    source. Also known as the travelling salesman problem.
 *                            <li> gpudb::solve_graph_INVERSE_SHORTEST_PATH:
 *                    Solves for finding the optimal path cost for each
 *                    destination node to route to the source node. Also known
 *                    as inverse Dijkstra or the service man routing problem.
 *                            <li> gpudb::solve_graph_BACKHAUL_ROUTING: Solves
 *                    for optimal routes that connect remote asset nodes to the
 *                    fixed (backbone) asset nodes. When @a BACKHAUL_ROUTING is
 *                    invoked, the @a destinationNodes or @a destinationNodeIds
 *                    array is used for both fixed and remote asset nodes and
 *                    the @a sourceNodeId represents the number of fixed asset
 *                    nodes contained in @a destinationNodes / @a
 *                    destinationNodeIds.
 *                    </ul>
 *                    The default value is gpudb::solve_graph_SHORTEST_PATH.
 * @param sourceNodeId  If @a nodeType is @a NODE_ID, the node ID (integer) of
 *                      the source (starting point) for the graph solution. If
 *                      the @a solverType is set to @a BACKHAUL_ROUTING, this
 *                      number represents the number of fixed asset nodes
 *                      contained in @a destinationNodes, e.g., if @a
 *                      sourceNodeId is set to 24, the first 24 nodes listed in
 *                      @a destinationNodes / @a destinationNodeIds are the
 *                      fixed asset nodes and the rest of the nodes in the
 *                      array are remote assets.
 * @param destinationNodeIds  List of destination node indices, or indices for
 *                            pageranks. If the @a solverType is set to @a
 *                            BACKHAUL_ROUTING, it is the list of all fixed and
 *                            remote asset nodes.
 * @param nodeType  Source and destination node identifier type.
 *                  <ul>
 *                          <li> gpudb::solve_graph_NODE_ID: The graph's nodes
 *                  were identified as integers, e.g., 1234.
 *                          <li> gpudb::solve_graph_NODE_WKTPOINT: The graph's
 *                  nodes were identified as geospatial coordinates, e.g.,
 *                  'POINT(1.0 2.0)'.
 *                          <li> gpudb::solve_graph_NODE_NAME: The graph's
 *                  nodes were identified as strings, e.g., 'Arlington'.
 *                  </ul>
 *                  The default value is gpudb::solve_graph_NODE_ID.
 * @param sourceNode  If @a nodeType is @a NODE_WKTPOINT or @a NODE_NAME, the
 *                    node (string) of the source (starting point) for the
 *                    graph solution.
 * @param destinationNodes  If @a nodeType is @a NODE_WKTPOINT or @a NODE_NAME,
 *                          the list of destination node or page rank indices
 *                          (strings) for the graph solution. If the @a
 *                          solverType is set to @a BACKHAUL_ROUTING, it is the
 *                          list of all fixed and remote asset nodes. The
 *                          string type should be consistent with the @a
 *                          nodeType parameter.
 * @param solutionTable  Name of the table to store the solution.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::solve_graph_max_solution_radius: For @a
 *                 SHORTEST_PATH and @a INVERSE_SHORTEST_PATH solvers only.
 *                 Sets the maximum solution cost radius, which ignores the @a
 *                 destinationNodeIds list and instead outputs the nodes within
 *                 the radius sorted by ascending cost. If set to '0.0', the
 *                 setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_min_solution_radius: For @a
 *                 SHORTEST_PATH and @a INVERSE_SHORTEST_PATH solvers only.
 *                 Applicable only when @a max_solution_radius is set. Sets the
 *                 minimum solution cost radius, which ignores the @a
 *                 destinationNodeIds list and instead outputs the nodes within
 *                 the radius sorted by ascending cost. If set to '0.0', the
 *                 setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_max_solution_targets: For @a
 *                 SHORTEST_PATH and @a INVERSE_SHORTEST_PATH solvers only.
 *                 Sets the maximum number of solution targets, which ignores
 *                 the @a destinationNodeIds list and instead outputs no more
 *                 than n number of nodes sorted by ascending cost where n is
 *                 equal to the setting value. If set to 0, the setting is
 *                 ignored.  The default value is '0'.
 *                         <li> gpudb::solve_graph_export_solve_results:
 *                 Returns solution results inside the @a
 *                 resultPerDestinationNode array in the response if set to @a
 *                 true.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li>
 *                 gpudb::solve_graph_remove_previous_restrictions: Ignore the
 *                 restrictions applied to the graph during the creation stage
 *                 and only use the restrictions specified in this request if
 *                 set to @a true.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li> gpudb::solve_graph_restriction_threshold_value:
 *                 Value-based restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 solution.
 *                         <li> gpudb::solve_graph_uniform_weights: When
 *                 specified, assigns the given value to all the edges in the
 *                 graph. Note that weights provided in @a weightsOnEdges will
 *                 override this value.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

SolveGraphResponse GPUdb::solveGraph( const std::string& graphName,
                                      const std::vector<std::string>& weightsOnEdges,
                                      const std::vector<std::string>& restrictions,
                                      const std::string& solverType,
                                      const int64_t sourceNodeId,
                                      const std::vector<int64_t>& destinationNodeIds,
                                      const std::string& nodeType,
                                      const std::string& sourceNode,
                                      const std::vector<std::string>& destinationNodes,
                                      const std::string& solutionTable,
                                      const std::map<std::string, std::string>& options ) const
{
    SolveGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.weightsOnEdges = weightsOnEdges;
    actualRequest_.restrictions = restrictions;
    actualRequest_.solverType = solverType;
    actualRequest_.sourceNodeId = sourceNodeId;
    actualRequest_.destinationNodeIds = destinationNodeIds;
    actualRequest_.nodeType = nodeType;
    actualRequest_.sourceNode = sourceNode;
    actualRequest_.destinationNodes = destinationNodes;
    actualRequest_.solutionTable = solutionTable;
    actualRequest_.options = options;
    SolveGraphResponse actualResponse_;
    submitRequest("/solve/graph", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Solves an existing graph for a type of problem (e.g., shortest path, page
 * rank, travelling salesman, etc.) using source nodes, destination nodes, and
 * additional, optional weights and restrictions. See <a
 * href="../../graph_solver/network_graph_solver.html" target="_top">Network
 * Graph Solvers</a> for more information.
 * 
 * @param graphName  Name of the graph resource to solve.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing graph. Weights must be specified using <a
 *                        href="../../graph_solver/network_graph_solver.html#identifiers"
 *                        target="_top">identifiers</a>; identifiers are
 *                        grouped as <a
 *                        href="../../graph_solver/network_graph_solver.html#id-combos"
 *                        target="_top">combinations</a>. Identifiers can be
 *                        used with existing column names, e.g., 'table.column
 *                        AS WEIGHTS_EDGE_ID', expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or raw
 *                        values, e.g., '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'.
 *                        Any provided weights will be added (in the case of
 *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with (in
 *                        the case of 'WEIGHTS_FACTORSPECIFIED') the existing
 *                        weight(s). If using raw values in an identifier
 *                        combination, the number of values specified must
 *                        match across the combination.
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
 *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0,
 *                      0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                      values in an identifier combination, the number of
 *                      values specified must match across the combination. If
 *                      @a remove_previous_restrictions is set to @a true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. If @a remove_previous_restrictions is set
 *                      to @a false, any provided restrictions will be added
 *                      (in the case of 'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param solverType  The type of solver to use for the graph.
 *                    <ul>
 *                            <li> gpudb::solve_graph_SHORTEST_PATH: Solves for
 *                    the optimal (shortest) path based on weights and
 *                    restrictions from one source to destinations nodes. Also
 *                    known as the Dijkstra solver.
 *                            <li> gpudb::solve_graph_PAGE_RANK: Solves for the
 *                    probability of each destination node being visited based
 *                    on the links of the graph topology. Weights are not
 *                    required to use this solver.
 *                            <li> gpudb::solve_graph_PROBABILITY_RANK: Solves
 *                    for the transitional probability (Hidden Markov) for each
 *                    node based on the weights (probability assigned over
 *                    given edges).
 *                            <li> gpudb::solve_graph_CENTRALITY: Solves for
 *                    the degree of a node to depict how many pairs of
 *                    individuals that would have to go through the node to
 *                    reach one another in the minimum number of hops. Also
 *                    known as betweenness.
 *                            <li> gpudb::solve_graph_MULTIPLE_ROUTING: Solves
 *                    for finding the minimum cost cumulative path for a
 *                    round-trip starting from the given source and visiting
 *                    each given destination node once then returning to the
 *                    source. Also known as the travelling salesman problem.
 *                            <li> gpudb::solve_graph_INVERSE_SHORTEST_PATH:
 *                    Solves for finding the optimal path cost for each
 *                    destination node to route to the source node. Also known
 *                    as inverse Dijkstra or the service man routing problem.
 *                            <li> gpudb::solve_graph_BACKHAUL_ROUTING: Solves
 *                    for optimal routes that connect remote asset nodes to the
 *                    fixed (backbone) asset nodes. When @a BACKHAUL_ROUTING is
 *                    invoked, the @a destinationNodes or @a destinationNodeIds
 *                    array is used for both fixed and remote asset nodes and
 *                    the @a sourceNodeId represents the number of fixed asset
 *                    nodes contained in @a destinationNodes / @a
 *                    destinationNodeIds.
 *                    </ul>
 *                    The default value is gpudb::solve_graph_SHORTEST_PATH.
 * @param sourceNodeId  If @a nodeType is @a NODE_ID, the node ID (integer) of
 *                      the source (starting point) for the graph solution. If
 *                      the @a solverType is set to @a BACKHAUL_ROUTING, this
 *                      number represents the number of fixed asset nodes
 *                      contained in @a destinationNodes, e.g., if @a
 *                      sourceNodeId is set to 24, the first 24 nodes listed in
 *                      @a destinationNodes / @a destinationNodeIds are the
 *                      fixed asset nodes and the rest of the nodes in the
 *                      array are remote assets.
 * @param destinationNodeIds  List of destination node indices, or indices for
 *                            pageranks. If the @a solverType is set to @a
 *                            BACKHAUL_ROUTING, it is the list of all fixed and
 *                            remote asset nodes.
 * @param nodeType  Source and destination node identifier type.
 *                  <ul>
 *                          <li> gpudb::solve_graph_NODE_ID: The graph's nodes
 *                  were identified as integers, e.g., 1234.
 *                          <li> gpudb::solve_graph_NODE_WKTPOINT: The graph's
 *                  nodes were identified as geospatial coordinates, e.g.,
 *                  'POINT(1.0 2.0)'.
 *                          <li> gpudb::solve_graph_NODE_NAME: The graph's
 *                  nodes were identified as strings, e.g., 'Arlington'.
 *                  </ul>
 *                  The default value is gpudb::solve_graph_NODE_ID.
 * @param sourceNode  If @a nodeType is @a NODE_WKTPOINT or @a NODE_NAME, the
 *                    node (string) of the source (starting point) for the
 *                    graph solution.
 * @param destinationNodes  If @a nodeType is @a NODE_WKTPOINT or @a NODE_NAME,
 *                          the list of destination node or page rank indices
 *                          (strings) for the graph solution. If the @a
 *                          solverType is set to @a BACKHAUL_ROUTING, it is the
 *                          list of all fixed and remote asset nodes. The
 *                          string type should be consistent with the @a
 *                          nodeType parameter.
 * @param solutionTable  Name of the table to store the solution.
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::solve_graph_max_solution_radius: For @a
 *                 SHORTEST_PATH and @a INVERSE_SHORTEST_PATH solvers only.
 *                 Sets the maximum solution cost radius, which ignores the @a
 *                 destinationNodeIds list and instead outputs the nodes within
 *                 the radius sorted by ascending cost. If set to '0.0', the
 *                 setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_min_solution_radius: For @a
 *                 SHORTEST_PATH and @a INVERSE_SHORTEST_PATH solvers only.
 *                 Applicable only when @a max_solution_radius is set. Sets the
 *                 minimum solution cost radius, which ignores the @a
 *                 destinationNodeIds list and instead outputs the nodes within
 *                 the radius sorted by ascending cost. If set to '0.0', the
 *                 setting is ignored.  The default value is '0.0'.
 *                         <li> gpudb::solve_graph_max_solution_targets: For @a
 *                 SHORTEST_PATH and @a INVERSE_SHORTEST_PATH solvers only.
 *                 Sets the maximum number of solution targets, which ignores
 *                 the @a destinationNodeIds list and instead outputs no more
 *                 than n number of nodes sorted by ascending cost where n is
 *                 equal to the setting value. If set to 0, the setting is
 *                 ignored.  The default value is '0'.
 *                         <li> gpudb::solve_graph_export_solve_results:
 *                 Returns solution results inside the @a
 *                 resultPerDestinationNode array in the response if set to @a
 *                 true.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li>
 *                 gpudb::solve_graph_remove_previous_restrictions: Ignore the
 *                 restrictions applied to the graph during the creation stage
 *                 and only use the restrictions specified in this request if
 *                 set to @a true.
 *                 <ul>
 *                         <li> gpudb::solve_graph_true
 *                         <li> gpudb::solve_graph_false
 *                 </ul>
 *                 The default value is gpudb::solve_graph_false.
 *                         <li> gpudb::solve_graph_restriction_threshold_value:
 *                 Value-based restriction comparison. Any node or edge with a
 *                 RESTRICTIONS_VALUECOMPARED value greater than the @a
 *                 restriction_threshold_value will not be included in the
 *                 solution.
 *                         <li> gpudb::solve_graph_uniform_weights: When
 *                 specified, assigns the given value to all the edges in the
 *                 graph. Note that weights provided in @a weightsOnEdges will
 *                 override this value.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

SolveGraphResponse& GPUdb::solveGraph( const std::string& graphName,
                                       const std::vector<std::string>& weightsOnEdges,
                                       const std::vector<std::string>& restrictions,
                                       const std::string& solverType,
                                       const int64_t sourceNodeId,
                                       const std::vector<int64_t>& destinationNodeIds,
                                       const std::string& nodeType,
                                       const std::string& sourceNode,
                                       const std::vector<std::string>& destinationNodes,
                                       const std::string& solutionTable,
                                       const std::map<std::string, std::string>& options,
                                       SolveGraphResponse& response_ ) const
{
    SolveGraphRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.weightsOnEdges = weightsOnEdges;
    actualRequest_.restrictions = restrictions;
    actualRequest_.solverType = solverType;
    actualRequest_.sourceNodeId = sourceNodeId;
    actualRequest_.destinationNodeIds = destinationNodeIds;
    actualRequest_.nodeType = nodeType;
    actualRequest_.sourceNode = sourceNode;
    actualRequest_.destinationNodes = destinationNodes;
    actualRequest_.solutionTable = solutionTable;
    actualRequest_.options = options;
    submitRequest("/solve/graph", actualRequest_, response_, false);
    return response_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsResponse GPUdb::updateRecordsRaw( const RawUpdateRecordsRequest& request_ ) const
{
    UpdateRecordsResponse actualResponse_;
    submitRequest("/update/records", request_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsResponse& GPUdb::updateRecordsRaw( const RawUpdateRecordsRequest& request_,
                                                UpdateRecordsResponse& response_ ) const
{
    submitRequest("/update/records", request_, response_, true);
    return response_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse GPUdb::updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_ ) const
{
    UpdateRecordsBySeriesResponse actualResponse_;
    submitRequest("/update/records/byseries", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& GPUdb::updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_,
                                                             UpdateRecordsBySeriesResponse& response_ ) const
{
    submitRequest("/update/records/byseries", request_, response_, false);
    return response_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed. Must be an existing view.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information.
 * @param viewName  name of the view containing the series (tracks) which have
 *                  to be updated.
 * @param reserved
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse GPUdb::updateRecordsBySeries( const std::string& tableName,
                                                            const std::string& worldTableName,
                                                            const std::string& viewName,
                                                            const std::vector<std::string>& reserved,
                                                            const std::map<std::string, std::string>& options ) const
{
    UpdateRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.viewName = viewName;
    actualRequest_.reserved = reserved;
    actualRequest_.options = options;
    UpdateRecordsBySeriesResponse actualResponse_;
    submitRequest("/update/records/byseries", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed. Must be an existing view.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information.
 * @param viewName  name of the view containing the series (tracks) which have
 *                  to be updated.
 * @param reserved
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& GPUdb::updateRecordsBySeries( const std::string& tableName,
                                                             const std::string& worldTableName,
                                                             const std::string& viewName,
                                                             const std::vector<std::string>& reserved,
                                                             const std::map<std::string, std::string>& options,
                                                             UpdateRecordsBySeriesResponse& response_ ) const
{
    UpdateRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.viewName = viewName;
    actualRequest_.reserved = reserved;
    actualRequest_.options = options;
    submitRequest("/update/records/byseries", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse GPUdb::visualizeImage( const VisualizeImageRequest& request_ ) const
{
    VisualizeImageResponse actualResponse_;
    submitRequest("/visualize/image", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& GPUdb::visualizeImage( const VisualizeImageRequest& request_,
                                               VisualizeImageResponse& response_ ) const
{
    submitRequest("/visualize/image", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param symbolColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_EPSG_4326
 *                            <li> gpudb::visualize_image_PLATE_CARREE
 *                            <li> gpudb::visualize_image_900913
 *                            <li> gpudb::visualize_image_EPSG_900913
 *                            <li> gpudb::visualize_image_102100
 *                            <li> gpudb::visualize_image_EPSG_102100
 *                            <li> gpudb::visualize_image_3857
 *                            <li> gpudb::visualize_image_EPSG_3857
 *                            <li> gpudb::visualize_image_WEB_MERCATOR
 *                    </ul>
 *                    The default value is gpudb::visualize_image_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_false.
 *                              <li> gpudb::visualize_image_pointcolors
 *                              <li> gpudb::visualize_image_pointsizes:   The
 *                      default value is '3'.
 *                              <li> gpudb::visualize_image_pointoffset_x:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointoffset_y:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_image_square.
 *                              <li> gpudb::visualize_image_symbolrotations:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_shapelinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li> gpudb::visualize_image_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_shapelinepatternlen:   The
 *                      default value is '32'.
 *                              <li> gpudb::visualize_image_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li> gpudb::visualize_image_hashlineintervals:
 *                      The default value is '20'.
 *                              <li> gpudb::visualize_image_hashlinecolors:
 *                      The default value is 'The same as line color.'.
 *                              <li> gpudb::visualize_image_hashlineangles:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinelens:   The
 *                      default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li> gpudb::visualize_image_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_oriented_arrow
 *                              <li> gpudb::visualize_image_oriented_triangle
 *                              <li> gpudb::visualize_image_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_image_circle.
 *                              <li> gpudb::visualize_image_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li> gpudb::visualize_image_trackheadsizes:
 *                      The default value is '10'.
 *                              <li> gpudb::visualize_image_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_hollowdiamond.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse GPUdb::visualizeImage( const std::vector<std::string>& tableNames,
                                              const std::vector<std::string>& worldTableNames,
                                              const std::string& xColumnName,
                                              const std::string& yColumnName,
                                              const std::string& symbolColumnName,
                                              const std::string& geometryColumnName,
                                              const std::vector<std::vector<std::string> >& trackIds,
                                              const double minX,
                                              const double maxX,
                                              const double minY,
                                              const double maxY,
                                              const int32_t width,
                                              const int32_t height,
                                              const std::string& projection,
                                              const int64_t bgColor,
                                              const std::map<std::string, std::vector<std::string> >& styleOptions,
                                              const std::map<std::string, std::string>& options ) const
{
    VisualizeImageRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.symbolColumnName = symbolColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageResponse actualResponse_;
    submitRequest("/visualize/image", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param symbolColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_EPSG_4326
 *                            <li> gpudb::visualize_image_PLATE_CARREE
 *                            <li> gpudb::visualize_image_900913
 *                            <li> gpudb::visualize_image_EPSG_900913
 *                            <li> gpudb::visualize_image_102100
 *                            <li> gpudb::visualize_image_EPSG_102100
 *                            <li> gpudb::visualize_image_3857
 *                            <li> gpudb::visualize_image_EPSG_3857
 *                            <li> gpudb::visualize_image_WEB_MERCATOR
 *                    </ul>
 *                    The default value is gpudb::visualize_image_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_true.
 *                              <li> gpudb::visualize_image_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_true
 *                              <li> gpudb::visualize_image_false
 *                      </ul>
 *                      The default value is gpudb::visualize_image_false.
 *                              <li> gpudb::visualize_image_pointcolors
 *                              <li> gpudb::visualize_image_pointsizes:   The
 *                      default value is '3'.
 *                              <li> gpudb::visualize_image_pointoffset_x:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointoffset_y:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_image_square.
 *                              <li> gpudb::visualize_image_symbolrotations:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_shapelinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li> gpudb::visualize_image_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_shapelinepatternlen:   The
 *                      default value is '32'.
 *                              <li> gpudb::visualize_image_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li> gpudb::visualize_image_hashlineintervals:
 *                      The default value is '20'.
 *                              <li> gpudb::visualize_image_hashlinecolors:
 *                      The default value is 'The same as line color.'.
 *                              <li> gpudb::visualize_image_hashlineangles:
 *                      The default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinelens:   The
 *                      default value is '0'.
 *                              <li> gpudb::visualize_image_hashlinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li> gpudb::visualize_image_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_oriented_arrow
 *                              <li> gpudb::visualize_image_oriented_triangle
 *                              <li> gpudb::visualize_image_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_image_circle.
 *                              <li> gpudb::visualize_image_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li> gpudb::visualize_image_trackheadsizes:
 *                      The default value is '10'.
 *                              <li> gpudb::visualize_image_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_none
 *                              <li> gpudb::visualize_image_circle
 *                              <li> gpudb::visualize_image_square
 *                              <li> gpudb::visualize_image_diamond
 *                              <li> gpudb::visualize_image_hollowcircle
 *                              <li> gpudb::visualize_image_hollowsquare
 *                              <li> gpudb::visualize_image_hollowdiamond
 *                              <li> gpudb::visualize_image_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_hollowdiamond.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& GPUdb::visualizeImage( const std::vector<std::string>& tableNames,
                                               const std::vector<std::string>& worldTableNames,
                                               const std::string& xColumnName,
                                               const std::string& yColumnName,
                                               const std::string& symbolColumnName,
                                               const std::string& geometryColumnName,
                                               const std::vector<std::vector<std::string> >& trackIds,
                                               const double minX,
                                               const double maxX,
                                               const double minY,
                                               const double maxY,
                                               const int32_t width,
                                               const int32_t height,
                                               const std::string& projection,
                                               const int64_t bgColor,
                                               const std::map<std::string, std::vector<std::string> >& styleOptions,
                                               const std::map<std::string, std::string>& options,
                                               VisualizeImageResponse& response_ ) const
{
    VisualizeImageRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.symbolColumnName = symbolColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image", actualRequest_, response_, false);
    return response_;
}


/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageChartResponse GPUdb::visualizeImageChart( const VisualizeImageChartRequest& request_ ) const
{
    VisualizeImageChartResponse actualResponse_;
    submitRequest("/visualize/image/chart", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageChartResponse& GPUdb::visualizeImageChart( const VisualizeImageChartRequest& request_,
                                                         VisualizeImageChartResponse& response_ ) const
{
    submitRequest("/visualize/image/chart", request_, response_, false);
    return response_;
}


/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param tableName  Name of the table containing the data to be drawn as a
 *                   chart.
 * @param xColumnNames  Names of the columns containing the data mapped to the
 *                      x axis of a chart.
 * @param yColumnNames  Names of the columns containing the data mapped to the
 *                      y axis of a chart.
 * @param minX  Lower bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param maxX  Upper bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param minY  Lower bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param maxY  Upper bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param width  Width of the generated image in pixels.
 * @param height  Height of the generated image in pixels.
 * @param bgColor  Background color of the generated image.
 * @param styleOptions  Rendering style options for a chart.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_pointcolor:
 *                      The color of points in the plot represented as a
 *                      hexadecimal number.  The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_chart_pointsize:
 *                      The size of points in the plot represented as number of
 *                      pixels.  The default value is '3'.
 *                              <li> gpudb::visualize_image_chart_pointshape:
 *                      The shape of points in the plot.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none
 *                              <li> gpudb::visualize_image_chart_circle
 *                              <li> gpudb::visualize_image_chart_square
 *                              <li> gpudb::visualize_image_chart_diamond
 *                              <li> gpudb::visualize_image_chart_hollowcircle
 *                              <li> gpudb::visualize_image_chart_hollowsquare
 *                              <li> gpudb::visualize_image_chart_hollowdiamond
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_chart_square.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointcolors: Point
 *                      color class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point color values. This option
 *                      overrides the pointcolor option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point color
 *                      values are separated by cb_delimiter, e.g. {"price",
 *                      "20:30;30:40;40:50", "0xFF0000;0x00FF00;0x0000FF"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointsizes: Point size
 *                      class break information consisting of three entries:
 *                      class-break attribute, class-break values/ranges, and
 *                      point size values. This option overrides the pointsize
 *                      option if both are provided. Class-break ranges are
 *                      represented in the form of "min:max". Class-break
 *                      values/ranges and point size values are separated by
 *                      cb_delimiter, e.g. {"states", "NY;TX;CA", "3;5;7"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointshapes: Point
 *                      shape class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point shape names. This option
 *                      overrides the pointshape option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point shape
 *                      names are separated by cb_delimiter, e.g. {"states",
 *                      "NY;TX;CA", "circle;square;diamond"}.
 *                              <li> gpudb::visualize_image_chart_cb_delimiter:
 *                      A character or string which separates per-class values
 *                      in a class-break style option string.  The default
 *                      value is ';'.
 *                              <li> gpudb::visualize_image_chart_x_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric x column values are sorted, e.g.
 *                      "avg(price) descending".
 *                              <li> gpudb::visualize_image_chart_y_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric y column values are sorted, e.g.
 *                      "avg(price)", which defaults to "avg(price) ascending".
 *                              <li> gpudb::visualize_image_chart_scale_type_x:
 *                      Type of x axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the x axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the x axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li> gpudb::visualize_image_chart_scale_type_y:
 *                      Type of y axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the y axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the y axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li>
 *                      gpudb::visualize_image_chart_min_max_scaled: If this
 *                      options is set to "false", this endpoint expects
 *                      request's min/max values are not yet scaled. They will
 *                      be scaled according to scale_type_x or scale_type_y for
 *                      response. If this options is set to "true", this
 *                      endpoint expects request's min/max values are already
 *                      scaled according to scale_type_x/scale_type_y.
 *                      Response's min/max values will be equal to request's
 *                      min/max values.  The default value is 'false'.
 *                              <li> gpudb::visualize_image_chart_jitter_x:
 *                      Amplitude of horizontal jitter applied to non-numeric x
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_jitter_y:
 *                      Amplitude of vertical jitter applied to non-numeric y
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_plot_all: If
 *                      this options is set to "true", all non-numeric column
 *                      values are plotted ignoring min_x, max_x, min_y and
 *                      max_y parameters.  The default value is 'false'.
 *                      </ul>
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageChartResponse GPUdb::visualizeImageChart( const std::string& tableName,
                                                        const std::vector<std::string>& xColumnNames,
                                                        const std::vector<std::string>& yColumnNames,
                                                        const double minX,
                                                        const double maxX,
                                                        const double minY,
                                                        const double maxY,
                                                        const int32_t width,
                                                        const int32_t height,
                                                        const std::string& bgColor,
                                                        const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                        const std::map<std::string, std::string>& options ) const
{
    VisualizeImageChartRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnNames = xColumnNames;
    actualRequest_.yColumnNames = yColumnNames;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageChartResponse actualResponse_;
    submitRequest("/visualize/image/chart", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the @a imageData field.
 * 
 * @param tableName  Name of the table containing the data to be drawn as a
 *                   chart.
 * @param xColumnNames  Names of the columns containing the data mapped to the
 *                      x axis of a chart.
 * @param yColumnNames  Names of the columns containing the data mapped to the
 *                      y axis of a chart.
 * @param minX  Lower bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param maxX  Upper bound for the x column values. For non-numeric x column,
 *              each x column item is mapped to an integral value starting from
 *              0.
 * @param minY  Lower bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param maxY  Upper bound for the y column values. For non-numeric y column,
 *              each y column item is mapped to an integral value starting from
 *              0.
 * @param width  Width of the generated image in pixels.
 * @param height  Height of the generated image in pixels.
 * @param bgColor  Background color of the generated image.
 * @param styleOptions  Rendering style options for a chart.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_pointcolor:
 *                      The color of points in the plot represented as a
 *                      hexadecimal number.  The default value is '0000FF'.
 *                              <li> gpudb::visualize_image_chart_pointsize:
 *                      The size of points in the plot represented as number of
 *                      pixels.  The default value is '3'.
 *                              <li> gpudb::visualize_image_chart_pointshape:
 *                      The shape of points in the plot.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none
 *                              <li> gpudb::visualize_image_chart_circle
 *                              <li> gpudb::visualize_image_chart_square
 *                              <li> gpudb::visualize_image_chart_diamond
 *                              <li> gpudb::visualize_image_chart_hollowcircle
 *                              <li> gpudb::visualize_image_chart_hollowsquare
 *                              <li> gpudb::visualize_image_chart_hollowdiamond
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_chart_square.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointcolors: Point
 *                      color class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point color values. This option
 *                      overrides the pointcolor option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point color
 *                      values are separated by cb_delimiter, e.g. {"price",
 *                      "20:30;30:40;40:50", "0xFF0000;0x00FF00;0x0000FF"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointsizes: Point size
 *                      class break information consisting of three entries:
 *                      class-break attribute, class-break values/ranges, and
 *                      point size values. This option overrides the pointsize
 *                      option if both are provided. Class-break ranges are
 *                      represented in the form of "min:max". Class-break
 *                      values/ranges and point size values are separated by
 *                      cb_delimiter, e.g. {"states", "NY;TX;CA", "3;5;7"}.
 *                              <li>
 *                      gpudb::visualize_image_chart_cb_pointshapes: Point
 *                      shape class break information consisting of three
 *                      entries: class-break attribute, class-break
 *                      values/ranges, and point shape names. This option
 *                      overrides the pointshape option if both are provided.
 *                      Class-break ranges are represented in the form of
 *                      "min:max". Class-break values/ranges and point shape
 *                      names are separated by cb_delimiter, e.g. {"states",
 *                      "NY;TX;CA", "circle;square;diamond"}.
 *                              <li> gpudb::visualize_image_chart_cb_delimiter:
 *                      A character or string which separates per-class values
 *                      in a class-break style option string.  The default
 *                      value is ';'.
 *                              <li> gpudb::visualize_image_chart_x_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric x column values are sorted, e.g.
 *                      "avg(price) descending".
 *                              <li> gpudb::visualize_image_chart_y_order_by:
 *                      An expression or aggregate expression by which
 *                      non-numeric y column values are sorted, e.g.
 *                      "avg(price)", which defaults to "avg(price) ascending".
 *                              <li> gpudb::visualize_image_chart_scale_type_x:
 *                      Type of x axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the x axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the x axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li> gpudb::visualize_image_chart_scale_type_y:
 *                      Type of y axis scale.
 *                      <ul>
 *                              <li> gpudb::visualize_image_chart_none: No
 *                      scale is applied to the y axis.
 *                              <li> gpudb::visualize_image_chart_log: A
 *                      base-10 log scale is applied to the y axis.
 *                      </ul>
 *                      The default value is gpudb::visualize_image_chart_none.
 *                              <li>
 *                      gpudb::visualize_image_chart_min_max_scaled: If this
 *                      options is set to "false", this endpoint expects
 *                      request's min/max values are not yet scaled. They will
 *                      be scaled according to scale_type_x or scale_type_y for
 *                      response. If this options is set to "true", this
 *                      endpoint expects request's min/max values are already
 *                      scaled according to scale_type_x/scale_type_y.
 *                      Response's min/max values will be equal to request's
 *                      min/max values.  The default value is 'false'.
 *                              <li> gpudb::visualize_image_chart_jitter_x:
 *                      Amplitude of horizontal jitter applied to non-numeric x
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_jitter_y:
 *                      Amplitude of vertical jitter applied to non-numeric y
 *                      column values.  The default value is '0.0'.
 *                              <li> gpudb::visualize_image_chart_plot_all: If
 *                      this options is set to "true", all non-numeric column
 *                      values are plotted ignoring min_x, max_x, min_y and
 *                      max_y parameters.  The default value is 'false'.
 *                      </ul>
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageChartResponse& GPUdb::visualizeImageChart( const std::string& tableName,
                                                         const std::vector<std::string>& xColumnNames,
                                                         const std::vector<std::string>& yColumnNames,
                                                         const double minX,
                                                         const double maxX,
                                                         const double minY,
                                                         const double maxY,
                                                         const int32_t width,
                                                         const int32_t height,
                                                         const std::string& bgColor,
                                                         const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                         const std::map<std::string, std::string>& options,
                                                         VisualizeImageChartResponse& response_ ) const
{
    VisualizeImageChartRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnNames = xColumnNames;
    actualRequest_.yColumnNames = yColumnNames;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image/chart", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse GPUdb::visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_ ) const
{
    VisualizeImageClassbreakResponse actualResponse_;
    submitRequest("/visualize/image/classbreak", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& GPUdb::visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_,
                                                                   VisualizeImageClassbreakResponse& response_ ) const
{
    submitRequest("/visualize/image/classbreak", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param cbAttr
 * @param cbVals
 * @param cbPointcolorAttr
 * @param cbPointcolorVals
 * @param cbPointsizeAttr
 * @param cbPointsizeVals
 * @param cbPointshapeAttr
 * @param cbPointshapeVals
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_classbreak_EPSG_4326
 *                            <li>
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE
 *                            <li> gpudb::visualize_image_classbreak_900913
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_900913
 *                            <li> gpudb::visualize_image_classbreak_102100
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_102100
 *                            <li> gpudb::visualize_image_classbreak_3857
 *                            <li> gpudb::visualize_image_classbreak_EPSG_3857
 *                            <li>
 *                    gpudb::visualize_image_classbreak_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_false.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointcolors:   The
 *                      default value is 'FF0000'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointsizes:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_x:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_y:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatternlen:
 *                      The default value is '32'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineintervals:
 *                      The default value is '20'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinecolors:   The
 *                      default value is 'The same as line color.'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineangles:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinelens:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinewidths:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadsizes:   The
 *                      default value is '10'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_circle.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse GPUdb::visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                                  const std::vector<std::string>& worldTableNames,
                                                                  const std::string& xColumnName,
                                                                  const std::string& yColumnName,
                                                                  const std::string& geometryColumnName,
                                                                  const std::vector<std::vector<std::string> >& trackIds,
                                                                  const std::string& cbAttr,
                                                                  const std::vector<std::string>& cbVals,
                                                                  const std::string& cbPointcolorAttr,
                                                                  const std::vector<std::string>& cbPointcolorVals,
                                                                  const std::string& cbPointsizeAttr,
                                                                  const std::vector<std::string>& cbPointsizeVals,
                                                                  const std::string& cbPointshapeAttr,
                                                                  const std::vector<std::string>& cbPointshapeVals,
                                                                  const double minX,
                                                                  const double maxX,
                                                                  const double minY,
                                                                  const double maxY,
                                                                  const int32_t width,
                                                                  const int32_t height,
                                                                  const std::string& projection,
                                                                  const int64_t bgColor,
                                                                  const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                                  const std::map<std::string, std::string>& options ) const
{
    VisualizeImageClassbreakRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.cbAttr = cbAttr;
    actualRequest_.cbVals = cbVals;
    actualRequest_.cbPointcolorAttr = cbPointcolorAttr;
    actualRequest_.cbPointcolorVals = cbPointcolorVals;
    actualRequest_.cbPointsizeAttr = cbPointsizeAttr;
    actualRequest_.cbPointsizeVals = cbPointsizeVals;
    actualRequest_.cbPointshapeAttr = cbPointshapeAttr;
    actualRequest_.cbPointshapeVals = cbPointshapeVals;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageClassbreakResponse actualResponse_;
    submitRequest("/visualize/image/classbreak", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param geometryColumnName
 * @param trackIds
 * @param cbAttr
 * @param cbVals
 * @param cbPointcolorAttr
 * @param cbPointcolorVals
 * @param cbPointsizeAttr
 * @param cbPointsizeVals
 * @param cbPointshapeAttr
 * @param cbPointshapeVals
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_classbreak_EPSG_4326
 *                            <li>
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE
 *                            <li> gpudb::visualize_image_classbreak_900913
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_900913
 *                            <li> gpudb::visualize_image_classbreak_102100
 *                            <li>
 *                    gpudb::visualize_image_classbreak_EPSG_102100
 *                            <li> gpudb::visualize_image_classbreak_3857
 *                            <li> gpudb::visualize_image_classbreak_EPSG_3857
 *                            <li>
 *                    gpudb::visualize_image_classbreak_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_classbreak_PLATE_CARREE.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_true.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_do_symbology:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_true
 *                              <li> gpudb::visualize_image_classbreak_false
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_false.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointcolors:   The
 *                      default value is 'FF0000'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointsizes:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_x:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointoffset_y:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatterns:
 *                      The default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapelinepatternlen:
 *                      The default value is '32'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineintervals:
 *                      The default value is '20'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinecolors:   The
 *                      default value is 'The same as line color.'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlineangles:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinelens:   The
 *                      default value is '0'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hashlinewidths:   The
 *                      default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinewidths:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_none.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadsizes:   The
 *                      default value is '10'.
 *                              <li>
 *                      gpudb::visualize_image_classbreak_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_image_classbreak_none
 *                              <li> gpudb::visualize_image_classbreak_circle
 *                              <li> gpudb::visualize_image_classbreak_square
 *                              <li> gpudb::visualize_image_classbreak_diamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowcircle
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowsquare
 *                              <li>
 *                      gpudb::visualize_image_classbreak_hollowdiamond
 *                              <li>
 *                      gpudb::visualize_image_classbreak_SYMBOLCODE
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_classbreak_circle.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& GPUdb::visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                                   const std::vector<std::string>& worldTableNames,
                                                                   const std::string& xColumnName,
                                                                   const std::string& yColumnName,
                                                                   const std::string& geometryColumnName,
                                                                   const std::vector<std::vector<std::string> >& trackIds,
                                                                   const std::string& cbAttr,
                                                                   const std::vector<std::string>& cbVals,
                                                                   const std::string& cbPointcolorAttr,
                                                                   const std::vector<std::string>& cbPointcolorVals,
                                                                   const std::string& cbPointsizeAttr,
                                                                   const std::vector<std::string>& cbPointsizeVals,
                                                                   const std::string& cbPointshapeAttr,
                                                                   const std::vector<std::string>& cbPointshapeVals,
                                                                   const double minX,
                                                                   const double maxX,
                                                                   const double minY,
                                                                   const double maxY,
                                                                   const int32_t width,
                                                                   const int32_t height,
                                                                   const std::string& projection,
                                                                   const int64_t bgColor,
                                                                   const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                                   const std::map<std::string, std::string>& options,
                                                                   VisualizeImageClassbreakResponse& response_ ) const
{
    VisualizeImageClassbreakRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.cbAttr = cbAttr;
    actualRequest_.cbVals = cbVals;
    actualRequest_.cbPointcolorAttr = cbPointcolorAttr;
    actualRequest_.cbPointcolorVals = cbPointcolorVals;
    actualRequest_.cbPointsizeAttr = cbPointsizeAttr;
    actualRequest_.cbPointsizeVals = cbPointsizeVals;
    actualRequest_.cbPointshapeAttr = cbPointshapeAttr;
    actualRequest_.cbPointshapeVals = cbPointshapeVals;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image/classbreak", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageContourResponse GPUdb::visualizeImageContour( const VisualizeImageContourRequest& request_ ) const
{
    VisualizeImageContourResponse actualResponse_;
    submitRequest("/visualize/image/contour", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageContourResponse& GPUdb::visualizeImageContour( const VisualizeImageContourRequest& request_,
                                                             VisualizeImageContourResponse& response_ ) const
{
    submitRequest("/visualize/image/contour", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_contour_3857
 *                            <li> gpudb::visualize_image_contour_102100
 *                            <li> gpudb::visualize_image_contour_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_4326
 *                            <li> gpudb::visualize_image_contour_PLATE_CARREE
 *                            <li> gpudb::visualize_image_contour_EPSG_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_102100
 *                            <li> gpudb::visualize_image_contour_EPSG_3857
 *                            <li> gpudb::visualize_image_contour_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_contour_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_line_size:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_contour_color:
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_image_contour_bg_color:
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_image_contour_text_color:
 *                      The default value is 'FF000000'.
 *                              <li> gpudb::visualize_image_contour_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_jet
 *                              <li> gpudb::visualize_image_contour_accent
 *                              <li> gpudb::visualize_image_contour_afmhot
 *                              <li> gpudb::visualize_image_contour_autumn
 *                              <li> gpudb::visualize_image_contour_binary
 *                              <li> gpudb::visualize_image_contour_blues
 *                              <li> gpudb::visualize_image_contour_bone
 *                              <li> gpudb::visualize_image_contour_brbg
 *                              <li> gpudb::visualize_image_contour_brg
 *                              <li> gpudb::visualize_image_contour_bugn
 *                              <li> gpudb::visualize_image_contour_bupu
 *                              <li> gpudb::visualize_image_contour_bwr
 *                              <li> gpudb::visualize_image_contour_cmrmap
 *                              <li> gpudb::visualize_image_contour_cool
 *                              <li> gpudb::visualize_image_contour_coolwarm
 *                              <li> gpudb::visualize_image_contour_copper
 *                              <li> gpudb::visualize_image_contour_cubehelix
 *                              <li> gpudb::visualize_image_contour_dark2
 *                              <li> gpudb::visualize_image_contour_flag
 *                              <li> gpudb::visualize_image_contour_gist_earth
 *                              <li> gpudb::visualize_image_contour_gist_gray
 *                              <li> gpudb::visualize_image_contour_gist_heat
 *                              <li> gpudb::visualize_image_contour_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_contour_gist_rainbow
 *                              <li> gpudb::visualize_image_contour_gist_stern
 *                              <li> gpudb::visualize_image_contour_gist_yarg
 *                              <li> gpudb::visualize_image_contour_gnbu
 *                              <li> gpudb::visualize_image_contour_gnuplot2
 *                              <li> gpudb::visualize_image_contour_gnuplot
 *                              <li> gpudb::visualize_image_contour_gray
 *                              <li> gpudb::visualize_image_contour_greens
 *                              <li> gpudb::visualize_image_contour_greys
 *                              <li> gpudb::visualize_image_contour_hot
 *                              <li> gpudb::visualize_image_contour_hsv
 *                              <li> gpudb::visualize_image_contour_inferno
 *                              <li> gpudb::visualize_image_contour_magma
 *                              <li>
 *                      gpudb::visualize_image_contour_nipy_spectral
 *                              <li> gpudb::visualize_image_contour_ocean
 *                              <li> gpudb::visualize_image_contour_oranges
 *                              <li> gpudb::visualize_image_contour_orrd
 *                              <li> gpudb::visualize_image_contour_paired
 *                              <li> gpudb::visualize_image_contour_pastel1
 *                              <li> gpudb::visualize_image_contour_pastel2
 *                              <li> gpudb::visualize_image_contour_pink
 *                              <li> gpudb::visualize_image_contour_piyg
 *                              <li> gpudb::visualize_image_contour_plasma
 *                              <li> gpudb::visualize_image_contour_prgn
 *                              <li> gpudb::visualize_image_contour_prism
 *                              <li> gpudb::visualize_image_contour_pubu
 *                              <li> gpudb::visualize_image_contour_pubugn
 *                              <li> gpudb::visualize_image_contour_puor
 *                              <li> gpudb::visualize_image_contour_purd
 *                              <li> gpudb::visualize_image_contour_purples
 *                              <li> gpudb::visualize_image_contour_rainbow
 *                              <li> gpudb::visualize_image_contour_rdbu
 *                              <li> gpudb::visualize_image_contour_rdgy
 *                              <li> gpudb::visualize_image_contour_rdpu
 *                              <li> gpudb::visualize_image_contour_rdylbu
 *                              <li> gpudb::visualize_image_contour_rdylgn
 *                              <li> gpudb::visualize_image_contour_reds
 *                              <li> gpudb::visualize_image_contour_seismic
 *                              <li> gpudb::visualize_image_contour_set1
 *                              <li> gpudb::visualize_image_contour_set2
 *                              <li> gpudb::visualize_image_contour_set3
 *                              <li> gpudb::visualize_image_contour_spectral
 *                              <li> gpudb::visualize_image_contour_spring
 *                              <li> gpudb::visualize_image_contour_summer
 *                              <li> gpudb::visualize_image_contour_terrain
 *                              <li> gpudb::visualize_image_contour_viridis
 *                              <li> gpudb::visualize_image_contour_winter
 *                              <li> gpudb::visualize_image_contour_wistia
 *                              <li> gpudb::visualize_image_contour_ylgn
 *                              <li> gpudb::visualize_image_contour_ylgnbu
 *                              <li> gpudb::visualize_image_contour_ylorbr
 *                              <li> gpudb::visualize_image_contour_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_contour_jet.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_min_level
 *                         <li> gpudb::visualize_image_contour_max_level
 *                         <li> gpudb::visualize_image_contour_num_levels:
 *                 The default value is '10'.
 *                         <li> gpudb::visualize_image_contour_adjust_levels:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_search_radius:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_max_search_cells:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_gridding_method:
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_INV_DST_POW
 *                         <li> gpudb::visualize_image_contour_MIN_CURV
 *                         <li> gpudb::visualize_image_contour_KRIGING
 *                         <li> gpudb::visualize_image_contour_PASS_THROUGH
 *                         <li> gpudb::visualize_image_contour_FILL_RATIO
 *                 </ul>
 *                 The default value is
 *                 gpudb::visualize_image_contour_INV_DST_POW.
 *                         <li>
 *                 gpudb::visualize_image_contour_smoothing_factor:   The
 *                 default value is '10'.
 *                         <li> gpudb::visualize_image_contour_grid_size:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_adjust_grid:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_neigh:   The
 *                 default value is '1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_size:   The
 *                 default value is '1'.
 *                         <li> gpudb::visualize_image_contour_max_grid_size:
 *                 The default value is '500'.
 *                         <li> gpudb::visualize_image_contour_min_grid_size:
 *                 The default value is '10'.
 *                         <li>
 *                 gpudb::visualize_image_contour_render_output_grid:   The
 *                 default value is 'false'.
 *                         <li> gpudb::visualize_image_contour_color_isolines:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_add_labels:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_size:   The
 *                 default value is '12'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_family:   The
 *                 default value is 'sans'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_search_window:   The
 *                 default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_intralevel_separation:
 *                 The default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_interlevel_separation:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_max_angle:   The
 *                 default value is '60'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_concavity:   The
 *                 default value is '-1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_output_table:   The
 *                 default value is ''.
 *                         <li> gpudb::visualize_image_contour_isochrone_image:
 *                 The default value is 'false'.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageContourResponse GPUdb::visualizeImageContour( const std::vector<std::string>& tableNames,
                                                            const std::string& xColumnName,
                                                            const std::string& yColumnName,
                                                            const std::string& valueColumnName,
                                                            const double minX,
                                                            const double maxX,
                                                            const double minY,
                                                            const double maxY,
                                                            const int32_t width,
                                                            const int32_t height,
                                                            const std::string& projection,
                                                            const std::map<std::string, std::string>& styleOptions,
                                                            const std::map<std::string, std::string>& options ) const
{
    VisualizeImageContourRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageContourResponse actualResponse_;
    submitRequest("/visualize/image/contour", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_contour_3857
 *                            <li> gpudb::visualize_image_contour_102100
 *                            <li> gpudb::visualize_image_contour_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_4326
 *                            <li> gpudb::visualize_image_contour_PLATE_CARREE
 *                            <li> gpudb::visualize_image_contour_EPSG_900913
 *                            <li> gpudb::visualize_image_contour_EPSG_102100
 *                            <li> gpudb::visualize_image_contour_EPSG_3857
 *                            <li> gpudb::visualize_image_contour_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_contour_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_line_size:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_image_contour_color:
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_image_contour_bg_color:
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_image_contour_text_color:
 *                      The default value is 'FF000000'.
 *                              <li> gpudb::visualize_image_contour_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_contour_jet
 *                              <li> gpudb::visualize_image_contour_accent
 *                              <li> gpudb::visualize_image_contour_afmhot
 *                              <li> gpudb::visualize_image_contour_autumn
 *                              <li> gpudb::visualize_image_contour_binary
 *                              <li> gpudb::visualize_image_contour_blues
 *                              <li> gpudb::visualize_image_contour_bone
 *                              <li> gpudb::visualize_image_contour_brbg
 *                              <li> gpudb::visualize_image_contour_brg
 *                              <li> gpudb::visualize_image_contour_bugn
 *                              <li> gpudb::visualize_image_contour_bupu
 *                              <li> gpudb::visualize_image_contour_bwr
 *                              <li> gpudb::visualize_image_contour_cmrmap
 *                              <li> gpudb::visualize_image_contour_cool
 *                              <li> gpudb::visualize_image_contour_coolwarm
 *                              <li> gpudb::visualize_image_contour_copper
 *                              <li> gpudb::visualize_image_contour_cubehelix
 *                              <li> gpudb::visualize_image_contour_dark2
 *                              <li> gpudb::visualize_image_contour_flag
 *                              <li> gpudb::visualize_image_contour_gist_earth
 *                              <li> gpudb::visualize_image_contour_gist_gray
 *                              <li> gpudb::visualize_image_contour_gist_heat
 *                              <li> gpudb::visualize_image_contour_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_contour_gist_rainbow
 *                              <li> gpudb::visualize_image_contour_gist_stern
 *                              <li> gpudb::visualize_image_contour_gist_yarg
 *                              <li> gpudb::visualize_image_contour_gnbu
 *                              <li> gpudb::visualize_image_contour_gnuplot2
 *                              <li> gpudb::visualize_image_contour_gnuplot
 *                              <li> gpudb::visualize_image_contour_gray
 *                              <li> gpudb::visualize_image_contour_greens
 *                              <li> gpudb::visualize_image_contour_greys
 *                              <li> gpudb::visualize_image_contour_hot
 *                              <li> gpudb::visualize_image_contour_hsv
 *                              <li> gpudb::visualize_image_contour_inferno
 *                              <li> gpudb::visualize_image_contour_magma
 *                              <li>
 *                      gpudb::visualize_image_contour_nipy_spectral
 *                              <li> gpudb::visualize_image_contour_ocean
 *                              <li> gpudb::visualize_image_contour_oranges
 *                              <li> gpudb::visualize_image_contour_orrd
 *                              <li> gpudb::visualize_image_contour_paired
 *                              <li> gpudb::visualize_image_contour_pastel1
 *                              <li> gpudb::visualize_image_contour_pastel2
 *                              <li> gpudb::visualize_image_contour_pink
 *                              <li> gpudb::visualize_image_contour_piyg
 *                              <li> gpudb::visualize_image_contour_plasma
 *                              <li> gpudb::visualize_image_contour_prgn
 *                              <li> gpudb::visualize_image_contour_prism
 *                              <li> gpudb::visualize_image_contour_pubu
 *                              <li> gpudb::visualize_image_contour_pubugn
 *                              <li> gpudb::visualize_image_contour_puor
 *                              <li> gpudb::visualize_image_contour_purd
 *                              <li> gpudb::visualize_image_contour_purples
 *                              <li> gpudb::visualize_image_contour_rainbow
 *                              <li> gpudb::visualize_image_contour_rdbu
 *                              <li> gpudb::visualize_image_contour_rdgy
 *                              <li> gpudb::visualize_image_contour_rdpu
 *                              <li> gpudb::visualize_image_contour_rdylbu
 *                              <li> gpudb::visualize_image_contour_rdylgn
 *                              <li> gpudb::visualize_image_contour_reds
 *                              <li> gpudb::visualize_image_contour_seismic
 *                              <li> gpudb::visualize_image_contour_set1
 *                              <li> gpudb::visualize_image_contour_set2
 *                              <li> gpudb::visualize_image_contour_set3
 *                              <li> gpudb::visualize_image_contour_spectral
 *                              <li> gpudb::visualize_image_contour_spring
 *                              <li> gpudb::visualize_image_contour_summer
 *                              <li> gpudb::visualize_image_contour_terrain
 *                              <li> gpudb::visualize_image_contour_viridis
 *                              <li> gpudb::visualize_image_contour_winter
 *                              <li> gpudb::visualize_image_contour_wistia
 *                              <li> gpudb::visualize_image_contour_ylgn
 *                              <li> gpudb::visualize_image_contour_ylgnbu
 *                              <li> gpudb::visualize_image_contour_ylorbr
 *                              <li> gpudb::visualize_image_contour_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_contour_jet.
 *                      </ul>
 * @param options
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_min_level
 *                         <li> gpudb::visualize_image_contour_max_level
 *                         <li> gpudb::visualize_image_contour_num_levels:
 *                 The default value is '10'.
 *                         <li> gpudb::visualize_image_contour_adjust_levels:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_search_radius:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_max_search_cells:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_gridding_method:
 *                 <ul>
 *                         <li> gpudb::visualize_image_contour_INV_DST_POW
 *                         <li> gpudb::visualize_image_contour_MIN_CURV
 *                         <li> gpudb::visualize_image_contour_KRIGING
 *                         <li> gpudb::visualize_image_contour_PASS_THROUGH
 *                         <li> gpudb::visualize_image_contour_FILL_RATIO
 *                 </ul>
 *                 The default value is
 *                 gpudb::visualize_image_contour_INV_DST_POW.
 *                         <li>
 *                 gpudb::visualize_image_contour_smoothing_factor:   The
 *                 default value is '10'.
 *                         <li> gpudb::visualize_image_contour_grid_size:   The
 *                 default value is '100'.
 *                         <li> gpudb::visualize_image_contour_adjust_grid:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_neigh:   The
 *                 default value is '1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_adjust_grid_size:   The
 *                 default value is '1'.
 *                         <li> gpudb::visualize_image_contour_max_grid_size:
 *                 The default value is '500'.
 *                         <li> gpudb::visualize_image_contour_min_grid_size:
 *                 The default value is '10'.
 *                         <li>
 *                 gpudb::visualize_image_contour_render_output_grid:   The
 *                 default value is 'false'.
 *                         <li> gpudb::visualize_image_contour_color_isolines:
 *                 The default value is 'true'.
 *                         <li> gpudb::visualize_image_contour_add_labels:
 *                 The default value is 'false'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_size:   The
 *                 default value is '12'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_font_family:   The
 *                 default value is 'sans'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_search_window:   The
 *                 default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_intralevel_separation:
 *                 The default value is '4'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_interlevel_separation:
 *                 The default value is '20'.
 *                         <li>
 *                 gpudb::visualize_image_contour_labels_max_angle:   The
 *                 default value is '60'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_concavity:   The
 *                 default value is '-1'.
 *                         <li>
 *                 gpudb::visualize_image_contour_isochrone_output_table:   The
 *                 default value is ''.
 *                         <li> gpudb::visualize_image_contour_isochrone_image:
 *                 The default value is 'false'.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageContourResponse& GPUdb::visualizeImageContour( const std::vector<std::string>& tableNames,
                                                             const std::string& xColumnName,
                                                             const std::string& yColumnName,
                                                             const std::string& valueColumnName,
                                                             const double minX,
                                                             const double maxX,
                                                             const double minY,
                                                             const double maxY,
                                                             const int32_t width,
                                                             const int32_t height,
                                                             const std::string& projection,
                                                             const std::map<std::string, std::string>& styleOptions,
                                                             const std::map<std::string, std::string>& options,
                                                             VisualizeImageContourResponse& response_ ) const
{
    VisualizeImageContourRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image/contour", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse GPUdb::visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_ ) const
{
    VisualizeImageHeatmapResponse actualResponse_;
    submitRequest("/visualize/image/heatmap", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& GPUdb::visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_,
                                                             VisualizeImageHeatmapResponse& response_ ) const
{
    submitRequest("/visualize/image/heatmap", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param geometryColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_heatmap_EPSG_4326
 *                            <li> gpudb::visualize_image_heatmap_PLATE_CARREE
 *                            <li> gpudb::visualize_image_heatmap_900913
 *                            <li> gpudb::visualize_image_heatmap_EPSG_900913
 *                            <li> gpudb::visualize_image_heatmap_102100
 *                            <li> gpudb::visualize_image_heatmap_EPSG_102100
 *                            <li> gpudb::visualize_image_heatmap_3857
 *                            <li> gpudb::visualize_image_heatmap_EPSG_3857
 *                            <li> gpudb::visualize_image_heatmap_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_heatmap_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_jet
 *                              <li> gpudb::visualize_image_heatmap_accent
 *                              <li> gpudb::visualize_image_heatmap_afmhot
 *                              <li> gpudb::visualize_image_heatmap_autumn
 *                              <li> gpudb::visualize_image_heatmap_binary
 *                              <li> gpudb::visualize_image_heatmap_blues
 *                              <li> gpudb::visualize_image_heatmap_bone
 *                              <li> gpudb::visualize_image_heatmap_brbg
 *                              <li> gpudb::visualize_image_heatmap_brg
 *                              <li> gpudb::visualize_image_heatmap_bugn
 *                              <li> gpudb::visualize_image_heatmap_bupu
 *                              <li> gpudb::visualize_image_heatmap_bwr
 *                              <li> gpudb::visualize_image_heatmap_cmrmap
 *                              <li> gpudb::visualize_image_heatmap_cool
 *                              <li> gpudb::visualize_image_heatmap_coolwarm
 *                              <li> gpudb::visualize_image_heatmap_copper
 *                              <li> gpudb::visualize_image_heatmap_cubehelix
 *                              <li> gpudb::visualize_image_heatmap_dark2
 *                              <li> gpudb::visualize_image_heatmap_flag
 *                              <li> gpudb::visualize_image_heatmap_gist_earth
 *                              <li> gpudb::visualize_image_heatmap_gist_gray
 *                              <li> gpudb::visualize_image_heatmap_gist_heat
 *                              <li> gpudb::visualize_image_heatmap_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gist_rainbow
 *                              <li> gpudb::visualize_image_heatmap_gist_stern
 *                              <li> gpudb::visualize_image_heatmap_gist_yarg
 *                              <li> gpudb::visualize_image_heatmap_gnbu
 *                              <li> gpudb::visualize_image_heatmap_gnuplot2
 *                              <li> gpudb::visualize_image_heatmap_gnuplot
 *                              <li> gpudb::visualize_image_heatmap_gray
 *                              <li> gpudb::visualize_image_heatmap_greens
 *                              <li> gpudb::visualize_image_heatmap_greys
 *                              <li> gpudb::visualize_image_heatmap_hot
 *                              <li> gpudb::visualize_image_heatmap_hsv
 *                              <li> gpudb::visualize_image_heatmap_inferno
 *                              <li> gpudb::visualize_image_heatmap_magma
 *                              <li>
 *                      gpudb::visualize_image_heatmap_nipy_spectral
 *                              <li> gpudb::visualize_image_heatmap_ocean
 *                              <li> gpudb::visualize_image_heatmap_oranges
 *                              <li> gpudb::visualize_image_heatmap_orrd
 *                              <li> gpudb::visualize_image_heatmap_paired
 *                              <li> gpudb::visualize_image_heatmap_pastel1
 *                              <li> gpudb::visualize_image_heatmap_pastel2
 *                              <li> gpudb::visualize_image_heatmap_pink
 *                              <li> gpudb::visualize_image_heatmap_piyg
 *                              <li> gpudb::visualize_image_heatmap_plasma
 *                              <li> gpudb::visualize_image_heatmap_prgn
 *                              <li> gpudb::visualize_image_heatmap_prism
 *                              <li> gpudb::visualize_image_heatmap_pubu
 *                              <li> gpudb::visualize_image_heatmap_pubugn
 *                              <li> gpudb::visualize_image_heatmap_puor
 *                              <li> gpudb::visualize_image_heatmap_purd
 *                              <li> gpudb::visualize_image_heatmap_purples
 *                              <li> gpudb::visualize_image_heatmap_rainbow
 *                              <li> gpudb::visualize_image_heatmap_rdbu
 *                              <li> gpudb::visualize_image_heatmap_rdgy
 *                              <li> gpudb::visualize_image_heatmap_rdpu
 *                              <li> gpudb::visualize_image_heatmap_rdylbu
 *                              <li> gpudb::visualize_image_heatmap_rdylgn
 *                              <li> gpudb::visualize_image_heatmap_reds
 *                              <li> gpudb::visualize_image_heatmap_seismic
 *                              <li> gpudb::visualize_image_heatmap_set1
 *                              <li> gpudb::visualize_image_heatmap_set2
 *                              <li> gpudb::visualize_image_heatmap_set3
 *                              <li> gpudb::visualize_image_heatmap_spectral
 *                              <li> gpudb::visualize_image_heatmap_spring
 *                              <li> gpudb::visualize_image_heatmap_summer
 *                              <li> gpudb::visualize_image_heatmap_terrain
 *                              <li> gpudb::visualize_image_heatmap_viridis
 *                              <li> gpudb::visualize_image_heatmap_winter
 *                              <li> gpudb::visualize_image_heatmap_wistia
 *                              <li> gpudb::visualize_image_heatmap_ylgn
 *                              <li> gpudb::visualize_image_heatmap_ylgnbu
 *                              <li> gpudb::visualize_image_heatmap_ylorbr
 *                              <li> gpudb::visualize_image_heatmap_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_heatmap_jet.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_blur_radius:   The
 *                      default value is '5'.
 *                              <li> gpudb::visualize_image_heatmap_bg_color
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_start_color:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_end_color:
 *                      The default value is 'FF0000'.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse GPUdb::visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                            const std::string& xColumnName,
                                                            const std::string& yColumnName,
                                                            const std::string& valueColumnName,
                                                            const std::string& geometryColumnName,
                                                            const double minX,
                                                            const double maxX,
                                                            const double minY,
                                                            const double maxY,
                                                            const int32_t width,
                                                            const int32_t height,
                                                            const std::string& projection,
                                                            const std::map<std::string, std::string>& styleOptions,
                                                            const std::map<std::string, std::string>& options ) const
{
    VisualizeImageHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageHeatmapResponse actualResponse_;
    submitRequest("/visualize/image/heatmap", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param geometryColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_heatmap_EPSG_4326
 *                            <li> gpudb::visualize_image_heatmap_PLATE_CARREE
 *                            <li> gpudb::visualize_image_heatmap_900913
 *                            <li> gpudb::visualize_image_heatmap_EPSG_900913
 *                            <li> gpudb::visualize_image_heatmap_102100
 *                            <li> gpudb::visualize_image_heatmap_EPSG_102100
 *                            <li> gpudb::visualize_image_heatmap_3857
 *                            <li> gpudb::visualize_image_heatmap_EPSG_3857
 *                            <li> gpudb::visualize_image_heatmap_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_heatmap_PLATE_CARREE.
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_image_heatmap_jet
 *                              <li> gpudb::visualize_image_heatmap_accent
 *                              <li> gpudb::visualize_image_heatmap_afmhot
 *                              <li> gpudb::visualize_image_heatmap_autumn
 *                              <li> gpudb::visualize_image_heatmap_binary
 *                              <li> gpudb::visualize_image_heatmap_blues
 *                              <li> gpudb::visualize_image_heatmap_bone
 *                              <li> gpudb::visualize_image_heatmap_brbg
 *                              <li> gpudb::visualize_image_heatmap_brg
 *                              <li> gpudb::visualize_image_heatmap_bugn
 *                              <li> gpudb::visualize_image_heatmap_bupu
 *                              <li> gpudb::visualize_image_heatmap_bwr
 *                              <li> gpudb::visualize_image_heatmap_cmrmap
 *                              <li> gpudb::visualize_image_heatmap_cool
 *                              <li> gpudb::visualize_image_heatmap_coolwarm
 *                              <li> gpudb::visualize_image_heatmap_copper
 *                              <li> gpudb::visualize_image_heatmap_cubehelix
 *                              <li> gpudb::visualize_image_heatmap_dark2
 *                              <li> gpudb::visualize_image_heatmap_flag
 *                              <li> gpudb::visualize_image_heatmap_gist_earth
 *                              <li> gpudb::visualize_image_heatmap_gist_gray
 *                              <li> gpudb::visualize_image_heatmap_gist_heat
 *                              <li> gpudb::visualize_image_heatmap_gist_ncar
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gist_rainbow
 *                              <li> gpudb::visualize_image_heatmap_gist_stern
 *                              <li> gpudb::visualize_image_heatmap_gist_yarg
 *                              <li> gpudb::visualize_image_heatmap_gnbu
 *                              <li> gpudb::visualize_image_heatmap_gnuplot2
 *                              <li> gpudb::visualize_image_heatmap_gnuplot
 *                              <li> gpudb::visualize_image_heatmap_gray
 *                              <li> gpudb::visualize_image_heatmap_greens
 *                              <li> gpudb::visualize_image_heatmap_greys
 *                              <li> gpudb::visualize_image_heatmap_hot
 *                              <li> gpudb::visualize_image_heatmap_hsv
 *                              <li> gpudb::visualize_image_heatmap_inferno
 *                              <li> gpudb::visualize_image_heatmap_magma
 *                              <li>
 *                      gpudb::visualize_image_heatmap_nipy_spectral
 *                              <li> gpudb::visualize_image_heatmap_ocean
 *                              <li> gpudb::visualize_image_heatmap_oranges
 *                              <li> gpudb::visualize_image_heatmap_orrd
 *                              <li> gpudb::visualize_image_heatmap_paired
 *                              <li> gpudb::visualize_image_heatmap_pastel1
 *                              <li> gpudb::visualize_image_heatmap_pastel2
 *                              <li> gpudb::visualize_image_heatmap_pink
 *                              <li> gpudb::visualize_image_heatmap_piyg
 *                              <li> gpudb::visualize_image_heatmap_plasma
 *                              <li> gpudb::visualize_image_heatmap_prgn
 *                              <li> gpudb::visualize_image_heatmap_prism
 *                              <li> gpudb::visualize_image_heatmap_pubu
 *                              <li> gpudb::visualize_image_heatmap_pubugn
 *                              <li> gpudb::visualize_image_heatmap_puor
 *                              <li> gpudb::visualize_image_heatmap_purd
 *                              <li> gpudb::visualize_image_heatmap_purples
 *                              <li> gpudb::visualize_image_heatmap_rainbow
 *                              <li> gpudb::visualize_image_heatmap_rdbu
 *                              <li> gpudb::visualize_image_heatmap_rdgy
 *                              <li> gpudb::visualize_image_heatmap_rdpu
 *                              <li> gpudb::visualize_image_heatmap_rdylbu
 *                              <li> gpudb::visualize_image_heatmap_rdylgn
 *                              <li> gpudb::visualize_image_heatmap_reds
 *                              <li> gpudb::visualize_image_heatmap_seismic
 *                              <li> gpudb::visualize_image_heatmap_set1
 *                              <li> gpudb::visualize_image_heatmap_set2
 *                              <li> gpudb::visualize_image_heatmap_set3
 *                              <li> gpudb::visualize_image_heatmap_spectral
 *                              <li> gpudb::visualize_image_heatmap_spring
 *                              <li> gpudb::visualize_image_heatmap_summer
 *                              <li> gpudb::visualize_image_heatmap_terrain
 *                              <li> gpudb::visualize_image_heatmap_viridis
 *                              <li> gpudb::visualize_image_heatmap_winter
 *                              <li> gpudb::visualize_image_heatmap_wistia
 *                              <li> gpudb::visualize_image_heatmap_ylgn
 *                              <li> gpudb::visualize_image_heatmap_ylgnbu
 *                              <li> gpudb::visualize_image_heatmap_ylorbr
 *                              <li> gpudb::visualize_image_heatmap_ylorrd
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_image_heatmap_jet.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_blur_radius:   The
 *                      default value is '5'.
 *                              <li> gpudb::visualize_image_heatmap_bg_color
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_start_color:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_image_heatmap_gradient_end_color:
 *                      The default value is 'FF0000'.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& GPUdb::visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                             const std::string& xColumnName,
                                                             const std::string& yColumnName,
                                                             const std::string& valueColumnName,
                                                             const std::string& geometryColumnName,
                                                             const double minX,
                                                             const double maxX,
                                                             const double minY,
                                                             const double maxY,
                                                             const int32_t width,
                                                             const int32_t height,
                                                             const std::string& projection,
                                                             const std::map<std::string, std::string>& styleOptions,
                                                             const std::map<std::string, std::string>& options,
                                                             VisualizeImageHeatmapResponse& response_ ) const
{
    VisualizeImageHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image/heatmap", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse GPUdb::visualizeImageLabels( const VisualizeImageLabelsRequest& request_ ) const
{
    VisualizeImageLabelsResponse actualResponse_;
    submitRequest("/visualize/image/labels", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& GPUdb::visualizeImageLabels( const VisualizeImageLabelsRequest& request_,
                                                           VisualizeImageLabelsResponse& response_ ) const
{
    submitRequest("/visualize/image/labels", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableName
 * @param xColumnName
 * @param yColumnName
 * @param xOffset
 * @param yOffset
 * @param textString
 * @param font
 * @param textColor
 * @param textAngle
 * @param textScale
 * @param drawBox
 * @param drawLeader
 * @param lineWidth
 * @param lineColor
 * @param fillColor
 * @param leaderXColumnName
 * @param leaderYColumnName
 * @param filter
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_labels_EPSG_4326
 *                            <li> gpudb::visualize_image_labels_PLATE_CARREE
 *                            <li> gpudb::visualize_image_labels_900913
 *                            <li> gpudb::visualize_image_labels_EPSG_900913
 *                            <li> gpudb::visualize_image_labels_102100
 *                            <li> gpudb::visualize_image_labels_EPSG_102100
 *                            <li> gpudb::visualize_image_labels_3857
 *                            <li> gpudb::visualize_image_labels_EPSG_3857
 *                            <li> gpudb::visualize_image_labels_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_labels_PLATE_CARREE.
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse GPUdb::visualizeImageLabels( const std::string& tableName,
                                                          const std::string& xColumnName,
                                                          const std::string& yColumnName,
                                                          const std::string& xOffset,
                                                          const std::string& yOffset,
                                                          const std::string& textString,
                                                          const std::string& font,
                                                          const std::string& textColor,
                                                          const std::string& textAngle,
                                                          const std::string& textScale,
                                                          const std::string& drawBox,
                                                          const std::string& drawLeader,
                                                          const std::string& lineWidth,
                                                          const std::string& lineColor,
                                                          const std::string& fillColor,
                                                          const std::string& leaderXColumnName,
                                                          const std::string& leaderYColumnName,
                                                          const std::string& filter,
                                                          const double minX,
                                                          const double maxX,
                                                          const double minY,
                                                          const double maxY,
                                                          const int32_t width,
                                                          const int32_t height,
                                                          const std::string& projection,
                                                          const std::map<std::string, std::string>& options ) const
{
    VisualizeImageLabelsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.xOffset = xOffset;
    actualRequest_.yOffset = yOffset;
    actualRequest_.textString = textString;
    actualRequest_.font = font;
    actualRequest_.textColor = textColor;
    actualRequest_.textAngle = textAngle;
    actualRequest_.textScale = textScale;
    actualRequest_.drawBox = drawBox;
    actualRequest_.drawLeader = drawLeader;
    actualRequest_.lineWidth = lineWidth;
    actualRequest_.lineColor = lineColor;
    actualRequest_.fillColor = fillColor;
    actualRequest_.leaderXColumnName = leaderXColumnName;
    actualRequest_.leaderYColumnName = leaderYColumnName;
    actualRequest_.filter = filter;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.options = options;
    VisualizeImageLabelsResponse actualResponse_;
    submitRequest("/visualize/image/labels", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableName
 * @param xColumnName
 * @param yColumnName
 * @param xOffset
 * @param yOffset
 * @param textString
 * @param font
 * @param textColor
 * @param textAngle
 * @param textScale
 * @param drawBox
 * @param drawLeader
 * @param lineWidth
 * @param lineColor
 * @param fillColor
 * @param leaderXColumnName
 * @param leaderYColumnName
 * @param filter
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_image_labels_EPSG_4326
 *                            <li> gpudb::visualize_image_labels_PLATE_CARREE
 *                            <li> gpudb::visualize_image_labels_900913
 *                            <li> gpudb::visualize_image_labels_EPSG_900913
 *                            <li> gpudb::visualize_image_labels_102100
 *                            <li> gpudb::visualize_image_labels_EPSG_102100
 *                            <li> gpudb::visualize_image_labels_3857
 *                            <li> gpudb::visualize_image_labels_EPSG_3857
 *                            <li> gpudb::visualize_image_labels_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_image_labels_PLATE_CARREE.
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& GPUdb::visualizeImageLabels( const std::string& tableName,
                                                           const std::string& xColumnName,
                                                           const std::string& yColumnName,
                                                           const std::string& xOffset,
                                                           const std::string& yOffset,
                                                           const std::string& textString,
                                                           const std::string& font,
                                                           const std::string& textColor,
                                                           const std::string& textAngle,
                                                           const std::string& textScale,
                                                           const std::string& drawBox,
                                                           const std::string& drawLeader,
                                                           const std::string& lineWidth,
                                                           const std::string& lineColor,
                                                           const std::string& fillColor,
                                                           const std::string& leaderXColumnName,
                                                           const std::string& leaderYColumnName,
                                                           const std::string& filter,
                                                           const double minX,
                                                           const double maxX,
                                                           const double minY,
                                                           const double maxY,
                                                           const int32_t width,
                                                           const int32_t height,
                                                           const std::string& projection,
                                                           const std::map<std::string, std::string>& options,
                                                           VisualizeImageLabelsResponse& response_ ) const
{
    VisualizeImageLabelsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.xOffset = xOffset;
    actualRequest_.yOffset = yOffset;
    actualRequest_.textString = textString;
    actualRequest_.font = font;
    actualRequest_.textColor = textColor;
    actualRequest_.textAngle = textAngle;
    actualRequest_.textScale = textScale;
    actualRequest_.drawBox = drawBox;
    actualRequest_.drawLeader = drawLeader;
    actualRequest_.lineWidth = lineWidth;
    actualRequest_.lineColor = lineColor;
    actualRequest_.fillColor = fillColor;
    actualRequest_.leaderXColumnName = leaderXColumnName;
    actualRequest_.leaderYColumnName = leaderYColumnName;
    actualRequest_.filter = filter;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.options = options;
    submitRequest("/visualize/image/labels", actualRequest_, response_, false);
    return response_;
}


/**
 * Generate an image containing isolines for travel results using an existing
 * graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information on graphs.
 * .
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeIsochroneResponse GPUdb::visualizeIsochrone( const VisualizeIsochroneRequest& request_ ) const
{
    VisualizeIsochroneResponse actualResponse_;
    submitRequest("/visualize/isochrone", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Generate an image containing isolines for travel results using an existing
 * graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information on graphs.
 * .
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeIsochroneResponse& GPUdb::visualizeIsochrone( const VisualizeIsochroneRequest& request_,
                                                       VisualizeIsochroneResponse& response_ ) const
{
    submitRequest("/visualize/isochrone", request_, response_, false);
    return response_;
}


/**
 * Generate an image containing isolines for travel results using an existing
 * graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information on graphs.
 * .
 * 
 * @param graphName  Name of the graph on which the isochrone is to be
 *                   computed.
 * @param sourceNode  Starting vertex on the underlying graph from/to which the
 *                    isochrones are created.
 * @param maxSolutionRadius  Extent of the search radius around @a sourceNode.
 *                           Set to '-1.0' for unrestricted search radius.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing graph. Weights must be specified using <a
 *                        href="../../graph_solver/network_graph_solver.html#identifiers"
 *                        target="_top">identifiers</a>; identifiers are
 *                        grouped as <a
 *                        href="../../graph_solver/network_graph_solver.html#id-combos"
 *                        target="_top">combinations</a>. Identifiers can be
 *                        used with existing column names, e.g., 'table.column
 *                        AS WEIGHTS_EDGE_ID', or expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED'. Any
 *                        provided weights will be added (in the case of
 *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with (in
 *                        the case of 'WEIGHTS_FACTORSPECIFIED') the existing
 *                        weight(s).
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', or expressions, e.g., 'column/2
 *                      AS RESTRICTIONS_VALUECOMPARED'. If @a
 *                      remove_previous_restrictions is set to @a true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. If @a remove_previous_restrictions is set
 *                      to @a false, any provided restrictions will be added
 *                      (in the case of 'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param numLevels  Number of equally-separated isochrones to compute.
 * @param generateImage  If set to @a true, generates a PNG image of the
 *                       isochrones in the response.
 *                       <ul>
 *                               <li> gpudb::visualize_isochrone_true
 *                               <li> gpudb::visualize_isochrone_false
 *                       </ul>
 *                       The default value is gpudb::visualize_isochrone_true.
 * @param levelsTable  Name of the table to output the isochrones, containing
 *                     levels and their corresponding WKT geometry. If no value
 *                     is provided, the table is not generated.
 * @param styleOptions  Various style related options of the isochrone image.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_line_size: The
 *                      width of the contour lines in pixels.  The default
 *                      value is '3'.
 *                              <li> gpudb::visualize_isochrone_color: Color of
 *                      generated isolines. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      If alpha is specified and flooded contours are enabled,
 *                      it will be used for as the transparency of the latter.
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_isochrone_bg_color: When
 *                      @a generateImage is set to @a true, background color of
 *                      the generated image. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_isochrone_text_color:
 *                      When @a add_labels is set to @a true, color for the
 *                      labels. All color values must be in the format RRGGBB
 *                      or AARRGGBB (to specify the alpha value).  The default
 *                      value is 'FF000000'.
 *                              <li> gpudb::visualize_isochrone_colormap:
 *                      Colormap for contours or fill-in regions when
 *                      applicable. All color values must be in the format
 *                      RRGGBB or AARRGGBB (to specify the alpha value)
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_jet
 *                              <li> gpudb::visualize_isochrone_accent
 *                              <li> gpudb::visualize_isochrone_afmhot
 *                              <li> gpudb::visualize_isochrone_autumn
 *                              <li> gpudb::visualize_isochrone_binary
 *                              <li> gpudb::visualize_isochrone_blues
 *                              <li> gpudb::visualize_isochrone_bone
 *                              <li> gpudb::visualize_isochrone_brbg
 *                              <li> gpudb::visualize_isochrone_brg
 *                              <li> gpudb::visualize_isochrone_bugn
 *                              <li> gpudb::visualize_isochrone_bupu
 *                              <li> gpudb::visualize_isochrone_bwr
 *                              <li> gpudb::visualize_isochrone_cmrmap
 *                              <li> gpudb::visualize_isochrone_cool
 *                              <li> gpudb::visualize_isochrone_coolwarm
 *                              <li> gpudb::visualize_isochrone_copper
 *                              <li> gpudb::visualize_isochrone_cubehelix
 *                              <li> gpudb::visualize_isochrone_dark2
 *                              <li> gpudb::visualize_isochrone_flag
 *                              <li> gpudb::visualize_isochrone_gist_earth
 *                              <li> gpudb::visualize_isochrone_gist_gray
 *                              <li> gpudb::visualize_isochrone_gist_heat
 *                              <li> gpudb::visualize_isochrone_gist_ncar
 *                              <li> gpudb::visualize_isochrone_gist_rainbow
 *                              <li> gpudb::visualize_isochrone_gist_stern
 *                              <li> gpudb::visualize_isochrone_gist_yarg
 *                              <li> gpudb::visualize_isochrone_gnbu
 *                              <li> gpudb::visualize_isochrone_gnuplot2
 *                              <li> gpudb::visualize_isochrone_gnuplot
 *                              <li> gpudb::visualize_isochrone_gray
 *                              <li> gpudb::visualize_isochrone_greens
 *                              <li> gpudb::visualize_isochrone_greys
 *                              <li> gpudb::visualize_isochrone_hot
 *                              <li> gpudb::visualize_isochrone_hsv
 *                              <li> gpudb::visualize_isochrone_inferno
 *                              <li> gpudb::visualize_isochrone_magma
 *                              <li> gpudb::visualize_isochrone_nipy_spectral
 *                              <li> gpudb::visualize_isochrone_ocean
 *                              <li> gpudb::visualize_isochrone_oranges
 *                              <li> gpudb::visualize_isochrone_orrd
 *                              <li> gpudb::visualize_isochrone_paired
 *                              <li> gpudb::visualize_isochrone_pastel1
 *                              <li> gpudb::visualize_isochrone_pastel2
 *                              <li> gpudb::visualize_isochrone_pink
 *                              <li> gpudb::visualize_isochrone_piyg
 *                              <li> gpudb::visualize_isochrone_plasma
 *                              <li> gpudb::visualize_isochrone_prgn
 *                              <li> gpudb::visualize_isochrone_prism
 *                              <li> gpudb::visualize_isochrone_pubu
 *                              <li> gpudb::visualize_isochrone_pubugn
 *                              <li> gpudb::visualize_isochrone_puor
 *                              <li> gpudb::visualize_isochrone_purd
 *                              <li> gpudb::visualize_isochrone_purples
 *                              <li> gpudb::visualize_isochrone_rainbow
 *                              <li> gpudb::visualize_isochrone_rdbu
 *                              <li> gpudb::visualize_isochrone_rdgy
 *                              <li> gpudb::visualize_isochrone_rdpu
 *                              <li> gpudb::visualize_isochrone_rdylbu
 *                              <li> gpudb::visualize_isochrone_rdylgn
 *                              <li> gpudb::visualize_isochrone_reds
 *                              <li> gpudb::visualize_isochrone_seismic
 *                              <li> gpudb::visualize_isochrone_set1
 *                              <li> gpudb::visualize_isochrone_set2
 *                              <li> gpudb::visualize_isochrone_set3
 *                              <li> gpudb::visualize_isochrone_spectral
 *                              <li> gpudb::visualize_isochrone_spring
 *                              <li> gpudb::visualize_isochrone_summer
 *                              <li> gpudb::visualize_isochrone_terrain
 *                              <li> gpudb::visualize_isochrone_viridis
 *                              <li> gpudb::visualize_isochrone_winter
 *                              <li> gpudb::visualize_isochrone_wistia
 *                              <li> gpudb::visualize_isochrone_ylgn
 *                              <li> gpudb::visualize_isochrone_ylgnbu
 *                              <li> gpudb::visualize_isochrone_ylorbr
 *                              <li> gpudb::visualize_isochrone_ylorrd
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_jet.
 *                      </ul>
 * @param solveOptions  Solver specific parameters
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_isochrone_remove_previous_restrictions:
 *                      Ignore the restrictions applied to the graph during the
 *                      creation stage and only use the restrictions specified
 *                      in this request if set to @a true.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_true
 *                              <li> gpudb::visualize_isochrone_false
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_false.
 *                              <li>
 *                      gpudb::visualize_isochrone_restriction_threshold_value:
 *                      Value-based restriction comparison. Any node or edge
 *                      with a 'RESTRICTIONS_VALUECOMPARED' value greater than
 *                      the @a restriction_threshold_value will not be included
 *                      in the solution.
 *                              <li>
 *                      gpudb::visualize_isochrone_uniform_weights: When
 *                      specified, assigns the given value to all the edges in
 *                      the graph. Note that weights provided in @a
 *                      weightsOnEdges will override this value.
 *                      </ul>
 * @param contourOptions  Solver specific parameters
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_projection:
 *                        Spatial Reference System (i.e. EPSG Code).
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_3857
 *                                <li> gpudb::visualize_isochrone_102100
 *                                <li> gpudb::visualize_isochrone_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_4326
 *                                <li> gpudb::visualize_isochrone_PLATE_CARREE
 *                                <li> gpudb::visualize_isochrone_EPSG_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_102100
 *                                <li> gpudb::visualize_isochrone_EPSG_3857
 *                                <li> gpudb::visualize_isochrone_WEB_MERCATOR
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_PLATE_CARREE.
 *                                <li> gpudb::visualize_isochrone_width: When
 *                        @a generateImage is set to @a true, width of the
 *                        generated image.  The default value is '512'.
 *                                <li> gpudb::visualize_isochrone_height: When
 *                        @a generateImage is set to @a true, height of the
 *                        generated image. If the default value is used, the @a
 *                        height is set to the value resulting from multiplying
 *                        the aspect ratio by the @a width.  The default value
 *                        is '-1'.
 *                                <li>
 *                        gpudb::visualize_isochrone_search_radius: When
 *                        interpolating the graph solution to generate the
 *                        isochrone, neighborhood of influence of sample data
 *                        (in percent of the image/grid).  The default value is
 *                        '20'.
 *                                <li> gpudb::visualize_isochrone_grid_size:
 *                        When interpolating the graph solution to generate the
 *                        isochrone, number of subdivisions along the x axis
 *                        when building the grid (the y is computed using the
 *                        aspect ratio of the output image).  The default value
 *                        is '100'.
 *                                <li>
 *                        gpudb::visualize_isochrone_color_isolines: Color each
 *                        isoline according to the colormap; otherwise, use the
 *                        foreground color.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is gpudb::visualize_isochrone_true.
 *                                <li> gpudb::visualize_isochrone_add_labels:
 *                        If set to @a true, add labels to the isolines.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_false.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_size: When @a
 *                        add_labels is set to @a true, size of the font (in
 *                        pixels) to use for labels.  The default value is
 *                        '12'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_family: When
 *                        @a add_labels is set to @a true, font name to be used
 *                        when adding labels.  The default value is 'arial'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_search_window: When
 *                        @a add_labels is set to @a true, a search window is
 *                        used to rate the local quality of each isoline.
 *                        Smooth, continuous, long stretches with relatively
 *                        flat angles are favored. The provided value is
 *                        multiplied by the @a labels_font_size to calculate
 *                        the final window size.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_intralevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the  distance (in multiples of the @a
 *                        labels_font_size) to use when separating labels of
 *                        different values.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_interlevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the distance (in percent of the total
 *                        window size) to use when separating labels of the
 *                        same value.  The default value is '20'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_max_angle: When @a
 *                        add_labels is set to @a true, maximum angle (in
 *                        degrees) from the vertical to use when adding labels.
 *                        The default value is '60'.
 *                        </ul>
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_solve_table: Name of
 *                 the table to host intermediate solve results containing the
 *                 position and cost for each vertex in the graph. If the
 *                 default value is used, a temporary table is created and
 *                 deleted once the solution is calculated.  The default value
 *                 is ''.
 *                         <li> gpudb::visualize_isochrone_is_replicated: If
 *                 set to @a true, replicate the @a solve_table.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true
 *                         <li> gpudb::visualize_isochrone_false
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_true.
 *                         <li> gpudb::visualize_isochrone_data_min_x: Lower
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_x: Upper
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_min_y: Lower
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_y: Upper
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_concavity_level:
 *                 Factor to qualify the concavity of the isochrone curves. The
 *                 lower the value, the more convex (with '0' being completely
 *                 convex and '1' being the most concave).  The default value
 *                 is '0.5'.
 *                         <li>
 *                 gpudb::visualize_isochrone_use_priority_queue_solvers: sets
 *                 the solver methods explicitly if true
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true: uses the
 *                 solvers scheduled for 'shortest_path' and
 *                 'inverse_shortest_path' based on solve_direction
 *                         <li> gpudb::visualize_isochrone_false: uses the
 *                 solvers 'priority_queue' and 'inverse_priority_queue' based
 *                 on solve_direction
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_false.
 *                         <li> gpudb::visualize_isochrone_solve_direction:
 *                 Specify whether we are going to the source node, or starting
 *                 from it.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_from_source:
 *                 Shortest path to get to the source (inverse Dijkstra)
 *                         <li> gpudb::visualize_isochrone_to_source: Shortest
 *                 path to source (Dijkstra)
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_from_source.
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeIsochroneResponse GPUdb::visualizeIsochrone( const std::string& graphName,
                                                      const std::string& sourceNode,
                                                      const double maxSolutionRadius,
                                                      const std::vector<std::string>& weightsOnEdges,
                                                      const std::vector<std::string>& restrictions,
                                                      const int32_t numLevels,
                                                      const bool generateImage,
                                                      const std::string& levelsTable,
                                                      const std::map<std::string, std::string>& styleOptions,
                                                      const std::map<std::string, std::string>& solveOptions,
                                                      const std::map<std::string, std::string>& contourOptions,
                                                      const std::map<std::string, std::string>& options ) const
{
    VisualizeIsochroneRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.sourceNode = sourceNode;
    actualRequest_.maxSolutionRadius = maxSolutionRadius;
    actualRequest_.weightsOnEdges = weightsOnEdges;
    actualRequest_.restrictions = restrictions;
    actualRequest_.numLevels = numLevels;
    actualRequest_.generateImage = generateImage;
    actualRequest_.levelsTable = levelsTable;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.solveOptions = solveOptions;
    actualRequest_.contourOptions = contourOptions;
    actualRequest_.options = options;
    VisualizeIsochroneResponse actualResponse_;
    submitRequest("/visualize/isochrone", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Generate an image containing isolines for travel results using an existing
 * graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See <a href="../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information on graphs.
 * .
 * 
 * @param graphName  Name of the graph on which the isochrone is to be
 *                   computed.
 * @param sourceNode  Starting vertex on the underlying graph from/to which the
 *                    isochrones are created.
 * @param maxSolutionRadius  Extent of the search radius around @a sourceNode.
 *                           Set to '-1.0' for unrestricted search radius.
 * @param weightsOnEdges  Additional weights to apply to the edges of an
 *                        existing graph. Weights must be specified using <a
 *                        href="../../graph_solver/network_graph_solver.html#identifiers"
 *                        target="_top">identifiers</a>; identifiers are
 *                        grouped as <a
 *                        href="../../graph_solver/network_graph_solver.html#id-combos"
 *                        target="_top">combinations</a>. Identifiers can be
 *                        used with existing column names, e.g., 'table.column
 *                        AS WEIGHTS_EDGE_ID', or expressions, e.g.,
 *                        'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED'. Any
 *                        provided weights will be added (in the case of
 *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with (in
 *                        the case of 'WEIGHTS_FACTORSPECIFIED') the existing
 *                        weight(s).
 * @param restrictions  Additional restrictions to apply to the nodes/edges of
 *                      an existing graph. Restrictions must be specified using
 *                      <a
 *                      href="../../graph_solver/network_graph_solver.html#identifiers"
 *                      target="_top">identifiers</a>; identifiers are grouped
 *                      as <a
 *                      href="../../graph_solver/network_graph_solver.html#id-combos"
 *                      target="_top">combinations</a>. Identifiers can be used
 *                      with existing column names, e.g., 'table.column AS
 *                      RESTRICTIONS_EDGE_ID', or expressions, e.g., 'column/2
 *                      AS RESTRICTIONS_VALUECOMPARED'. If @a
 *                      remove_previous_restrictions is set to @a true, any
 *                      provided restrictions will replace the existing
 *                      restrictions. If @a remove_previous_restrictions is set
 *                      to @a false, any provided restrictions will be added
 *                      (in the case of 'RESTRICTIONS_VALUECOMPARED') to or
 *                      replaced (in the case of 'RESTRICTIONS_ONOFFCOMPARED').
 * @param numLevels  Number of equally-separated isochrones to compute.
 * @param generateImage  If set to @a true, generates a PNG image of the
 *                       isochrones in the response.
 *                       <ul>
 *                               <li> gpudb::visualize_isochrone_true
 *                               <li> gpudb::visualize_isochrone_false
 *                       </ul>
 *                       The default value is gpudb::visualize_isochrone_true.
 * @param levelsTable  Name of the table to output the isochrones, containing
 *                     levels and their corresponding WKT geometry. If no value
 *                     is provided, the table is not generated.
 * @param styleOptions  Various style related options of the isochrone image.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_line_size: The
 *                      width of the contour lines in pixels.  The default
 *                      value is '3'.
 *                              <li> gpudb::visualize_isochrone_color: Color of
 *                      generated isolines. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      If alpha is specified and flooded contours are enabled,
 *                      it will be used for as the transparency of the latter.
 *                      The default value is 'FF696969'.
 *                              <li> gpudb::visualize_isochrone_bg_color: When
 *                      @a generateImage is set to @a true, background color of
 *                      the generated image. All color values must be in the
 *                      format RRGGBB or AARRGGBB (to specify the alpha value).
 *                      The default value is '00000000'.
 *                              <li> gpudb::visualize_isochrone_text_color:
 *                      When @a add_labels is set to @a true, color for the
 *                      labels. All color values must be in the format RRGGBB
 *                      or AARRGGBB (to specify the alpha value).  The default
 *                      value is 'FF000000'.
 *                              <li> gpudb::visualize_isochrone_colormap:
 *                      Colormap for contours or fill-in regions when
 *                      applicable. All color values must be in the format
 *                      RRGGBB or AARRGGBB (to specify the alpha value)
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_jet
 *                              <li> gpudb::visualize_isochrone_accent
 *                              <li> gpudb::visualize_isochrone_afmhot
 *                              <li> gpudb::visualize_isochrone_autumn
 *                              <li> gpudb::visualize_isochrone_binary
 *                              <li> gpudb::visualize_isochrone_blues
 *                              <li> gpudb::visualize_isochrone_bone
 *                              <li> gpudb::visualize_isochrone_brbg
 *                              <li> gpudb::visualize_isochrone_brg
 *                              <li> gpudb::visualize_isochrone_bugn
 *                              <li> gpudb::visualize_isochrone_bupu
 *                              <li> gpudb::visualize_isochrone_bwr
 *                              <li> gpudb::visualize_isochrone_cmrmap
 *                              <li> gpudb::visualize_isochrone_cool
 *                              <li> gpudb::visualize_isochrone_coolwarm
 *                              <li> gpudb::visualize_isochrone_copper
 *                              <li> gpudb::visualize_isochrone_cubehelix
 *                              <li> gpudb::visualize_isochrone_dark2
 *                              <li> gpudb::visualize_isochrone_flag
 *                              <li> gpudb::visualize_isochrone_gist_earth
 *                              <li> gpudb::visualize_isochrone_gist_gray
 *                              <li> gpudb::visualize_isochrone_gist_heat
 *                              <li> gpudb::visualize_isochrone_gist_ncar
 *                              <li> gpudb::visualize_isochrone_gist_rainbow
 *                              <li> gpudb::visualize_isochrone_gist_stern
 *                              <li> gpudb::visualize_isochrone_gist_yarg
 *                              <li> gpudb::visualize_isochrone_gnbu
 *                              <li> gpudb::visualize_isochrone_gnuplot2
 *                              <li> gpudb::visualize_isochrone_gnuplot
 *                              <li> gpudb::visualize_isochrone_gray
 *                              <li> gpudb::visualize_isochrone_greens
 *                              <li> gpudb::visualize_isochrone_greys
 *                              <li> gpudb::visualize_isochrone_hot
 *                              <li> gpudb::visualize_isochrone_hsv
 *                              <li> gpudb::visualize_isochrone_inferno
 *                              <li> gpudb::visualize_isochrone_magma
 *                              <li> gpudb::visualize_isochrone_nipy_spectral
 *                              <li> gpudb::visualize_isochrone_ocean
 *                              <li> gpudb::visualize_isochrone_oranges
 *                              <li> gpudb::visualize_isochrone_orrd
 *                              <li> gpudb::visualize_isochrone_paired
 *                              <li> gpudb::visualize_isochrone_pastel1
 *                              <li> gpudb::visualize_isochrone_pastel2
 *                              <li> gpudb::visualize_isochrone_pink
 *                              <li> gpudb::visualize_isochrone_piyg
 *                              <li> gpudb::visualize_isochrone_plasma
 *                              <li> gpudb::visualize_isochrone_prgn
 *                              <li> gpudb::visualize_isochrone_prism
 *                              <li> gpudb::visualize_isochrone_pubu
 *                              <li> gpudb::visualize_isochrone_pubugn
 *                              <li> gpudb::visualize_isochrone_puor
 *                              <li> gpudb::visualize_isochrone_purd
 *                              <li> gpudb::visualize_isochrone_purples
 *                              <li> gpudb::visualize_isochrone_rainbow
 *                              <li> gpudb::visualize_isochrone_rdbu
 *                              <li> gpudb::visualize_isochrone_rdgy
 *                              <li> gpudb::visualize_isochrone_rdpu
 *                              <li> gpudb::visualize_isochrone_rdylbu
 *                              <li> gpudb::visualize_isochrone_rdylgn
 *                              <li> gpudb::visualize_isochrone_reds
 *                              <li> gpudb::visualize_isochrone_seismic
 *                              <li> gpudb::visualize_isochrone_set1
 *                              <li> gpudb::visualize_isochrone_set2
 *                              <li> gpudb::visualize_isochrone_set3
 *                              <li> gpudb::visualize_isochrone_spectral
 *                              <li> gpudb::visualize_isochrone_spring
 *                              <li> gpudb::visualize_isochrone_summer
 *                              <li> gpudb::visualize_isochrone_terrain
 *                              <li> gpudb::visualize_isochrone_viridis
 *                              <li> gpudb::visualize_isochrone_winter
 *                              <li> gpudb::visualize_isochrone_wistia
 *                              <li> gpudb::visualize_isochrone_ylgn
 *                              <li> gpudb::visualize_isochrone_ylgnbu
 *                              <li> gpudb::visualize_isochrone_ylorbr
 *                              <li> gpudb::visualize_isochrone_ylorrd
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_jet.
 *                      </ul>
 * @param solveOptions  Solver specific parameters
 *                      <ul>
 *                              <li>
 *                      gpudb::visualize_isochrone_remove_previous_restrictions:
 *                      Ignore the restrictions applied to the graph during the
 *                      creation stage and only use the restrictions specified
 *                      in this request if set to @a true.
 *                      <ul>
 *                              <li> gpudb::visualize_isochrone_true
 *                              <li> gpudb::visualize_isochrone_false
 *                      </ul>
 *                      The default value is gpudb::visualize_isochrone_false.
 *                              <li>
 *                      gpudb::visualize_isochrone_restriction_threshold_value:
 *                      Value-based restriction comparison. Any node or edge
 *                      with a 'RESTRICTIONS_VALUECOMPARED' value greater than
 *                      the @a restriction_threshold_value will not be included
 *                      in the solution.
 *                              <li>
 *                      gpudb::visualize_isochrone_uniform_weights: When
 *                      specified, assigns the given value to all the edges in
 *                      the graph. Note that weights provided in @a
 *                      weightsOnEdges will override this value.
 *                      </ul>
 * @param contourOptions  Solver specific parameters
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_projection:
 *                        Spatial Reference System (i.e. EPSG Code).
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_3857
 *                                <li> gpudb::visualize_isochrone_102100
 *                                <li> gpudb::visualize_isochrone_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_4326
 *                                <li> gpudb::visualize_isochrone_PLATE_CARREE
 *                                <li> gpudb::visualize_isochrone_EPSG_900913
 *                                <li> gpudb::visualize_isochrone_EPSG_102100
 *                                <li> gpudb::visualize_isochrone_EPSG_3857
 *                                <li> gpudb::visualize_isochrone_WEB_MERCATOR
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_PLATE_CARREE.
 *                                <li> gpudb::visualize_isochrone_width: When
 *                        @a generateImage is set to @a true, width of the
 *                        generated image.  The default value is '512'.
 *                                <li> gpudb::visualize_isochrone_height: When
 *                        @a generateImage is set to @a true, height of the
 *                        generated image. If the default value is used, the @a
 *                        height is set to the value resulting from multiplying
 *                        the aspect ratio by the @a width.  The default value
 *                        is '-1'.
 *                                <li>
 *                        gpudb::visualize_isochrone_search_radius: When
 *                        interpolating the graph solution to generate the
 *                        isochrone, neighborhood of influence of sample data
 *                        (in percent of the image/grid).  The default value is
 *                        '20'.
 *                                <li> gpudb::visualize_isochrone_grid_size:
 *                        When interpolating the graph solution to generate the
 *                        isochrone, number of subdivisions along the x axis
 *                        when building the grid (the y is computed using the
 *                        aspect ratio of the output image).  The default value
 *                        is '100'.
 *                                <li>
 *                        gpudb::visualize_isochrone_color_isolines: Color each
 *                        isoline according to the colormap; otherwise, use the
 *                        foreground color.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is gpudb::visualize_isochrone_true.
 *                                <li> gpudb::visualize_isochrone_add_labels:
 *                        If set to @a true, add labels to the isolines.
 *                        <ul>
 *                                <li> gpudb::visualize_isochrone_true
 *                                <li> gpudb::visualize_isochrone_false
 *                        </ul>
 *                        The default value is
 *                        gpudb::visualize_isochrone_false.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_size: When @a
 *                        add_labels is set to @a true, size of the font (in
 *                        pixels) to use for labels.  The default value is
 *                        '12'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_font_family: When
 *                        @a add_labels is set to @a true, font name to be used
 *                        when adding labels.  The default value is 'arial'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_search_window: When
 *                        @a add_labels is set to @a true, a search window is
 *                        used to rate the local quality of each isoline.
 *                        Smooth, continuous, long stretches with relatively
 *                        flat angles are favored. The provided value is
 *                        multiplied by the @a labels_font_size to calculate
 *                        the final window size.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_intralevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the  distance (in multiples of the @a
 *                        labels_font_size) to use when separating labels of
 *                        different values.  The default value is '4'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_interlevel_separation:
 *                        When @a add_labels is set to @a true, this value
 *                        determines the distance (in percent of the total
 *                        window size) to use when separating labels of the
 *                        same value.  The default value is '20'.
 *                                <li>
 *                        gpudb::visualize_isochrone_labels_max_angle: When @a
 *                        add_labels is set to @a true, maximum angle (in
 *                        degrees) from the vertical to use when adding labels.
 *                        The default value is '60'.
 *                        </ul>
 * @param options  Additional parameters
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_solve_table: Name of
 *                 the table to host intermediate solve results containing the
 *                 position and cost for each vertex in the graph. If the
 *                 default value is used, a temporary table is created and
 *                 deleted once the solution is calculated.  The default value
 *                 is ''.
 *                         <li> gpudb::visualize_isochrone_is_replicated: If
 *                 set to @a true, replicate the @a solve_table.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true
 *                         <li> gpudb::visualize_isochrone_false
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_true.
 *                         <li> gpudb::visualize_isochrone_data_min_x: Lower
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_x: Upper
 *                 bound for the x values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_min_y: Lower
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_data_max_y: Upper
 *                 bound for the y values. If not provided, it will be computed
 *                 from the bounds of the input data.
 *                         <li> gpudb::visualize_isochrone_concavity_level:
 *                 Factor to qualify the concavity of the isochrone curves. The
 *                 lower the value, the more convex (with '0' being completely
 *                 convex and '1' being the most concave).  The default value
 *                 is '0.5'.
 *                         <li>
 *                 gpudb::visualize_isochrone_use_priority_queue_solvers: sets
 *                 the solver methods explicitly if true
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_true: uses the
 *                 solvers scheduled for 'shortest_path' and
 *                 'inverse_shortest_path' based on solve_direction
 *                         <li> gpudb::visualize_isochrone_false: uses the
 *                 solvers 'priority_queue' and 'inverse_priority_queue' based
 *                 on solve_direction
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_false.
 *                         <li> gpudb::visualize_isochrone_solve_direction:
 *                 Specify whether we are going to the source node, or starting
 *                 from it.
 *                 <ul>
 *                         <li> gpudb::visualize_isochrone_from_source:
 *                 Shortest path to get to the source (inverse Dijkstra)
 *                         <li> gpudb::visualize_isochrone_to_source: Shortest
 *                 path to source (Dijkstra)
 *                 </ul>
 *                 The default value is gpudb::visualize_isochrone_from_source.
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeIsochroneResponse& GPUdb::visualizeIsochrone( const std::string& graphName,
                                                       const std::string& sourceNode,
                                                       const double maxSolutionRadius,
                                                       const std::vector<std::string>& weightsOnEdges,
                                                       const std::vector<std::string>& restrictions,
                                                       const int32_t numLevels,
                                                       const bool generateImage,
                                                       const std::string& levelsTable,
                                                       const std::map<std::string, std::string>& styleOptions,
                                                       const std::map<std::string, std::string>& solveOptions,
                                                       const std::map<std::string, std::string>& contourOptions,
                                                       const std::map<std::string, std::string>& options,
                                                       VisualizeIsochroneResponse& response_ ) const
{
    VisualizeIsochroneRequest actualRequest_;
    actualRequest_.graphName = graphName;
    actualRequest_.sourceNode = sourceNode;
    actualRequest_.maxSolutionRadius = maxSolutionRadius;
    actualRequest_.weightsOnEdges = weightsOnEdges;
    actualRequest_.restrictions = restrictions;
    actualRequest_.numLevels = numLevels;
    actualRequest_.generateImage = generateImage;
    actualRequest_.levelsTable = levelsTable;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.solveOptions = solveOptions;
    actualRequest_.contourOptions = contourOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/isochrone", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoResponse GPUdb::visualizeVideo( const VisualizeVideoRequest& request_ ) const
{
    VisualizeVideoResponse actualResponse_;
    submitRequest("/visualize/video", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoResponse& GPUdb::visualizeVideo( const VisualizeVideoRequest& request_,
                                               VisualizeVideoResponse& response_ ) const
{
    submitRequest("/visualize/video", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param trackIds
 * @param xColumnName
 * @param yColumnName
 * @param geometryColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_video_EPSG_4326
 *                            <li> gpudb::visualize_video_PLATE_CARREE
 *                            <li> gpudb::visualize_video_900913
 *                            <li> gpudb::visualize_video_EPSG_900913
 *                            <li> gpudb::visualize_video_102100
 *                            <li> gpudb::visualize_video_EPSG_102100
 *                            <li> gpudb::visualize_video_3857
 *                            <li> gpudb::visualize_video_EPSG_3857
 *                            <li> gpudb::visualize_video_WEB_MERCATOR
 *                    </ul>
 *                    The default value is gpudb::visualize_video_PLATE_CARREE.
 * @param bgColor
 * @param timeIntervals
 * @param videoStyle
 * @param sessionKey
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_video_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_video_true
 *                              <li> gpudb::visualize_video_false
 *                      </ul>
 *                      The default value is gpudb::visualize_video_true.
 *                              <li> gpudb::visualize_video_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_true
 *                              <li> gpudb::visualize_video_false
 *                      </ul>
 *                      The default value is gpudb::visualize_video_true.
 *                              <li> gpudb::visualize_video_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_video_true
 *                              <li> gpudb::visualize_video_false
 *                      </ul>
 *                      The default value is gpudb::visualize_video_true.
 *                              <li> gpudb::visualize_video_pointcolors:   The
 *                      default value is 'FF0000'.
 *                              <li> gpudb::visualize_video_pointsizes:   The
 *                      default value is '3'.
 *                              <li> gpudb::visualize_video_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_none
 *                              <li> gpudb::visualize_video_circle
 *                              <li> gpudb::visualize_video_square
 *                              <li> gpudb::visualize_video_diamond
 *                              <li> gpudb::visualize_video_hollowcircle
 *                              <li> gpudb::visualize_video_hollowsquare
 *                              <li> gpudb::visualize_video_hollowdiamond
 *                              <li> gpudb::visualize_video_SYMBOLCODE
 *                      </ul>
 *                              <li> gpudb::visualize_video_shapelinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_video_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li> gpudb::visualize_video_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li> gpudb::visualize_video_tracklinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_video_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li> gpudb::visualize_video_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_video_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li> gpudb::visualize_video_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_none
 *                              <li> gpudb::visualize_video_circle
 *                              <li> gpudb::visualize_video_square
 *                              <li> gpudb::visualize_video_diamond
 *                              <li> gpudb::visualize_video_hollowcircle
 *                              <li> gpudb::visualize_video_hollowsquare
 *                              <li> gpudb::visualize_video_hollowdiamond
 *                              <li> gpudb::visualize_video_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_video_none.
 *                              <li> gpudb::visualize_video_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li> gpudb::visualize_video_trackheadsizes:
 *                      The default value is '10'.
 *                              <li> gpudb::visualize_video_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_none
 *                              <li> gpudb::visualize_video_circle
 *                              <li> gpudb::visualize_video_square
 *                              <li> gpudb::visualize_video_diamond
 *                              <li> gpudb::visualize_video_hollowcircle
 *                              <li> gpudb::visualize_video_hollowsquare
 *                              <li> gpudb::visualize_video_hollowdiamond
 *                              <li> gpudb::visualize_video_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_video_circle.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoResponse GPUdb::visualizeVideo( const std::vector<std::string>& tableNames,
                                              const std::vector<std::string>& worldTableNames,
                                              const std::vector<std::vector<std::string> >& trackIds,
                                              const std::string& xColumnName,
                                              const std::string& yColumnName,
                                              const std::string& geometryColumnName,
                                              const double minX,
                                              const double maxX,
                                              const double minY,
                                              const double maxY,
                                              const int32_t width,
                                              const int32_t height,
                                              const std::string& projection,
                                              const int64_t bgColor,
                                              const std::vector<std::vector<double> >& timeIntervals,
                                              const std::string& videoStyle,
                                              const std::string& sessionKey,
                                              const std::map<std::string, std::vector<std::string> >& styleOptions,
                                              const std::map<std::string, std::string>& options ) const
{
    VisualizeVideoRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.trackIds = trackIds;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeVideoResponse actualResponse_;
    submitRequest("/visualize/video", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param trackIds
 * @param xColumnName
 * @param yColumnName
 * @param geometryColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_video_EPSG_4326
 *                            <li> gpudb::visualize_video_PLATE_CARREE
 *                            <li> gpudb::visualize_video_900913
 *                            <li> gpudb::visualize_video_EPSG_900913
 *                            <li> gpudb::visualize_video_102100
 *                            <li> gpudb::visualize_video_EPSG_102100
 *                            <li> gpudb::visualize_video_3857
 *                            <li> gpudb::visualize_video_EPSG_3857
 *                            <li> gpudb::visualize_video_WEB_MERCATOR
 *                    </ul>
 *                    The default value is gpudb::visualize_video_PLATE_CARREE.
 * @param bgColor
 * @param timeIntervals
 * @param videoStyle
 * @param sessionKey
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_video_do_points:
 *                      <ul>
 *                              <li> gpudb::visualize_video_true
 *                              <li> gpudb::visualize_video_false
 *                      </ul>
 *                      The default value is gpudb::visualize_video_true.
 *                              <li> gpudb::visualize_video_do_shapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_true
 *                              <li> gpudb::visualize_video_false
 *                      </ul>
 *                      The default value is gpudb::visualize_video_true.
 *                              <li> gpudb::visualize_video_do_tracks:
 *                      <ul>
 *                              <li> gpudb::visualize_video_true
 *                              <li> gpudb::visualize_video_false
 *                      </ul>
 *                      The default value is gpudb::visualize_video_true.
 *                              <li> gpudb::visualize_video_pointcolors:   The
 *                      default value is 'FF0000'.
 *                              <li> gpudb::visualize_video_pointsizes:   The
 *                      default value is '3'.
 *                              <li> gpudb::visualize_video_pointshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_none
 *                              <li> gpudb::visualize_video_circle
 *                              <li> gpudb::visualize_video_square
 *                              <li> gpudb::visualize_video_diamond
 *                              <li> gpudb::visualize_video_hollowcircle
 *                              <li> gpudb::visualize_video_hollowsquare
 *                              <li> gpudb::visualize_video_hollowdiamond
 *                              <li> gpudb::visualize_video_SYMBOLCODE
 *                      </ul>
 *                              <li> gpudb::visualize_video_shapelinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_video_shapelinecolors:
 *                      The default value is 'FFFF00 '.
 *                              <li> gpudb::visualize_video_shapefillcolors:
 *                      The default value is '-1'.
 *                              <li> gpudb::visualize_video_tracklinewidths:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_video_tracklinecolors:
 *                      The default value is '00FF00'.
 *                              <li> gpudb::visualize_video_trackmarkersizes:
 *                      The default value is '3'.
 *                              <li> gpudb::visualize_video_trackmarkercolors:
 *                      The default value is '0000FF'.
 *                              <li> gpudb::visualize_video_trackmarkershapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_none
 *                              <li> gpudb::visualize_video_circle
 *                              <li> gpudb::visualize_video_square
 *                              <li> gpudb::visualize_video_diamond
 *                              <li> gpudb::visualize_video_hollowcircle
 *                              <li> gpudb::visualize_video_hollowsquare
 *                              <li> gpudb::visualize_video_hollowdiamond
 *                              <li> gpudb::visualize_video_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_video_none.
 *                              <li> gpudb::visualize_video_trackheadcolors:
 *                      The default value is 'FFFFFF'.
 *                              <li> gpudb::visualize_video_trackheadsizes:
 *                      The default value is '10'.
 *                              <li> gpudb::visualize_video_trackheadshapes:
 *                      <ul>
 *                              <li> gpudb::visualize_video_none
 *                              <li> gpudb::visualize_video_circle
 *                              <li> gpudb::visualize_video_square
 *                              <li> gpudb::visualize_video_diamond
 *                              <li> gpudb::visualize_video_hollowcircle
 *                              <li> gpudb::visualize_video_hollowsquare
 *                              <li> gpudb::visualize_video_hollowdiamond
 *                              <li> gpudb::visualize_video_SYMBOLCODE
 *                      </ul>
 *                      The default value is gpudb::visualize_video_circle.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoResponse& GPUdb::visualizeVideo( const std::vector<std::string>& tableNames,
                                               const std::vector<std::string>& worldTableNames,
                                               const std::vector<std::vector<std::string> >& trackIds,
                                               const std::string& xColumnName,
                                               const std::string& yColumnName,
                                               const std::string& geometryColumnName,
                                               const double minX,
                                               const double maxX,
                                               const double minY,
                                               const double maxY,
                                               const int32_t width,
                                               const int32_t height,
                                               const std::string& projection,
                                               const int64_t bgColor,
                                               const std::vector<std::vector<double> >& timeIntervals,
                                               const std::string& videoStyle,
                                               const std::string& sessionKey,
                                               const std::map<std::string, std::vector<std::string> >& styleOptions,
                                               const std::map<std::string, std::string>& options,
                                               VisualizeVideoResponse& response_ ) const
{
    VisualizeVideoRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.trackIds = trackIds;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.geometryColumnName = geometryColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/video", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoHeatmapResponse GPUdb::visualizeVideoHeatmap( const VisualizeVideoHeatmapRequest& request_ ) const
{
    VisualizeVideoHeatmapResponse actualResponse_;
    submitRequest("/visualize/video/heatmap", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoHeatmapResponse& GPUdb::visualizeVideoHeatmap( const VisualizeVideoHeatmapRequest& request_,
                                                             VisualizeVideoHeatmapResponse& response_ ) const
{
    submitRequest("/visualize/video/heatmap", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param timeIntervals
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_video_heatmap_EPSG_4326
 *                            <li> gpudb::visualize_video_heatmap_PLATE_CARREE
 *                            <li> gpudb::visualize_video_heatmap_900913
 *                            <li> gpudb::visualize_video_heatmap_EPSG_900913
 *                            <li> gpudb::visualize_video_heatmap_102100
 *                            <li> gpudb::visualize_video_heatmap_EPSG_102100
 *                            <li> gpudb::visualize_video_heatmap_3857
 *                            <li> gpudb::visualize_video_heatmap_EPSG_3857
 *                            <li> gpudb::visualize_video_heatmap_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_video_heatmap_PLATE_CARREE.
 * @param videoStyle
 * @param sessionKey
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_video_heatmap_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_video_heatmap_jet
 *                              <li> gpudb::visualize_video_heatmap_hot
 *                              <li> gpudb::visualize_video_heatmap_hsv
 *                              <li> gpudb::visualize_video_heatmap_gray
 *                              <li> gpudb::visualize_video_heatmap_blues
 *                              <li> gpudb::visualize_video_heatmap_greens
 *                              <li> gpudb::visualize_video_heatmap_greys
 *                              <li> gpudb::visualize_video_heatmap_oranges
 *                              <li> gpudb::visualize_video_heatmap_purples
 *                              <li> gpudb::visualize_video_heatmap_reds
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_video_heatmap_reds.
 *                              <li>
 *                      gpudb::visualize_video_heatmap_blur_radius:   The
 *                      default value is '5'.
 *                              <li> gpudb::visualize_video_heatmap_bg_color:
 *                      The default value is 'FF000000'.
 *                              <li>
 *                      gpudb::visualize_video_heatmap_gradient_start_color:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_video_heatmap_gradient_end_color:
 *                      The default value is 'FF0000'.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoHeatmapResponse GPUdb::visualizeVideoHeatmap( const std::vector<std::string>& tableNames,
                                                            const std::string& xColumnName,
                                                            const std::string& yColumnName,
                                                            const double minX,
                                                            const double maxX,
                                                            const double minY,
                                                            const double maxY,
                                                            const std::vector<std::vector<double> >& timeIntervals,
                                                            const int32_t width,
                                                            const int32_t height,
                                                            const std::string& projection,
                                                            const std::string& videoStyle,
                                                            const std::string& sessionKey,
                                                            const std::map<std::string, std::string>& styleOptions,
                                                            const std::map<std::string, std::string>& options ) const
{
    VisualizeVideoHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeVideoHeatmapResponse actualResponse_;
    submitRequest("/visualize/video/heatmap", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param timeIntervals
 * @param width
 * @param height
 * @param projection
 *                    <ul>
 *                            <li> gpudb::visualize_video_heatmap_EPSG_4326
 *                            <li> gpudb::visualize_video_heatmap_PLATE_CARREE
 *                            <li> gpudb::visualize_video_heatmap_900913
 *                            <li> gpudb::visualize_video_heatmap_EPSG_900913
 *                            <li> gpudb::visualize_video_heatmap_102100
 *                            <li> gpudb::visualize_video_heatmap_EPSG_102100
 *                            <li> gpudb::visualize_video_heatmap_3857
 *                            <li> gpudb::visualize_video_heatmap_EPSG_3857
 *                            <li> gpudb::visualize_video_heatmap_WEB_MERCATOR
 *                    </ul>
 *                    The default value is
 *                    gpudb::visualize_video_heatmap_PLATE_CARREE.
 * @param videoStyle
 * @param sessionKey
 * @param styleOptions
 *                      <ul>
 *                              <li> gpudb::visualize_video_heatmap_colormap:
 *                      <ul>
 *                              <li> gpudb::visualize_video_heatmap_jet
 *                              <li> gpudb::visualize_video_heatmap_hot
 *                              <li> gpudb::visualize_video_heatmap_hsv
 *                              <li> gpudb::visualize_video_heatmap_gray
 *                              <li> gpudb::visualize_video_heatmap_blues
 *                              <li> gpudb::visualize_video_heatmap_greens
 *                              <li> gpudb::visualize_video_heatmap_greys
 *                              <li> gpudb::visualize_video_heatmap_oranges
 *                              <li> gpudb::visualize_video_heatmap_purples
 *                              <li> gpudb::visualize_video_heatmap_reds
 *                      </ul>
 *                      The default value is
 *                      gpudb::visualize_video_heatmap_reds.
 *                              <li>
 *                      gpudb::visualize_video_heatmap_blur_radius:   The
 *                      default value is '5'.
 *                              <li> gpudb::visualize_video_heatmap_bg_color:
 *                      The default value is 'FF000000'.
 *                              <li>
 *                      gpudb::visualize_video_heatmap_gradient_start_color:
 *                      The default value is 'FFFFFF'.
 *                              <li>
 *                      gpudb::visualize_video_heatmap_gradient_end_color:
 *                      The default value is 'FF0000'.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoHeatmapResponse& GPUdb::visualizeVideoHeatmap( const std::vector<std::string>& tableNames,
                                                             const std::string& xColumnName,
                                                             const std::string& yColumnName,
                                                             const double minX,
                                                             const double maxX,
                                                             const double minY,
                                                             const double maxY,
                                                             const std::vector<std::vector<double> >& timeIntervals,
                                                             const int32_t width,
                                                             const int32_t height,
                                                             const std::string& projection,
                                                             const std::string& videoStyle,
                                                             const std::string& sessionKey,
                                                             const std::map<std::string, std::string>& styleOptions,
                                                             const std::map<std::string, std::string>& options,
                                                             VisualizeVideoHeatmapResponse& response_ ) const
{
    VisualizeVideoHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/video/heatmap", actualRequest_, response_, false);
    return response_;
}

