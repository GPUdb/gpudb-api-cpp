/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */


// GPUdb Version
const std::string GPUdb::API_VERSION( "6.0.0.0" );



/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminDeleteNodeResponse GPUdb::adminDeleteNode( const AdminDeleteNodeRequest& request_ ) const
{
    AdminDeleteNodeResponse actualResponse_;
    submitRequest("/admin/delete/node", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminDeleteNodeResponse& GPUdb::adminDeleteNode( const AdminDeleteNodeRequest& request_,
                                                 AdminDeleteNodeResponse& response_ ) const
{
    submitRequest("/admin/delete/node", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param rank
 * @param authorization
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminDeleteNodeResponse GPUdb::adminDeleteNode( const int32_t rank,
                                                const std::string& authorization,
                                                const std::map<std::string, std::string>& options ) const
{
    AdminDeleteNodeRequest actualRequest_;
    actualRequest_.rank = rank;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    AdminDeleteNodeResponse actualResponse_;
    submitRequest("/admin/delete/node", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param rank
 * @param authorization
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminDeleteNodeResponse& GPUdb::adminDeleteNode( const int32_t rank,
                                                 const std::string& authorization,
                                                 const std::map<std::string, std::string>& options,
                                                 AdminDeleteNodeResponse& response_ ) const
{
    AdminDeleteNodeRequest actualRequest_;
    actualRequest_.rank = rank;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    submitRequest("/admin/delete/node", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminGetShardAssignmentsResponse GPUdb::adminGetShardAssignments( const AdminGetShardAssignmentsRequest& request_ ) const
{
    AdminGetShardAssignmentsResponse actualResponse_;
    submitRequest("/admin/getshardassignments", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminGetShardAssignmentsResponse& GPUdb::adminGetShardAssignments( const AdminGetShardAssignmentsRequest& request_,
                                                                   AdminGetShardAssignmentsResponse& response_ ) const
{
    submitRequest("/admin/getshardassignments", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminGetShardAssignmentsResponse GPUdb::adminGetShardAssignments( const std::map<std::string, std::string>& options ) const
{
    AdminGetShardAssignmentsRequest actualRequest_;
    actualRequest_.options = options;
    AdminGetShardAssignmentsResponse actualResponse_;
    submitRequest("/admin/getshardassignments", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminGetShardAssignmentsResponse& GPUdb::adminGetShardAssignments( const std::map<std::string, std::string>& options,
                                                                   AdminGetShardAssignmentsResponse& response_ ) const
{
    AdminGetShardAssignmentsRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/admin/getshardassignments", actualRequest_, response_, false);
    return response_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse GPUdb::adminOffline( const AdminOfflineRequest& request_ ) const
{
    AdminOfflineResponse actualResponse_;
    submitRequest("/admin/offline", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& GPUdb::adminOffline( const AdminOfflineRequest& request_,
                                           AdminOfflineResponse& response_ ) const
{
    submitRequest("/admin/offline", request_, response_, false);
    return response_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline. Values: 'true',
 *                 'false'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminOfflineResponse GPUdb::adminOffline( const bool offline,
                                          const std::map<std::string, std::string>& options ) const
{
    AdminOfflineRequest actualRequest_;
    actualRequest_.offline = offline;
    actualRequest_.options = options;
    AdminOfflineResponse actualResponse_;
    submitRequest("/admin/offline", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 * 
 * @param offline  Set to true if desired state is offline. Values: 'true',
 *                 'false'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminOfflineResponse& GPUdb::adminOffline( const bool offline,
                                           const std::map<std::string, std::string>& options,
                                           AdminOfflineResponse& response_ ) const
{
    AdminOfflineRequest actualRequest_;
    actualRequest_.offline = offline;
    actualRequest_.options = options;
    submitRequest("/admin/offline", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse GPUdb::adminRebalance( const AdminRebalanceRequest& request_ ) const
{
    AdminRebalanceResponse actualResponse_;
    submitRequest("/admin/rebalance", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& GPUdb::adminRebalance( const AdminRebalanceRequest& request_,
                                               AdminRebalanceResponse& response_ ) const
{
    submitRequest("/admin/rebalance", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminRebalanceResponse GPUdb::adminRebalance( const std::vector<std::string>& tableNames,
                                              const std::map<std::string, std::string>& options ) const
{
    AdminRebalanceRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    AdminRebalanceResponse actualResponse_;
    submitRequest("/admin/rebalance", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminRebalanceResponse& GPUdb::adminRebalance( const std::vector<std::string>& tableNames,
                                               const std::map<std::string, std::string>& options,
                                               AdminRebalanceResponse& response_ ) const
{
    AdminRebalanceRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    submitRequest("/admin/rebalance", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminSetShardAssignmentsResponse GPUdb::adminSetShardAssignments( const AdminSetShardAssignmentsRequest& request_ ) const
{
    AdminSetShardAssignmentsResponse actualResponse_;
    submitRequest("/admin/setshardassignments", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminSetShardAssignmentsResponse& GPUdb::adminSetShardAssignments( const AdminSetShardAssignmentsRequest& request_,
                                                                   AdminSetShardAssignmentsResponse& response_ ) const
{
    submitRequest("/admin/setshardassignments", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param version
 * @param partialReassignment
 * @param shardAssignmentsRank
 * @param shardAssignmentsTom
 * @param assignmentIndex
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminSetShardAssignmentsResponse GPUdb::adminSetShardAssignments( const int64_t version,
                                                                  const bool partialReassignment,
                                                                  const std::vector<int32_t>& shardAssignmentsRank,
                                                                  const std::vector<int32_t>& shardAssignmentsTom,
                                                                  const std::vector<int32_t>& assignmentIndex,
                                                                  const std::map<std::string, std::string>& options ) const
{
    AdminSetShardAssignmentsRequest actualRequest_;
    actualRequest_.version = version;
    actualRequest_.partialReassignment = partialReassignment;
    actualRequest_.shardAssignmentsRank = shardAssignmentsRank;
    actualRequest_.shardAssignmentsTom = shardAssignmentsTom;
    actualRequest_.assignmentIndex = assignmentIndex;
    actualRequest_.options = options;
    AdminSetShardAssignmentsResponse actualResponse_;
    submitRequest("/admin/setshardassignments", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param version
 * @param partialReassignment
 * @param shardAssignmentsRank
 * @param shardAssignmentsTom
 * @param assignmentIndex
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminSetShardAssignmentsResponse& GPUdb::adminSetShardAssignments( const int64_t version,
                                                                   const bool partialReassignment,
                                                                   const std::vector<int32_t>& shardAssignmentsRank,
                                                                   const std::vector<int32_t>& shardAssignmentsTom,
                                                                   const std::vector<int32_t>& assignmentIndex,
                                                                   const std::map<std::string, std::string>& options,
                                                                   AdminSetShardAssignmentsResponse& response_ ) const
{
    AdminSetShardAssignmentsRequest actualRequest_;
    actualRequest_.version = version;
    actualRequest_.partialReassignment = partialReassignment;
    actualRequest_.shardAssignmentsRank = shardAssignmentsRank;
    actualRequest_.shardAssignmentsTom = shardAssignmentsTom;
    actualRequest_.assignmentIndex = assignmentIndex;
    actualRequest_.options = options;
    submitRequest("/admin/setshardassignments", actualRequest_, response_, false);
    return response_;
}


/**
 * Exits the GPUdb server application.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse GPUdb::adminShutdown( const AdminShutdownRequest& request_ ) const
{
    AdminShutdownResponse actualResponse_;
    submitRequest("/admin/shutdown", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Exits the GPUdb server application.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& GPUdb::adminShutdown( const AdminShutdownRequest& request_,
                                             AdminShutdownResponse& response_ ) const
{
    submitRequest("/admin/shutdown", request_, response_, false);
    return response_;
}


/**
 * Exits the GPUdb server application.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminShutdownResponse GPUdb::adminShutdown( const std::string& exitType,
                                            const std::string& authorization,
                                            const std::map<std::string, std::string>& options ) const
{
    AdminShutdownRequest actualRequest_;
    actualRequest_.exitType = exitType;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    AdminShutdownResponse actualResponse_;
    submitRequest("/admin/shutdown", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Exits the GPUdb server application.
 * 
 * @param exitType  Reserved for future use. User can pass an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminShutdownResponse& GPUdb::adminShutdown( const std::string& exitType,
                                             const std::string& authorization,
                                             const std::map<std::string, std::string>& options,
                                             AdminShutdownResponse& response_ ) const
{
    AdminShutdownRequest actualRequest_;
    actualRequest_.exitType = exitType;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    submitRequest("/admin/shutdown", actualRequest_, response_, false);
    return response_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse GPUdb::adminVerifyDb( const AdminVerifyDbRequest& request_ ) const
{
    AdminVerifyDbResponse actualResponse_;
    submitRequest("/admin/verifydb", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& GPUdb::adminVerifyDb( const AdminVerifyDbRequest& request_,
                                             AdminVerifyDbResponse& response_ ) const
{
    submitRequest("/admin/verifydb", request_, response_, false);
    return response_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AdminVerifyDbResponse GPUdb::adminVerifyDb( const std::map<std::string, std::string>& options ) const
{
    AdminVerifyDbRequest actualRequest_;
    actualRequest_.options = options;
    AdminVerifyDbResponse actualResponse_;
    submitRequest("/admin/verifydb", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 * 
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AdminVerifyDbResponse& GPUdb::adminVerifyDb( const std::map<std::string, std::string>& options,
                                             AdminVerifyDbResponse& response_ ) const
{
    AdminVerifyDbRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/admin/verifydb", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse GPUdb::aggregateConvexHull( const AggregateConvexHullRequest& request_ ) const
{
    AggregateConvexHullResponse actualResponse_;
    submitRequest("/aggregate/convexhull", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& GPUdb::aggregateConvexHull( const AggregateConvexHullRequest& request_,
                                                         AggregateConvexHullResponse& response_ ) const
{
    submitRequest("/aggregate/convexhull", request_, response_, false);
    return response_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of Table on which the operation will be performed.
 *                   Must be a valid table in GPUdb.  It can not be a
 *                   collection.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateConvexHullResponse GPUdb::aggregateConvexHull( const std::string& tableName,
                                                        const std::string& xColumnName,
                                                        const std::string& yColumnName,
                                                        const std::map<std::string, std::string>& options ) const
{
    AggregateConvexHullRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.options = options;
    AggregateConvexHullResponse actualResponse_;
    submitRequest("/aggregate/convexhull", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the convex hull for the values in a table specified
 * by @a tableName.
 * 
 * @param tableName  Name of Table on which the operation will be performed.
 *                   Must be a valid table in GPUdb.  It can not be a
 *                   collection.
 * @param xColumnName  Name of the column containing the x coordinates of the
 *                     points for the operation being performed.
 * @param yColumnName  Name of the column containing the y coordinates of the
 *                     points for the operation being performed.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateConvexHullResponse& GPUdb::aggregateConvexHull( const std::string& tableName,
                                                         const std::string& xColumnName,
                                                         const std::string& yColumnName,
                                                         const std::map<std::string, std::string>& options,
                                                         AggregateConvexHullResponse& response_ ) const
{
    AggregateConvexHullRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.options = options;
    submitRequest("/aggregate/convexhull", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the @a
 * offset and @a limit parameters. For example, to get 10 groups with the
 * largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. @a options can be
 * used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateGroupByResponse GPUdb::aggregateGroupByRaw( const AggregateGroupByRequest& request_ ) const
{
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the @a
 * offset and @a limit parameters. For example, to get 10 groups with the
 * largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. @a options can be
 * used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateGroupByResponse& GPUdb::aggregateGroupByRaw( const AggregateGroupByRequest& request_,
                                                         RawAggregateGroupByResponse& response_ ) const
{
    submitRequest("/aggregate/groupby", request_, response_, false);
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the @a
 * offset and @a limit parameters. For example, to get 10 groups with the
 * largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. @a options can be
 * used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse GPUdb::aggregateGroupBy( const AggregateGroupByRequest& request_ ) const
{
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", request_, actualResponse_, false);
    AggregateGroupByResponse response_;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the @a
 * offset and @a limit parameters. For example, to get 10 groups with the
 * largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. @a options can be
 * used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& GPUdb::aggregateGroupBy( const AggregateGroupByRequest& request_,
                                                   AggregateGroupByResponse& response_ ) const
{
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", request_, actualResponse_, false);
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the @a
 * offset and @a limit parameters. For example, to get 10 groups with the
 * largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. @a options can be
 * used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table/view/collection in GPUdb.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions. Must include at least one
 *                     'grouping' column or expression.  If no aggregate is
 *                     included, count(*) will be computed as a default.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 1000.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> expression: Filter expression to apply to the
 *                 table prior to computing the aggregate group by.
 *                         <li> having: Filter expression to apply to the
 *                 aggregated results.
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted - ascending or descending. Values:
 *                 'ascending', 'descending'.
 *                         <li> sort_by: String determining how the results are
 *                 sorted. Values: 'key', 'value'.
 *                         <li> result_table: The name of the table used to
 *                 store the results. Column names (group-by and aggregate
 *                 fields) need to be given aliases e.g. ["FChar256 as
 *                 fchar256", "sum(FDouble) as sfd"].  If present, no results
 *                 are returned in the response.  This option is not available
 *                 if one of the grouping attributes is an unrestricted string
 *                 (i.e.; not charN) type.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateGroupByResponse GPUdb::aggregateGroupBy( const std::string& tableName,
                                                  const std::vector<std::string>& columnNames,
                                                  const int64_t offset,
                                                  const int64_t limit,
                                                  const std::map<std::string, std::string>& options ) const
{
    AggregateGroupByRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", actualRequest_, actualResponse_, false);
    AggregateGroupByResponse response_;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates. The results can be paged via the @a
 * offset and @a limit parameters. For example, to get 10 groups with the
 * largest counts the inputs would be: limit=10,
 * options={"sort_order":"descending", "sort_by":"value"}. @a options can be
 * used to customize behavior of this call e.g. filtering or sorting the
 * results. To group by 'x' and 'y' and compute the number of objects within
 * each group, use column_names=['x','y','count(*)'].  To also compute the sum
 * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp',
 * 'arg_min', 'arg_max' and 'count_distinct'. The response is returned as a
 * dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table/view/collection in GPUdb.
 * @param columnNames  List of one or more column names, expressions, and
 *                     aggregate expressions. Must include at least one
 *                     'grouping' column or expression.  If no aggregate is
 *                     included, count(*) will be computed as a default.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 1000.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> expression: Filter expression to apply to the
 *                 table prior to computing the aggregate group by.
 *                         <li> having: Filter expression to apply to the
 *                 aggregated results.
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted - ascending or descending. Values:
 *                 'ascending', 'descending'.
 *                         <li> sort_by: String determining how the results are
 *                 sorted. Values: 'key', 'value'.
 *                         <li> result_table: The name of the table used to
 *                 store the results. Column names (group-by and aggregate
 *                 fields) need to be given aliases e.g. ["FChar256 as
 *                 fchar256", "sum(FDouble) as sfd"].  If present, no results
 *                 are returned in the response.  This option is not available
 *                 if one of the grouping attributes is an unrestricted string
 *                 (i.e.; not charN) type.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateGroupByResponse& GPUdb::aggregateGroupBy( const std::string& tableName,
                                                   const std::vector<std::string>& columnNames,
                                                   const int64_t offset,
                                                   const int64_t limit,
                                                   const std::map<std::string, std::string>& options,
                                                   AggregateGroupByResponse& response_ ) const
{
    AggregateGroupByRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateGroupByResponse actualResponse_;
    submitRequest("/aggregate/groupby", actualRequest_, actualResponse_, false);
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a *value_column* in @a options.  In
 * this latter case the sum of the values corresponding to the *value_column*
 * is used as the result instead.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse GPUdb::aggregateHistogram( const AggregateHistogramRequest& request_ ) const
{
    AggregateHistogramResponse actualResponse_;
    submitRequest("/aggregate/histogram", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a *value_column* in @a options.  In
 * this latter case the sum of the values corresponding to the *value_column*
 * is used as the result instead.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& GPUdb::aggregateHistogram( const AggregateHistogramRequest& request_,
                                                       AggregateHistogramResponse& response_ ) const
{
    submitRequest("/aggregate/histogram", request_, response_, false);
    return response_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a *value_column* in @a options.  In
 * this latter case the sum of the values corresponding to the *value_column*
 * is used as the result instead.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> value_column: The name of the column GPUdb will
 *                 use when calculating the bin values (values are summed).
 *                 The column must be a numerical type (int, double, long,
 *                 float).
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateHistogramResponse GPUdb::aggregateHistogram( const std::string& tableName,
                                                      const std::string& columnName,
                                                      const double start,
                                                      const double end,
                                                      const double interval,
                                                      const std::map<std::string, std::string>& options ) const
{
    AggregateHistogramRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    AggregateHistogramResponse actualResponse_;
    submitRequest("/aggregate/histogram", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The @a interval is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a *value_column* in @a options.  In
 * this latter case the sum of the values corresponding to the *value_column*
 * is used as the result instead.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    names over which the histogram will be calculated.
 * @param start  Lower end value of the histogram interval, inclusive.
 * @param end  Upper end value of the histogram interval, inclusive.
 * @param interval  The size of each bin within the start and end parameters.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> value_column: The name of the column GPUdb will
 *                 use when calculating the bin values (values are summed).
 *                 The column must be a numerical type (int, double, long,
 *                 float).
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateHistogramResponse& GPUdb::aggregateHistogram( const std::string& tableName,
                                                       const std::string& columnName,
                                                       const double start,
                                                       const double end,
                                                       const double interval,
                                                       const std::map<std::string, std::string>& options,
                                                       AggregateHistogramResponse& response_ ) const
{
    AggregateHistogramRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    submitRequest("/aggregate/histogram", actualRequest_, response_, false);
    return response_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse GPUdb::aggregateKMeans( const AggregateKMeansRequest& request_ ) const
{
    AggregateKMeansResponse actualResponse_;
    submitRequest("/aggregate/kmeans", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& GPUdb::aggregateKMeans( const AggregateKMeansRequest& request_,
                                                 AggregateKMeansResponse& response_ ) const
{
    submitRequest("/aggregate/kmeans", request_, response_, false);
    return response_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> whiten: When set to 1 each of the columns is
 *                 first normalized by its stdv - default is not to whiten.
 *                         <li> max_iters: Number of times to try to hit the
 *                 tolerance limit before giving up - default is 10.
 *                         <li> num_tries: Number of times to run the k-means
 *                 algorithm with a different randomly selected starting points
 *                 - helps avoid local minimum. Default is 1.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateKMeansResponse GPUdb::aggregateKMeans( const std::string& tableName,
                                                const std::vector<std::string>& columnNames,
                                                const int32_t k,
                                                const double tolerance,
                                                const std::map<std::string, std::string>& options ) const
{
    AggregateKMeansRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.k = k;
    actualRequest_.tolerance = tolerance;
    actualRequest_.options = options;
    AggregateKMeansResponse actualResponse_;
    submitRequest("/aggregate/kmeans", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table or collection in GPUdb.
 * @param columnNames  List of column names on which the operation would be
 *                     performed. If n columns are provided then each of the k
 *                     result points will have n dimensions corresponding to
 *                     the n columns.
 * @param k  The number of mean points to be determined by the algorithm.
 * @param tolerance  Stop iterating when the distances between successive
 *                   points is less than the given tolerance.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> whiten: When set to 1 each of the columns is
 *                 first normalized by its stdv - default is not to whiten.
 *                         <li> max_iters: Number of times to try to hit the
 *                 tolerance limit before giving up - default is 10.
 *                         <li> num_tries: Number of times to run the k-means
 *                 algorithm with a different randomly selected starting points
 *                 - helps avoid local minimum. Default is 1.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateKMeansResponse& GPUdb::aggregateKMeans( const std::string& tableName,
                                                 const std::vector<std::string>& columnNames,
                                                 const int32_t k,
                                                 const double tolerance,
                                                 const std::map<std::string, std::string>& options,
                                                 AggregateKMeansResponse& response_ ) const
{
    AggregateKMeansRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.k = k;
    actualRequest_.tolerance = tolerance;
    actualRequest_.options = options;
    submitRequest("/aggregate/kmeans", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse GPUdb::aggregateMinMax( const AggregateMinMaxRequest& request_ ) const
{
    AggregateMinMaxResponse actualResponse_;
    submitRequest("/aggregate/minmax", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& GPUdb::aggregateMinMax( const AggregateMinMaxRequest& request_,
                                                 AggregateMinMaxResponse& response_ ) const
{
    submitRequest("/aggregate/minmax", request_, response_, false);
    return response_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateMinMaxResponse GPUdb::aggregateMinMax( const std::string& tableName,
                                                const std::string& columnName,
                                                const std::map<std::string, std::string>& options ) const
{
    AggregateMinMaxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    AggregateMinMaxResponse actualResponse_;
    submitRequest("/aggregate/minmax", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of a column or an expression of one or more column
 *                    on which the min-max will be calculated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateMinMaxResponse& GPUdb::aggregateMinMax( const std::string& tableName,
                                                 const std::string& columnName,
                                                 const std::map<std::string, std::string>& options,
                                                 AggregateMinMaxResponse& response_ ) const
{
    AggregateMinMaxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    submitRequest("/aggregate/minmax", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse GPUdb::aggregateStatistics( const AggregateStatisticsRequest& request_ ) const
{
    AggregateStatisticsResponse actualResponse_;
    submitRequest("/aggregate/statistics", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& GPUdb::aggregateStatistics( const AggregateStatisticsRequest& request_,
                                                         AggregateStatisticsResponse& response_ ) const
{
    submitRequest("/aggregate/statistics", request_, response_, false);
    return response_;
}


/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed.
 * @param columnName  Name of the column for which the statistics are to be
 *                    calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean". Values: 'count', 'mean', 'stdv', 'variance',
 *               'skew', 'kurtosis', 'sum', 'min', 'max', 'weighted_average',
 *               'cardinality', 'estimated_cardinality', 'percentile',
 *               'percentile_rank'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> additional_column_names: A list of comma
 *                 separated column names over which statistics can be
 *                 accumulated along with the primary column.
 *                         <li> weight_column_name: Name of column used as
 *                 weighting attribute for the weighted average statistic.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsResponse GPUdb::aggregateStatistics( const std::string& tableName,
                                                        const std::string& columnName,
                                                        const std::string& stats,
                                                        const std::map<std::string, std::string>& options ) const
{
    AggregateStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.stats = stats;
    actualRequest_.options = options;
    AggregateStatisticsResponse actualResponse_;
    submitRequest("/aggregate/statistics", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in @a options. The weighted average is then defined as the sum of the
 * products of @a columnName times the weight attribute divided by the sum of
 * the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 * 
 * @param tableName  Name of the table on which the statistics operation will
 *                   be performed.
 * @param columnName  Name of the column for which the statistics are to be
 *                    calculated.
 * @param stats  Comma separated list of the statistics to calculate, e.g.
 *               "sum,mean". Values: 'count', 'mean', 'stdv', 'variance',
 *               'skew', 'kurtosis', 'sum', 'min', 'max', 'weighted_average',
 *               'cardinality', 'estimated_cardinality', 'percentile',
 *               'percentile_rank'.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> additional_column_names: A list of comma
 *                 separated column names over which statistics can be
 *                 accumulated along with the primary column.
 *                         <li> weight_column_name: Name of column used as
 *                 weighting attribute for the weighted average statistic.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsResponse& GPUdb::aggregateStatistics( const std::string& tableName,
                                                         const std::string& columnName,
                                                         const std::string& stats,
                                                         const std::map<std::string, std::string>& options,
                                                         AggregateStatisticsResponse& response_ ) const
{
    AggregateStatisticsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.stats = stats;
    actualRequest_.options = options;
    submitRequest("/aggregate/statistics", actualRequest_, response_, false);
    return response_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse GPUdb::aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_ ) const
{
    AggregateStatisticsByRangeResponse actualResponse_;
    submitRequest("/aggregate/statistics/byrange", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& GPUdb::aggregateStatisticsByRange( const AggregateStatisticsByRangeRequest& request_,
                                                                       AggregateStatisticsByRangeResponse& response_ ) const
{
    submitRequest("/aggregate/statistics/byrange", request_, response_, false);
    return response_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.  Default value is an empty
 *                          string.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval``*``i,
 *                  start+interval``*``(i+1)).
 * @param options  Map of optional parameters:
 *                 <ul>
 *                         <li> additional_column_names: A list of comma
 *                 separated value-column names over which statistics can be
 *                 accumulated along with the primary value_column.
 *                         <li> bin_values: A list of comma separated
 *                 binning-column values. Values that match the nth bin_values
 *                 value are placed in the nth bin.
 *                         <li> weight_column_name: Name of the column used as
 *                 weighting column for the weighted_average statistic.
 *                         <li> order_column_name: Name of the column used for
 *                 candlestick charting techniques.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateStatisticsByRangeResponse GPUdb::aggregateStatisticsByRange( const std::string& tableName,
                                                                      const std::string& selectExpression,
                                                                      const std::string& columnName,
                                                                      const std::string& valueColumnName,
                                                                      const std::string& stats,
                                                                      const double start,
                                                                      const double end,
                                                                      const double interval,
                                                                      const std::map<std::string, std::string>& options ) const
{
    AggregateStatisticsByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.selectExpression = selectExpression;
    actualRequest_.columnName = columnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.stats = stats;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    AggregateStatisticsByRangeResponse actualResponse_;
    submitRequest("/aggregate/statistics/byrange", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in @a
 * options. The weighted average is then defined as the sum of the products of
 * the value column times the weight column divided by the sum of the weight
 * column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of
 * (max-min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, @a options bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 * 
 * @param tableName  Name of the table on which the ranged-statistics operation
 *                   will be performed.
 * @param selectExpression  For a non-empty expression statistics are
 *                          calculated for those records for which the
 *                          expression is true.  Default value is an empty
 *                          string.
 * @param columnName  Name of the binning-column used to divide the set samples
 *                    into bins.
 * @param valueColumnName  Name of the value-column for which statistics are to
 *                         be computed.
 * @param stats  A string of comma separated list of the statistics to
 *               calculate, e.g. 'sum,mean'. Available statistics: mean, stdv
 *               (standard deviation), variance, skew, kurtosis, sum.
 * @param start  The lower bound of the binning-column.
 * @param end  The upper bound of the binning-column.
 * @param interval  The interval of a bin. Set members fall into bin i if the
 *                  binning-column falls in the range [start+interval``*``i,
 *                  start+interval``*``(i+1)).
 * @param options  Map of optional parameters:
 *                 <ul>
 *                         <li> additional_column_names: A list of comma
 *                 separated value-column names over which statistics can be
 *                 accumulated along with the primary value_column.
 *                         <li> bin_values: A list of comma separated
 *                 binning-column values. Values that match the nth bin_values
 *                 value are placed in the nth bin.
 *                         <li> weight_column_name: Name of the column used as
 *                 weighting column for the weighted_average statistic.
 *                         <li> order_column_name: Name of the column used for
 *                 candlestick charting techniques.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateStatisticsByRangeResponse& GPUdb::aggregateStatisticsByRange( const std::string& tableName,
                                                                       const std::string& selectExpression,
                                                                       const std::string& columnName,
                                                                       const std::string& valueColumnName,
                                                                       const std::string& stats,
                                                                       const double start,
                                                                       const double end,
                                                                       const double interval,
                                                                       const std::map<std::string, std::string>& options,
                                                                       AggregateStatisticsByRangeResponse& response_ ) const
{
    AggregateStatisticsByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.selectExpression = selectExpression;
    actualRequest_.columnName = columnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.stats = stats;
    actualRequest_.start = start;
    actualRequest_.end = end;
    actualRequest_.interval = interval;
    actualRequest_.options = options;
    submitRequest("/aggregate/statistics/byrange", actualRequest_, response_, false);
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawAggregateUniqueResponse GPUdb::aggregateUniqueRaw( const AggregateUniqueRequest& request_ ) const
{
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawAggregateUniqueResponse& GPUdb::aggregateUniqueRaw( const AggregateUniqueRequest& request_,
                                                       RawAggregateUniqueResponse& response_ ) const
{
    submitRequest("/aggregate/unique", request_, response_, false);
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse GPUdb::aggregateUnique( const AggregateUniqueRequest& request_ ) const
{
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", request_, actualResponse_, false);
    AggregateUniqueResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& GPUdb::aggregateUnique( const AggregateUniqueRequest& request_,
                                                 AggregateUniqueResponse& response_ ) const
{
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> expression: Optional filter expression to apply
 *                 to the table.
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted. Values: 'ascending', 'descending'.
 *                         <li> result_table: The name of the table used to
 *                 store the results. If present no results are returned in the
 *                 response.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AggregateUniqueResponse GPUdb::aggregateUnique( const std::string& tableName,
                                                const std::string& columnName,
                                                const int64_t offset,
                                                const int64_t limit,
                                                const std::map<std::string, std::string>& options ) const
{
    AggregateUniqueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", actualRequest_, actualResponse_, false);
    AggregateUniqueResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Returns all the unique values from a particular column (specified by @a
 * columnName) of a particular table (specified by @a tableName). If @a
 * columnName is a numeric column the values will be in @a
 * binaryEncodedResponse. Otherwise if @a columnName is a string column the
 * values will be in @a jsonEncodedResponse.  @a offset and @a limit are used
 * to page through the results if there are large numbers of unique values. To
 * get the first 10 unique values sorted in descending order @a options would
 * be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>. If the 'result_table' option is provided then the
 * results are stored in a table with the name given in the option and the
 * results are not returned in the response.
 * 
 * @param tableName  Name of the table on which the operation will be
 *                   performed. Must be a valid table in GPUdb.
 * @param columnName  Name of the column or an expression containing one or
 *                    more column names on which the unique function would be
 *                    applied.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> expression: Optional filter expression to apply
 *                 to the table.
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted. Values: 'ascending', 'descending'.
 *                         <li> result_table: The name of the table used to
 *                 store the results. If present no results are returned in the
 *                 response.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AggregateUniqueResponse& GPUdb::aggregateUnique( const std::string& tableName,
                                                 const std::string& columnName,
                                                 const int64_t offset,
                                                 const int64_t limit,
                                                 const std::map<std::string, std::string>& options,
                                                 AggregateUniqueResponse& response_ ) const
{
    AggregateUniqueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnName = columnName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawAggregateUniqueResponse actualResponse_;
    submitRequest("/aggregate/unique", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of GPUdb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse GPUdb::alterSystemProperties( const AlterSystemPropertiesRequest& request_ ) const
{
    AlterSystemPropertiesResponse actualResponse_;
    submitRequest("/alter/system/properties", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of GPUdb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& GPUdb::alterSystemProperties( const AlterSystemPropertiesRequest& request_,
                                                             AlterSystemPropertiesResponse& response_ ) const
{
    submitRequest("/alter/system/properties", request_, response_, false);
    return response_;
}


/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of GPUdb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 *                            <ul>
 *                                    <li> sm_omp_threads: Set the number of
 *                            sm_omp_threads to the specified integer value.
 *                                    <li> kernel_omp_threads: Set the number
 *                            of kernel_omp_threads to the specified integer
 *                            value.
 *                                    <li> concurrent_kernel_execution: Enables
 *                            concurrent kernel execution if the value is
 *                            'true' and disables it if the value is 'false'.
 *                                    <li> chunk_size: Sets the chunk size of
 *                            all new sets to the specified integer value.
 *                                    <li> flush_to_disk: Flushes any changes
 *                            to any tables to the persistent store.  These
 *                            changes include updates to the vector store,
 *                            object store, and text search store, Value string
 *                            is ignored
 *                                    <li> clear_cache: Clears cached results.
 *                            Useful to allow repeated timing of endpoints.
 *                            Value string is ignored
 *                                    <li> communicator_test: Invoke the
 *                            communicator test and report timing results.
 *                            Value string is is a comma separated list of
 *                            <key>=<value> expressions.  Expressions are:
 *                            num_transactions = <num> where <num> is the
 *                            number of request reply transactions to invoke
 *                            per test; message_size = <bytes> where bytes is
 *                            the size of the messages to send in bytes;
 *                            check_values = <enabled> where if enabled is true
 *                            the value of the messages received are verified.
 *                                    <li> set_message_timers_enabled: Enables
 *                            the communicator test to collect additional
 *                            timing statistics when the value string is
 *                            'true'. Disables the collection when the value
 *                            string is 'false'
 *                                    <li> bulk_add_test: Invoke the bulk_add
 *                            test and report timing results. Value string is
 *                            ignored.
 *                                    <li> network_speed: Invoke the network
 *                            speed test and report timing results. Value
 *                            string is a comma separated list of <key>=<value>
 *                            expressions.  Expressions are: seconds = <time>
 *                            where time is the time in seconds to run the
 *                            test; data_size = <size> where <size> is the size
 *                            in bytes of the block to be transferred; threads
 *                            = <number of threads>; to_ranks = <comma
 *                            separated list of ranks> where the list of ranks
 *                            is the ranks that rank 0 will send data to and
 *                            get data from. If to_ranks is unspecified then
 *                            all worker ranks are used.
 *                                    <li> request_timeout: Number of minutes
 *                            after which /filter/ * and /aggregate/ * queries
 *                            will timeout.
 *                                    <li> max_get_records_size: set
 *                            max_get_records_size. default 20000
 *                            </ul>
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterSystemPropertiesResponse GPUdb::alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                            const std::map<std::string, std::string>& options ) const
{
    AlterSystemPropertiesRequest actualRequest_;
    actualRequest_.propertyUpdatesMap = propertyUpdatesMap;
    actualRequest_.options = options;
    AlterSystemPropertiesResponse actualResponse_;
    submitRequest("/alter/system/properties", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of GPUdb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 * 
 * @param propertyUpdatesMap  Map containing the properties of the system to be
 *                            updated. Error if empty.
 *                            <ul>
 *                                    <li> sm_omp_threads: Set the number of
 *                            sm_omp_threads to the specified integer value.
 *                                    <li> kernel_omp_threads: Set the number
 *                            of kernel_omp_threads to the specified integer
 *                            value.
 *                                    <li> concurrent_kernel_execution: Enables
 *                            concurrent kernel execution if the value is
 *                            'true' and disables it if the value is 'false'.
 *                                    <li> chunk_size: Sets the chunk size of
 *                            all new sets to the specified integer value.
 *                                    <li> flush_to_disk: Flushes any changes
 *                            to any tables to the persistent store.  These
 *                            changes include updates to the vector store,
 *                            object store, and text search store, Value string
 *                            is ignored
 *                                    <li> clear_cache: Clears cached results.
 *                            Useful to allow repeated timing of endpoints.
 *                            Value string is ignored
 *                                    <li> communicator_test: Invoke the
 *                            communicator test and report timing results.
 *                            Value string is is a comma separated list of
 *                            <key>=<value> expressions.  Expressions are:
 *                            num_transactions = <num> where <num> is the
 *                            number of request reply transactions to invoke
 *                            per test; message_size = <bytes> where bytes is
 *                            the size of the messages to send in bytes;
 *                            check_values = <enabled> where if enabled is true
 *                            the value of the messages received are verified.
 *                                    <li> set_message_timers_enabled: Enables
 *                            the communicator test to collect additional
 *                            timing statistics when the value string is
 *                            'true'. Disables the collection when the value
 *                            string is 'false'
 *                                    <li> bulk_add_test: Invoke the bulk_add
 *                            test and report timing results. Value string is
 *                            ignored.
 *                                    <li> network_speed: Invoke the network
 *                            speed test and report timing results. Value
 *                            string is a comma separated list of <key>=<value>
 *                            expressions.  Expressions are: seconds = <time>
 *                            where time is the time in seconds to run the
 *                            test; data_size = <size> where <size> is the size
 *                            in bytes of the block to be transferred; threads
 *                            = <number of threads>; to_ranks = <comma
 *                            separated list of ranks> where the list of ranks
 *                            is the ranks that rank 0 will send data to and
 *                            get data from. If to_ranks is unspecified then
 *                            all worker ranks are used.
 *                                    <li> request_timeout: Number of minutes
 *                            after which /filter/ * and /aggregate/ * queries
 *                            will timeout.
 *                                    <li> max_get_records_size: set
 *                            max_get_records_size. default 20000
 *                            </ul>
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterSystemPropertiesResponse& GPUdb::alterSystemProperties( const std::map<std::string, std::string>& propertyUpdatesMap,
                                                             const std::map<std::string, std::string>& options,
                                                             AlterSystemPropertiesResponse& response_ ) const
{
    AlterSystemPropertiesRequest actualRequest_;
    actualRequest_.propertyUpdatesMap = propertyUpdatesMap;
    actualRequest_.options = options;
    submitRequest("/alter/system/properties", actualRequest_, response_, false);
    return response_;
}


/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Creating or deleting an index on a particular column. This can speed up
 * certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&) const}, {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}, {@link
 * #updateRecordsRaw(const RawUpdateRecordsRequest&) const}) when using
 * expressions containing equality or relational operators on indexed columns.
 * This only applies to tables.
 * <p>
 *      Setting the time-to-live (TTL). This can be applied to tables, views,
 * or collections.  When applied to collections, every table & view within the
 * collection will have its TTL set to the given value.
 * <p>
 *      Making a table protected or not. Protected tables have their TTLs set
 * to not automatically expire. This can be applied to tables, views, and
 * collections.
 * <p>
 *      Allowing homogeneous tables within a collection.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse GPUdb::alterTable( const AlterTableRequest& request_ ) const
{
    AlterTableResponse actualResponse_;
    submitRequest("/alter/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Creating or deleting an index on a particular column. This can speed up
 * certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&,RawGetRecordsResponse&) const},
 * {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const},
 * {@link
 * #updateRecordsRaw(const RawUpdateRecordsRequest&,UpdateRecordsResponse&) const})
 * when using expressions containing equality or relational operators on
 * indexed columns. This only applies to tables.
 * <p>
 *      Setting the time-to-live (TTL). This can be applied to tables, views,
 * or collections.  When applied to collections, every table & view within the
 * collection will have its TTL set to the given value.
 * <p>
 *      Making a table protected or not. Protected tables have their TTLs set
 * to not automatically expire. This can be applied to tables, views, and
 * collections.
 * <p>
 *      Allowing homogeneous tables within a collection.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& GPUdb::alterTable( const AlterTableRequest& request_,
                                       AlterTableResponse& response_ ) const
{
    submitRequest("/alter/table", request_, response_, false);
    return response_;
}


/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Creating or deleting an index on a particular column. This can speed up
 * certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&) const}, {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const},
 * {@link #updateRecordsRaw(const RawUpdateRecordsRequest&) const}) when
 * using expressions containing equality or relational operators on indexed
 * columns. This only applies to tables.
 * <p>
 *      Setting the time-to-live (TTL). This can be applied to tables, views,
 * or collections.  When applied to collections, every table & view within the
 * collection will have its TTL set to the given value.
 * <p>
 *      Making a table protected or not. Protected tables have their TTLs set
 * to not automatically expire. This can be applied to tables, views, and
 * collections.
 * <p>
 *      Allowing homogeneous tables within a collection.
 * 
 * @param tableName  Table on which the operation will be performed. Must be a
 *                   valid table, view, or collection in GPUdb.
 * @param action  Modification operation to be applied Values: 'create_index',
 *                'delete_index', 'allow_homogeneous_tables', 'protected',
 *                'ttl', 'add_column', 'delete_column', 'change_column',
 *                'rename_table'.
 * @param value  The value of the modification. May be a column name, 'true' or
 *               'false', or a TTL depending on @a action.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> column_default_value: when adding a column: set
 *                 a default value, for existing data.
 *                         <li> column_properties: when adding or changing a
 *                 column: set the column properties (strings, separated by a
 *                 comma: data, store_only, text_search, char8, int8 etc).
 *                         <li> column_type: when adding or changing a column:
 *                 set the column type (strings, separated by a comma: int,
 *                 double, string, null etc).
 *                         <li> validate_change_column: Validate the type
 *                 change before applying column_change request. Default is
 *                 true (if option is missing). If True, then validate all
 *                 values. A value too large (or too long) for the new type
 *                 will prevent any change. If False, then when a value is too
 *                 large or long, it will be trancated. Values: 'true',
 *                 'false'.
 *                         <li> copy_values_from_column: when adding or
 *                 changing a column: enter column name - from where to copy
 *                 values.
 *                         <li> rename_column: new column name (using
 *                 change_column).
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableResponse GPUdb::alterTable( const std::string& tableName,
                                      const std::string& action,
                                      const std::string& value,
                                      const std::map<std::string, std::string>& options ) const
{
    AlterTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    AlterTableResponse actualResponse_;
    submitRequest("/alter/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Creating or deleting an index on a particular column. This can speed up
 * certain search queries (such as {@link
 * #getRecordsRaw(const GetRecordsRequest&) const}, {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&,DeleteRecordsResponse&) const},
 * {@link #updateRecordsRaw(const RawUpdateRecordsRequest&) const}) when
 * using expressions containing equality or relational operators on indexed
 * columns. This only applies to tables.
 * <p>
 *      Setting the time-to-live (TTL). This can be applied to tables, views,
 * or collections.  When applied to collections, every table & view within the
 * collection will have its TTL set to the given value.
 * <p>
 *      Making a table protected or not. Protected tables have their TTLs set
 * to not automatically expire. This can be applied to tables, views, and
 * collections.
 * <p>
 *      Allowing homogeneous tables within a collection.
 * 
 * @param tableName  Table on which the operation will be performed. Must be a
 *                   valid table, view, or collection in GPUdb.
 * @param action  Modification operation to be applied Values: 'create_index',
 *                'delete_index', 'allow_homogeneous_tables', 'protected',
 *                'ttl', 'add_column', 'delete_column', 'change_column',
 *                'rename_table'.
 * @param value  The value of the modification. May be a column name, 'true' or
 *               'false', or a TTL depending on @a action.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> column_default_value: when adding a column: set
 *                 a default value, for existing data.
 *                         <li> column_properties: when adding or changing a
 *                 column: set the column properties (strings, separated by a
 *                 comma: data, store_only, text_search, char8, int8 etc).
 *                         <li> column_type: when adding or changing a column:
 *                 set the column type (strings, separated by a comma: int,
 *                 double, string, null etc).
 *                         <li> validate_change_column: Validate the type
 *                 change before applying column_change request. Default is
 *                 true (if option is missing). If True, then validate all
 *                 values. A value too large (or too long) for the new type
 *                 will prevent any change. If False, then when a value is too
 *                 large or long, it will be trancated. Values: 'true',
 *                 'false'.
 *                         <li> copy_values_from_column: when adding or
 *                 changing a column: enter column name - from where to copy
 *                 values.
 *                         <li> rename_column: new column name (using
 *                 change_column).
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableResponse& GPUdb::alterTable( const std::string& tableName,
                                       const std::string& action,
                                       const std::string& value,
                                       const std::map<std::string, std::string>& options,
                                       AlterTableResponse& response_ ) const
{
    AlterTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    submitRequest("/alter/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse GPUdb::alterTableMetadata( const AlterTableMetadataRequest& request_ ) const
{
    AlterTableMetadataResponse actualResponse_;
    submitRequest("/alter/table/metadata", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& GPUdb::alterTableMetadata( const AlterTableMetadataRequest& request_,
                                                       AlterTableMetadataResponse& response_ ) const
{
    submitRequest("/alter/table/metadata", request_, response_, false);
    return response_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated. All
 *                    specified tables must exist in GPUdb, or GPUdb will
 *                    return an error.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterTableMetadataResponse GPUdb::alterTableMetadata( const std::vector<std::string>& tableNames,
                                                      const std::map<std::string, std::string>& metadataMap,
                                                      const std::map<std::string, std::string>& options ) const
{
    AlterTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.metadataMap = metadataMap;
    actualRequest_.options = options;
    AlterTableMetadataResponse actualResponse_;
    submitRequest("/alter/table/metadata", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 * 
 * @param tableNames  Names of the tables whose metadata will be updated. All
 *                    specified tables must exist in GPUdb, or GPUdb will
 *                    return an error.
 * @param metadataMap  A map which contains the metadata of the tables that are
 *                     to be updated. Note that only one map is provided for
 *                     all the tables; so the change will be applied to every
 *                     table. If the provided map is empty, then all existing
 *                     metadata for the table(s) will be cleared.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterTableMetadataResponse& GPUdb::alterTableMetadata( const std::vector<std::string>& tableNames,
                                                       const std::map<std::string, std::string>& metadataMap,
                                                       const std::map<std::string, std::string>& options,
                                                       AlterTableMetadataResponse& response_ ) const
{
    AlterTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.metadataMap = metadataMap;
    actualRequest_.options = options;
    submitRequest("/alter/table/metadata", actualRequest_, response_, false);
    return response_;
}


/**
 * Alters a user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterUserResponse GPUdb::alterUser( const AlterUserRequest& request_ ) const
{
    AlterUserResponse actualResponse_;
    submitRequest("/alter/user", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters a user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterUserResponse& GPUdb::alterUser( const AlterUserRequest& request_,
                                     AlterUserResponse& response_ ) const
{
    submitRequest("/alter/user", request_, response_, false);
    return response_;
}


/**
 * Alters a user.
 * 
 * @param name  Name of the user to be altered. Must be an existing user.
 * @param action  Modification operation to be applied to the user. Values:
 *                'set_password'.
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

AlterUserResponse GPUdb::alterUser( const std::string& name,
                                    const std::string& action,
                                    const std::string& value,
                                    const std::map<std::string, std::string>& options ) const
{
    AlterUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    AlterUserResponse actualResponse_;
    submitRequest("/alter/user", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Alters a user.
 * 
 * @param name  Name of the user to be altered. Must be an existing user.
 * @param action  Modification operation to be applied to the user. Values:
 *                'set_password'.
 * @param value  The value of the modification, depending on @a action.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

AlterUserResponse& GPUdb::alterUser( const std::string& name,
                                     const std::string& action,
                                     const std::string& value,
                                     const std::map<std::string, std::string>& options,
                                     AlterUserResponse& response_ ) const
{
    AlterUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.action = action;
    actualRequest_.value = value;
    actualRequest_.options = options;
    submitRequest("/alter/user", actualRequest_, response_, false);
    return response_;
}


/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse GPUdb::clearTable( const ClearTableRequest& request_ ) const
{
    ClearTableResponse actualResponse_;
    submitRequest("/clear/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& GPUdb::clearTable( const ClearTableRequest& request_,
                                       ClearTableResponse& response_ ) const
{
    submitRequest("/clear/table", request_, response_, false);
    return response_;
}


/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param tableName  Name of the table to be cleared. Must be an existing GPUdb
 *                   table. Empty string clears all available tables in GPUdb.
 *                   Default value is an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 *                       Default value is an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableResponse GPUdb::clearTable( const std::string& tableName,
                                      const std::string& authorization,
                                      const std::map<std::string, std::string>& options ) const
{
    ClearTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    ClearTableResponse actualResponse_;
    submitRequest("/clear/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared.
 * 
 * @param tableName  Name of the table to be cleared. Must be an existing GPUdb
 *                   table. Empty string clears all available tables in GPUdb.
 *                   Default value is an empty string.
 * @param authorization  No longer used. User can pass an empty string.
 *                       Default value is an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableResponse& GPUdb::clearTable( const std::string& tableName,
                                       const std::string& authorization,
                                       const std::map<std::string, std::string>& options,
                                       ClearTableResponse& response_ ) const
{
    ClearTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.authorization = authorization;
    actualRequest_.options = options;
    submitRequest("/clear/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse GPUdb::clearTableMonitor( const ClearTableMonitorRequest& request_ ) const
{
    ClearTableMonitorResponse actualResponse_;
    submitRequest("/clear/tablemonitor", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const CreateTableMonitorRequest&,CreateTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& GPUdb::clearTableMonitor( const ClearTableMonitorRequest& request_,
                                                     ClearTableMonitorResponse& response_ ) const
{
    submitRequest("/clear/tablemonitor", request_, response_, false);
    return response_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTableMonitorResponse GPUdb::clearTableMonitor( const std::string& topicId,
                                                    const std::map<std::string, std::string>& options ) const
{
    ClearTableMonitorRequest actualRequest_;
    actualRequest_.topicId = topicId;
    actualRequest_.options = options;
    ClearTableMonitorResponse actualResponse_;
    submitRequest("/clear/tablemonitor", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deactivates a table monitor previously created with {@link
 * #createTableMonitor(const std::string&,const std::map<std::string, std::string>&,CreateTableMonitorResponse&) const}.
 * 
 * @param topicId  The topic ID returned by /create/tablemonitor.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTableMonitorResponse& GPUdb::clearTableMonitor( const std::string& topicId,
                                                     const std::map<std::string, std::string>& options,
                                                     ClearTableMonitorResponse& response_ ) const
{
    ClearTableMonitorRequest actualRequest_;
    actualRequest_.topicId = topicId;
    actualRequest_.options = options;
    submitRequest("/clear/tablemonitor", actualRequest_, response_, false);
    return response_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse GPUdb::clearTrigger( const ClearTriggerRequest& request_ ) const
{
    ClearTriggerResponse actualResponse_;
    submitRequest("/clear/trigger", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& GPUdb::clearTrigger( const ClearTriggerRequest& request_,
                                           ClearTriggerResponse& response_ ) const
{
    submitRequest("/clear/trigger", request_, response_, false);
    return response_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ClearTriggerResponse GPUdb::clearTrigger( const std::string& triggerId,
                                          const std::map<std::string, std::string>& options ) const
{
    ClearTriggerRequest actualRequest_;
    actualRequest_.triggerId = triggerId;
    actualRequest_.options = options;
    ClearTriggerResponse actualResponse_;
    submitRequest("/clear/trigger", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 * 
 * @param triggerId  ID for the trigger to be deactivated.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ClearTriggerResponse& GPUdb::clearTrigger( const std::string& triggerId,
                                           const std::map<std::string, std::string>& options,
                                           ClearTriggerResponse& response_ ) const
{
    ClearTriggerRequest actualRequest_;
    actualRequest_.triggerId = triggerId;
    actualRequest_.options = options;
    submitRequest("/clear/trigger", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a table that is the result of a SQL JOIN.  For details see: <a
 * href="../../concepts/index.html#joins" target="_top">join concept
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse GPUdb::createJoinTable( const CreateJoinTableRequest& request_ ) const
{
    CreateJoinTableResponse actualResponse_;
    submitRequest("/create/jointable", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a table that is the result of a SQL JOIN.  For details see: <a
 * href="../../concepts/index.html#joins" target="_top">join concept
 * documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& GPUdb::createJoinTable( const CreateJoinTableRequest& request_,
                                                 CreateJoinTableResponse& response_ ) const
{
    submitRequest("/create/jointable", request_, response_, false);
    return response_;
}


/**
 * Creates a table that is the result of a SQL JOIN.  For details see: <a
 * href="../../concepts/index.html#joins" target="_top">join concept
 * documentation</a>.
 * 
 * @param joinTableName  Name of the join table to be created. Must not be the
 *                       name of a currently existing GPUdb table or join
 *                       table. Cannot be an empty string.
 * @param tableNames  The list of table names making up the joined set.
 *                    Corresponds to a SQL statement FROM clause  Default value
 *                    is an empty std::vector.
 * @param columnNames  The list of columns to be selected from the input table
 *                     names. Empty list says to select all the column names.
 *                     Empty list is the default.  Default value is an empty
 *                     std::vector.
 * @param expressions  An optional list of expressions GPUdb uses to combine
 *                     and filter the joined set.  Corresponds to a SQL
 *                     statement WHERE clause. For details see: <a
 *                     href="../../concepts/index.html#expressions"
 *                     target="_top">expressions</a>.  Default value is an
 *                     empty std::vector.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> collection_name: Name of a collection which is
 *                 to contain the join table. If empty, then the join table
 *                 will be a top-level table.
 *                         <li> max_query_dimensions: The maximum number of
 *                 tables in a joined table that can be accessed by a query and
 *                 are not equated by a foreign-key to primary-key equality
 *                 predicate
 *                         <li> optimize_lookups: Use the applied filters to
 *                 precalculate the lookup table to get data from the primary
 *                 key sets
 *                         <li> refresh_method: Method by which the join table
 *                 can be refreshed when underlying member tables have changed.
 *                 Values: 'manual', 'on_query', 'on_insert'.
 *                         <li> refresh: Do a manual refresh of the join table
 *                 if it exists - throws an error otherwise Values:
 *                 'no_refresh', 'refresh', 'full_refresh'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateJoinTableResponse GPUdb::createJoinTable( const std::string& joinTableName,
                                                const std::vector<std::string>& tableNames,
                                                const std::vector<std::string>& columnNames,
                                                const std::vector<std::string>& expressions,
                                                const std::map<std::string, std::string>& options ) const
{
    CreateJoinTableRequest actualRequest_;
    actualRequest_.joinTableName = joinTableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnNames = columnNames;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    CreateJoinTableResponse actualResponse_;
    submitRequest("/create/jointable", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a table that is the result of a SQL JOIN.  For details see: <a
 * href="../../concepts/index.html#joins" target="_top">join concept
 * documentation</a>.
 * 
 * @param joinTableName  Name of the join table to be created. Must not be the
 *                       name of a currently existing GPUdb table or join
 *                       table. Cannot be an empty string.
 * @param tableNames  The list of table names making up the joined set.
 *                    Corresponds to a SQL statement FROM clause  Default value
 *                    is an empty std::vector.
 * @param columnNames  The list of columns to be selected from the input table
 *                     names. Empty list says to select all the column names.
 *                     Empty list is the default.  Default value is an empty
 *                     std::vector.
 * @param expressions  An optional list of expressions GPUdb uses to combine
 *                     and filter the joined set.  Corresponds to a SQL
 *                     statement WHERE clause. For details see: <a
 *                     href="../../concepts/index.html#expressions"
 *                     target="_top">expressions</a>.  Default value is an
 *                     empty std::vector.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> collection_name: Name of a collection which is
 *                 to contain the join table. If empty, then the join table
 *                 will be a top-level table.
 *                         <li> max_query_dimensions: The maximum number of
 *                 tables in a joined table that can be accessed by a query and
 *                 are not equated by a foreign-key to primary-key equality
 *                 predicate
 *                         <li> optimize_lookups: Use the applied filters to
 *                 precalculate the lookup table to get data from the primary
 *                 key sets
 *                         <li> refresh_method: Method by which the join table
 *                 can be refreshed when underlying member tables have changed.
 *                 Values: 'manual', 'on_query', 'on_insert'.
 *                         <li> refresh: Do a manual refresh of the join table
 *                 if it exists - throws an error otherwise Values:
 *                 'no_refresh', 'refresh', 'full_refresh'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateJoinTableResponse& GPUdb::createJoinTable( const std::string& joinTableName,
                                                 const std::vector<std::string>& tableNames,
                                                 const std::vector<std::string>& columnNames,
                                                 const std::vector<std::string>& expressions,
                                                 const std::map<std::string, std::string>& options,
                                                 CreateJoinTableResponse& response_ ) const
{
    CreateJoinTableRequest actualRequest_;
    actualRequest_.joinTableName = joinTableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnNames = columnNames;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    submitRequest("/create/jointable", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProcResponse GPUdb::createProc( const CreateProcRequest& request_ ) const
{
    CreateProcResponse actualResponse_;
    submitRequest("/create/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProcResponse& GPUdb::createProc( const CreateProcRequest& request_,
                                       CreateProcResponse& response_ ) const
{
    submitRequest("/create/proc", request_, response_, false);
    return response_;
}


/**
 * Creates a proc.
 * 
 * @param procName  Name of the proc to be created. Must not be the name of a
 *                  currently existing proc.
 * @param executionMode  The execution mode of the proc. Values: 'distributed',
 *                       'nondistributed'.
 *                         Default value is 'distributed'.
 * @param files  A map of the files that make up the proc. The keys of the map
 *               are file names, and the values are the binary contents of the
 *               files. The file names may include subdirectory names (e.g.
 *               'subdir/file') but must not resolve to a directory above the
 *               root for the proc.  Default value is an empty std::map.
 * @param command  The command (excluding arguments) that will be invoked when
 *                 the proc is executed. It will be invoked from the directory
 *                 containing the proc @a files and may be any command that can
 *                 be resolved from that directory. It need not refer to a file
 *                 actually in that directory; for example, it could be 'java'
 *                 if the proc is a Java application; however, any necessary
 *                 external programs must be preinstalled on every GPUdb node.
 *                 If the command refers to a file in that directory, it must
 *                 be preceded with './' as per Linux convention. If not
 *                 specified, and exactly one file is provided in @a files,
 *                 that file will be invoked.  Default value is an empty
 *                 string.
 * @param args  An array of command-line arguments that will be passed to @a
 *              command when the proc is executed.  Default value is an empty
 *              std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProcResponse GPUdb::createProc( const std::string& procName,
                                      const std::string& executionMode,
                                      const std::map<std::string, std::vector<uint8_t> >& files,
                                      const std::string& command,
                                      const std::vector<std::string>& args,
                                      const std::map<std::string, std::string>& options ) const
{
    CreateProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.executionMode = executionMode;
    actualRequest_.files = files;
    actualRequest_.command = command;
    actualRequest_.args = args;
    actualRequest_.options = options;
    CreateProcResponse actualResponse_;
    submitRequest("/create/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a proc.
 * 
 * @param procName  Name of the proc to be created. Must not be the name of a
 *                  currently existing proc.
 * @param executionMode  The execution mode of the proc. Values: 'distributed',
 *                       'nondistributed'.
 *                         Default value is 'distributed'.
 * @param files  A map of the files that make up the proc. The keys of the map
 *               are file names, and the values are the binary contents of the
 *               files. The file names may include subdirectory names (e.g.
 *               'subdir/file') but must not resolve to a directory above the
 *               root for the proc.  Default value is an empty std::map.
 * @param command  The command (excluding arguments) that will be invoked when
 *                 the proc is executed. It will be invoked from the directory
 *                 containing the proc @a files and may be any command that can
 *                 be resolved from that directory. It need not refer to a file
 *                 actually in that directory; for example, it could be 'java'
 *                 if the proc is a Java application; however, any necessary
 *                 external programs must be preinstalled on every GPUdb node.
 *                 If the command refers to a file in that directory, it must
 *                 be preceded with './' as per Linux convention. If not
 *                 specified, and exactly one file is provided in @a files,
 *                 that file will be invoked.  Default value is an empty
 *                 string.
 * @param args  An array of command-line arguments that will be passed to @a
 *              command when the proc is executed.  Default value is an empty
 *              std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProcResponse& GPUdb::createProc( const std::string& procName,
                                       const std::string& executionMode,
                                       const std::map<std::string, std::vector<uint8_t> >& files,
                                       const std::string& command,
                                       const std::vector<std::string>& args,
                                       const std::map<std::string, std::string>& options,
                                       CreateProcResponse& response_ ) const
{
    CreateProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.executionMode = executionMode;
    actualRequest_.files = files;
    actualRequest_.command = command;
    actualRequest_.args = args;
    actualRequest_.options = options;
    submitRequest("/create/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProjectionResponse GPUdb::createProjection( const CreateProjectionRequest& request_ ) const
{
    CreateProjectionResponse actualResponse_;
    submitRequest("/create/projection", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProjectionResponse& GPUdb::createProjection( const CreateProjectionRequest& request_,
                                                   CreateProjectionResponse& response_ ) const
{
    submitRequest("/create/projection", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableName
 * @param projectionName
 * @param columnNames
 * @param options
 *                 <ul>
 *                         <li> collection_name:
 *                         <li> expression:
 *                         <li> limit:
 *                         <li> order_by:
 *                 </ul>
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateProjectionResponse GPUdb::createProjection( const std::string& tableName,
                                                  const std::string& projectionName,
                                                  const std::vector<std::string>& columnNames,
                                                  const std::map<std::string, std::string>& options ) const
{
    CreateProjectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.projectionName = projectionName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    CreateProjectionResponse actualResponse_;
    submitRequest("/create/projection", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableName
 * @param projectionName
 * @param columnNames
 * @param options
 *                 <ul>
 *                         <li> collection_name:
 *                         <li> expression:
 *                         <li> limit:
 *                         <li> order_by:
 *                 </ul>
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateProjectionResponse& GPUdb::createProjection( const std::string& tableName,
                                                   const std::string& projectionName,
                                                   const std::vector<std::string>& columnNames,
                                                   const std::map<std::string, std::string>& options,
                                                   CreateProjectionResponse& response_ ) const
{
    CreateProjectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.projectionName = projectionName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    submitRequest("/create/projection", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateRoleResponse GPUdb::createRole( const CreateRoleRequest& request_ ) const
{
    CreateRoleResponse actualResponse_;
    submitRequest("/create/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateRoleResponse& GPUdb::createRole( const CreateRoleRequest& request_,
                                       CreateRoleResponse& response_ ) const
{
    submitRequest("/create/role", request_, response_, false);
    return response_;
}


/**
 * Creates a new role.
 * 
 * @param name  Name of the role to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role in
 *              GPUdb.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateRoleResponse GPUdb::createRole( const std::string& name,
                                      const std::map<std::string, std::string>& options ) const
{
    CreateRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    CreateRoleResponse actualResponse_;
    submitRequest("/create/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new role.
 * 
 * @param name  Name of the role to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role in
 *              GPUdb.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateRoleResponse& GPUdb::createRole( const std::string& name,
                                       const std::map<std::string, std::string>& options,
                                       CreateRoleResponse& response_ ) const
{
    CreateRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/create/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new table or collection. If a new table is being created, the type
 * of the table is given by @a typeId, which must the be the ID of a currently
 * registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&) const}). The table will be created
 * inside a collection if the option @a collection_name is specified. If that
 * collection does not already exist, it will be created.

 * To create a new collection, specify the name of the collection in @a
 * tableName and set the @a is_collection option to @a true; @a typeId will be
 * ignored.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse GPUdb::createTable( const CreateTableRequest& request_ ) const
{
    CreateTableResponse actualResponse_;
    submitRequest("/create/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new table or collection. If a new table is being created, the type
 * of the table is given by @a typeId, which must the be the ID of a currently
 * registered type (i.e. one created via {@link
 * #createType(const CreateTypeRequest&,CreateTypeResponse&) const}). The
 * table will be created inside a collection if the option @a collection_name
 * is specified. If that collection does not already exist, it will be created.

 * To create a new collection, specify the name of the collection in @a
 * tableName and set the @a is_collection option to @a true; @a typeId will be
 * ignored.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& GPUdb::createTable( const CreateTableRequest& request_,
                                         CreateTableResponse& response_ ) const
{
    submitRequest("/create/table", request_, response_, false);
    return response_;
}


/**
 * Creates a new table or collection. If a new table is being created, the type
 * of the table is given by @a typeId, which must the be the ID of a currently
 * registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const}).
 * The table will be created inside a collection if the option @a
 * collection_name is specified. If that collection does not already exist, it
 * will be created.

 * To create a new collection, specify the name of the collection in @a
 * tableName and set the @a is_collection option to @a true; @a typeId will be
 * ignored.
 * 
 * @param tableName  Name of the table to be created. Must not be the name of a
 *                   currently existing table of a different type.  Error for
 *                   requests with existing table of the same name and type id
 *                   may be suppressed by using the @a no_error_if_exists
 *                   option.  Cannot be an empty string.  Valid characters are
 *                   alphanumeric or any of '_-(){}[] .:' (excluding the single
 *                   quotes), with the first character being alphanumeric or an
 *                   underscore.  The maximum length is 256 characters.
 * @param typeId  ID of a currently registered type. All objects added to the
 *                newly created table will be of this type.  Ignored if @a
 *                is_collection is @a true.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> no_error_if_exists: If @a true, prevents an
 *                 error from occurring if the table already exists and is of
 *                 the given type.  If a table with the same ID but a different
 *                 type exists, it is still an error. Values: 'true', 'false'.
 *                         <li> collection_name: Name of a collection which is
 *                 to contain the newly created table. If empty, then the newly
 *                 created table will be a top-level table. If the collection
 *                 does not allow duplicate types and it contains a table of
 *                 the same type as the given one, then this table creation
 *                 request will fail.
 *                         <li> is_collection: Indicates whether the new table
 *                 to be created will be a collection. Values: 'true', 'false'.
 *                         <li> disallow_homogeneous_tables: For a collection,
 *                 indicates whether the collection prohibits containment of
 *                 multiple tables of exactly the same data type. Values:
 *                 'true', 'false'.
 *                         <li> is_replicated: For a table, indicates whether
 *                 the table is to be replicated to all the database ranks.
 *                 This may be necessary when the table is to be joined with
 *                 other tables in a query. Values: 'true', 'false'.
 *                         <li> foreign_keys: Semicolon-separated list of
 *                 foreign key constraints, of the format 'source_column
 *                 references target_table(primary_key_column)'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableResponse GPUdb::createTable( const std::string& tableName,
                                        const std::string& typeId,
                                        const std::map<std::string, std::string>& options ) const
{
    CreateTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    CreateTableResponse actualResponse_;
    submitRequest("/create/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new table or collection. If a new table is being created, the type
 * of the table is given by @a typeId, which must the be the ID of a currently
 * registered type (i.e. one created via {@link
 * #createType(const std::string&,const std::string&,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,CreateTypeResponse&) const}).
 * The table will be created inside a collection if the option @a
 * collection_name is specified. If that collection does not already exist, it
 * will be created.

 * To create a new collection, specify the name of the collection in @a
 * tableName and set the @a is_collection option to @a true; @a typeId will be
 * ignored.
 * 
 * @param tableName  Name of the table to be created. Must not be the name of a
 *                   currently existing table of a different type.  Error for
 *                   requests with existing table of the same name and type id
 *                   may be suppressed by using the @a no_error_if_exists
 *                   option.  Cannot be an empty string.  Valid characters are
 *                   alphanumeric or any of '_-(){}[] .:' (excluding the single
 *                   quotes), with the first character being alphanumeric or an
 *                   underscore.  The maximum length is 256 characters.
 * @param typeId  ID of a currently registered type. All objects added to the
 *                newly created table will be of this type.  Ignored if @a
 *                is_collection is @a true.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> no_error_if_exists: If @a true, prevents an
 *                 error from occurring if the table already exists and is of
 *                 the given type.  If a table with the same ID but a different
 *                 type exists, it is still an error. Values: 'true', 'false'.
 *                         <li> collection_name: Name of a collection which is
 *                 to contain the newly created table. If empty, then the newly
 *                 created table will be a top-level table. If the collection
 *                 does not allow duplicate types and it contains a table of
 *                 the same type as the given one, then this table creation
 *                 request will fail.
 *                         <li> is_collection: Indicates whether the new table
 *                 to be created will be a collection. Values: 'true', 'false'.
 *                         <li> disallow_homogeneous_tables: For a collection,
 *                 indicates whether the collection prohibits containment of
 *                 multiple tables of exactly the same data type. Values:
 *                 'true', 'false'.
 *                         <li> is_replicated: For a table, indicates whether
 *                 the table is to be replicated to all the database ranks.
 *                 This may be necessary when the table is to be joined with
 *                 other tables in a query. Values: 'true', 'false'.
 *                         <li> foreign_keys: Semicolon-separated list of
 *                 foreign key constraints, of the format 'source_column
 *                 references target_table(primary_key_column)'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableResponse& GPUdb::createTable( const std::string& tableName,
                                         const std::string& typeId,
                                         const std::map<std::string, std::string>& options,
                                         CreateTableResponse& response_ ) const
{
    CreateTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    submitRequest("/create/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const ClearTableMonitorRequest&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse GPUdb::createTableMonitor( const CreateTableMonitorRequest& request_ ) const
{
    CreateTableMonitorResponse actualResponse_;
    submitRequest("/create/tablemonitor", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const ClearTableMonitorRequest&,ClearTableMonitorResponse&) const}.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& GPUdb::createTableMonitor( const CreateTableMonitorRequest& request_,
                                                       CreateTableMonitorResponse& response_ ) const
{
    submitRequest("/create/tablemonitor", request_, response_, false);
    return response_;
}


/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&) const}.
 * 
 * @param tableName  Name of the table to monitor. Must not refer to a
 *                   collection.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTableMonitorResponse GPUdb::createTableMonitor( const std::string& tableName,
                                                      const std::map<std::string, std::string>& options ) const
{
    CreateTableMonitorRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    CreateTableMonitorResponse actualResponse_;
    submitRequest("/create/tablemonitor", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by @a tableName) and forwards copies to subscribers via
 * ZMQ. After this call completes, subscribe to the returned @a topicId on the
 * GPUdb ZMQ table monitor port (default 9002). Each time an insert operation
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that was inserted. The monitor will continue to
 * run (regardless of whether or not there are any subscribers) until
 * deactivated with {@link
 * #clearTableMonitor(const std::string&,const std::map<std::string, std::string>&,ClearTableMonitorResponse&) const}.
 * 
 * @param tableName  Name of the table to monitor. Must not refer to a
 *                   collection.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTableMonitorResponse& GPUdb::createTableMonitor( const std::string& tableName,
                                                       const std::map<std::string, std::string>& options,
                                                       CreateTableMonitorResponse& response_ ) const
{
    CreateTableMonitorRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/create/tablemonitor", actualRequest_, response_, false);
    return response_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&) const}.) Once
 * the trigger has been activated, any record added to the listed tables(s) via
 * {@link #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&) const}-for any
 * listening client to collect. Active triggers can be cancelled by using the
 * {@link #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse GPUdb::createTriggerByArea( const CreateTriggerByAreaRequest& request_ ) const
{
    CreateTriggerByAreaResponse actualResponse_;
    submitRequest("/create/trigger/byarea", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const CreateTriggerByRangeRequest&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the chosen columns' values falling within the specified region will
 * trip the trigger. All such records will be queued at GPUdb's trigger port-by
 * default '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& GPUdb::createTriggerByArea( const CreateTriggerByAreaRequest& request_,
                                                         CreateTriggerByAreaResponse& response_ ) const
{
    submitRequest("/create/trigger/byarea", request_, response_, false);
    return response_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * columns' values falling within the specified region will trip the trigger.
 * All such records will be queued at GPUdb's trigger port-by default '9001'
 * but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger to be activated.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByAreaResponse GPUdb::createTriggerByArea( const std::string& requestId,
                                                        const std::vector<std::string>& tableNames,
                                                        const std::string& xColumnName,
                                                        const std::vector<double>& xVector,
                                                        const std::string& yColumnName,
                                                        const std::vector<double>& yVector,
                                                        const std::map<std::string, std::string>& options ) const
{
    CreateTriggerByAreaRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    CreateTriggerByAreaResponse actualResponse_;
    submitRequest("/create/trigger/byarea", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of {@link
 * #createTriggerByRange(const std::string&,const std::vector<std::string>&,const std::string&,const double,const double,const std::map<std::string, std::string>&,CreateTriggerByRangeResponse&) const}.)
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * columns' values falling within the specified region will trip the trigger.
 * All such records will be queued at GPUdb's trigger port-by default '9001'
 * but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger to be activated.
 * @param tableNames  Names of the tables on which the trigger will be
 *                    activated and maintained.
 * @param xColumnName  Name of a numeric column on which the trigger is
 *                     activated. Usually 'x' for geospatial data points.
 * @param xVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 x-coordinates of a geospatial region.
 * @param yColumnName  Name of a second numeric column on which the trigger is
 *                     activated. Usually 'y' for geospatial data points.
 * @param yVector  The respective coordinate values for the region on which the
 *                 trigger is activated. This usually translates to the
 *                 y-coordinates of a geospatial region. Must be the same
 *                 length as xvals.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByAreaResponse& GPUdb::createTriggerByArea( const std::string& requestId,
                                                         const std::vector<std::string>& tableNames,
                                                         const std::string& xColumnName,
                                                         const std::vector<double>& xVector,
                                                         const std::string& yColumnName,
                                                         const std::vector<double>& yVector,
                                                         const std::map<std::string, std::string>& options,
                                                         CreateTriggerByAreaResponse& response_ ) const
{
    CreateTriggerByAreaRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    submitRequest("/create/trigger/byarea", actualRequest_, response_, false);
    return response_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&) const}-for any
 * listening client to collect. Active triggers can be cancelled by using the
 * {@link #clearTrigger(const ClearTriggerRequest&) const} endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse GPUdb::createTriggerByRange( const CreateTriggerByRangeRequest& request_ ) const
{
    CreateTriggerByRangeResponse actualResponse_;
    submitRequest("/create/trigger/byrange", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const}
 * with the chosen column_name's value falling within the specified range will
 * trip the trigger. All such records will be queued at GPUdb's trigger port-by
 * default '9001' but can also be obtained via {@link
 * #showSystemStatus(const ShowSystemStatusRequest&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const ClearTriggerRequest&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& GPUdb::createTriggerByRange( const CreateTriggerByRangeRequest& request_,
                                                           CreateTriggerByRangeResponse& response_ ) const
{
    submitRequest("/create/trigger/byrange", request_, response_, false);
    return response_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger request.
 * @param tableNames  Tables on which the trigger will be active.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTriggerByRangeResponse GPUdb::createTriggerByRange( const std::string& requestId,
                                                          const std::vector<std::string>& tableNames,
                                                          const std::string& columnName,
                                                          const double min,
                                                          const double max,
                                                          const std::map<std::string, std::string>& options ) const
{
    CreateTriggerByRangeRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnName = columnName;
    actualRequest_.min = min;
    actualRequest_.max = max;
    actualRequest_.options = options;
    CreateTriggerByRangeResponse actualResponse_;
    submitRequest("/create/trigger/byrange", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const} with the chosen
 * column_name's value falling within the specified range will trip the
 * trigger. All such records will be queued at GPUdb's trigger port-by default
 * '9001' but can also be obtained via {@link
 * #showSystemStatus(const std::map<std::string, std::string>&,ShowSystemStatusResponse&) const}-for
 * any listening client to collect. Active triggers can be cancelled by using
 * the {@link
 * #clearTrigger(const std::string&,const std::map<std::string, std::string>&,ClearTriggerResponse&) const}
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 * 
 * @param requestId  ID for the trigger request.
 * @param tableNames  Tables on which the trigger will be active.
 * @param columnName  Name of a numeric column_name on which the trigger is
 *                    activated.
 * @param min  The lower bound (inclusive) for the trigger range.
 * @param max  The upper bound (inclusive) for the trigger range.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTriggerByRangeResponse& GPUdb::createTriggerByRange( const std::string& requestId,
                                                           const std::vector<std::string>& tableNames,
                                                           const std::string& columnName,
                                                           const double min,
                                                           const double max,
                                                           const std::map<std::string, std::string>& options,
                                                           CreateTriggerByRangeResponse& response_ ) const
{
    CreateTriggerByRangeRequest actualRequest_;
    actualRequest_.requestId = requestId;
    actualRequest_.tableNames = tableNames;
    actualRequest_.columnName = columnName;
    actualRequest_.min = min;
    actualRequest_.max = max;
    actualRequest_.options = options;
    submitRequest("/create/trigger/byrange", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary keys that match existing objects will either
 * overwrite (i.e. update) the existing object or will be skipped and not added
 * into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse GPUdb::createType( const CreateTypeRequest& request_ ) const
{
    CreateTypeResponse actualResponse_;
    submitRequest("/create/type", request_, actualResponse_, false);
    setDecoderIfMissing( actualResponse_.typeId,
                         actualResponse_.label,
                         actualResponse_.typeDefinition,
                         actualResponse_.properties );
    return actualResponse_;
}


/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&,InsertRecordsResponse&) const
 * inserting} data into a table with a primary key, depending on the parameters
 * in the request, incoming objects with primary keys that match existing
 * objects will either overwrite (i.e. update) the existing object or will be
 * skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& GPUdb::createType( const CreateTypeRequest& request_,
                                       CreateTypeResponse& response_ ) const
{
    submitRequest("/create/type", request_, response_, false);
    setDecoderIfMissing( response_.typeId,
                         response_.label,
                         response_.typeDefinition,
                         response_.properties );
    return response_;
}


/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary keys that match existing objects will either
 * overwrite (i.e. update) the existing object or will be skipped and not added
 * into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).  Default value is an empty std::map.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateTypeResponse GPUdb::createType( const std::string& typeDefinition,
                                      const std::string& label,
                                      const std::map<std::string, std::vector<std::string> >& properties,
                                      const std::map<std::string, std::string>& options ) const
{
    CreateTypeRequest actualRequest_;
    actualRequest_.typeDefinition = typeDefinition;
    actualRequest_.label = label;
    actualRequest_.properties = properties;
    actualRequest_.options = options;
    CreateTypeResponse actualResponse_;
    submitRequest("/create/type", actualRequest_, actualResponse_, false);
    setDecoderIfMissing( actualResponse_.typeId,
                         actualResponse_.label,
                         actualResponse_.typeDefinition,
                         actualResponse_.properties );
    return actualResponse_;
}


/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are @a data
 * and @a store_only.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When {@link
 * #insertRecordsRaw(const RawInsertRecordsRequest&) const inserting} data
 * into a table with a primary key, depending on the parameters in the request,
 * incoming objects with primary keys that match existing objects will either
 * overwrite (i.e. update) the existing object or will be skipped and not added
 * into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 * 
 * @param typeDefinition  a JSON string describing the columns of the type to
 *                        be registered.
 * @param label  A user-defined description string which can be used to
 *               differentiate between tables and types with otherwise
 *               identical schemas.
 * @param properties  Each key-value pair specifies the properties to use for a
 *                    given column where the key is the column name.  All keys
 *                    used must be relevant column names for the given table.
 *                    Specifying any property overrides the default properties
 *                    for that column (which is based on the column's data
 *                    type).  Default value is an empty std::map.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateTypeResponse& GPUdb::createType( const std::string& typeDefinition,
                                       const std::string& label,
                                       const std::map<std::string, std::vector<std::string> >& properties,
                                       const std::map<std::string, std::string>& options,
                                       CreateTypeResponse& response_ ) const
{
    CreateTypeRequest actualRequest_;
    actualRequest_.typeDefinition = typeDefinition;
    actualRequest_.label = label;
    actualRequest_.properties = properties;
    actualRequest_.options = options;
    submitRequest("/create/type", actualRequest_, response_, false);
    setDecoderIfMissing( response_.typeId,
                         response_.label,
                         response_.typeDefinition,
                         response_.properties );
    return response_;
}


/**
 * Creates a table that is the concatenation of one or more existing tables. It
 * is equivalent to the SQL UNION ALL operator.  Non-charN 'string' and 'bytes'
 * column types cannot be included in a union, neither can columns with the
 * property 'store_only'.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUnionResponse GPUdb::createUnion( const CreateUnionRequest& request_ ) const
{
    CreateUnionResponse actualResponse_;
    submitRequest("/create/union", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a table that is the concatenation of one or more existing tables. It
 * is equivalent to the SQL UNION ALL operator.  Non-charN 'string' and 'bytes'
 * column types cannot be included in a union, neither can columns with the
 * property 'store_only'.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUnionResponse& GPUdb::createUnion( const CreateUnionRequest& request_,
                                         CreateUnionResponse& response_ ) const
{
    submitRequest("/create/union", request_, response_, false);
    return response_;
}


/**
 * Creates a table that is the concatenation of one or more existing tables. It
 * is equivalent to the SQL UNION ALL operator.  Non-charN 'string' and 'bytes'
 * column types cannot be included in a union, neither can columns with the
 * property 'store_only'.
 * 
 * @param tableName  Name of the table to be created. Must not be the name of a
 *                   currently existing GPUdb table. Cannot be an empty string.
 * @param tableNames  The list of table names making up the union. Must contain
 *                    the names of one or more existing tables.
 * @param inputColumnNames  The list of columns from each of the corresponding
 *                          input tables.
 * @param outputColumnNames  The list of names of the columns to be stored in
 *                           the union.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> collection_name: Name of a collection which is
 *                 to contain the union. If empty, then the union will be a
 *                 top-level table.
 *                         <li> mode: If 'merge_views' then this operation will
 *                 merge (i.e. union) the provided views. All 'table_names'
 *                 must be views from the same underlying base table. Values:
 *                 'union_all', 'union', 'union_distinct', 'except',
 *                 'intersect', 'merge_views'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUnionResponse GPUdb::createUnion( const std::string& tableName,
                                        const std::vector<std::string>& tableNames,
                                        const std::vector<std::vector<std::string> >& inputColumnNames,
                                        const std::vector<std::string>& outputColumnNames,
                                        const std::map<std::string, std::string>& options ) const
{
    CreateUnionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputColumnNames = outputColumnNames;
    actualRequest_.options = options;
    CreateUnionResponse actualResponse_;
    submitRequest("/create/union", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a table that is the concatenation of one or more existing tables. It
 * is equivalent to the SQL UNION ALL operator.  Non-charN 'string' and 'bytes'
 * column types cannot be included in a union, neither can columns with the
 * property 'store_only'.
 * 
 * @param tableName  Name of the table to be created. Must not be the name of a
 *                   currently existing GPUdb table. Cannot be an empty string.
 * @param tableNames  The list of table names making up the union. Must contain
 *                    the names of one or more existing tables.
 * @param inputColumnNames  The list of columns from each of the corresponding
 *                          input tables.
 * @param outputColumnNames  The list of names of the columns to be stored in
 *                           the union.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> collection_name: Name of a collection which is
 *                 to contain the union. If empty, then the union will be a
 *                 top-level table.
 *                         <li> mode: If 'merge_views' then this operation will
 *                 merge (i.e. union) the provided views. All 'table_names'
 *                 must be views from the same underlying base table. Values:
 *                 'union_all', 'union', 'union_distinct', 'except',
 *                 'intersect', 'merge_views'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUnionResponse& GPUdb::createUnion( const std::string& tableName,
                                         const std::vector<std::string>& tableNames,
                                         const std::vector<std::vector<std::string> >& inputColumnNames,
                                         const std::vector<std::string>& outputColumnNames,
                                         const std::map<std::string, std::string>& options,
                                         CreateUnionResponse& response_ ) const
{
    CreateUnionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.tableNames = tableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputColumnNames = outputColumnNames;
    actualRequest_.options = options;
    submitRequest("/create/union", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserExternalResponse GPUdb::createUserExternal( const CreateUserExternalRequest& request_ ) const
{
    CreateUserExternalResponse actualResponse_;
    submitRequest("/create/user/external", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserExternalResponse& GPUdb::createUserExternal( const CreateUserExternalRequest& request_,
                                                       CreateUserExternalResponse& response_ ) const
{
    submitRequest("/create/user/external", request_, response_, false);
    return response_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param name  Name of the user to be created. Must exactly match the user's
 *              name in the external LDAP, prefixed with a @. Must not be the
 *              same name as an existing user in GPUdb.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserExternalResponse GPUdb::createUserExternal( const std::string& name,
                                                      const std::map<std::string, std::string>& options ) const
{
    CreateUserExternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    CreateUserExternalResponse actualResponse_;
    submitRequest("/create/user/external", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * 
 * @param name  Name of the user to be created. Must exactly match the user's
 *              name in the external LDAP, prefixed with a @. Must not be the
 *              same name as an existing user in GPUdb.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserExternalResponse& GPUdb::createUserExternal( const std::string& name,
                                                       const std::map<std::string, std::string>& options,
                                                       CreateUserExternalResponse& response_ ) const
{
    CreateUserExternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/create/user/external", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by GPUdb).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserInternalResponse GPUdb::createUserInternal( const CreateUserInternalRequest& request_ ) const
{
    CreateUserInternalResponse actualResponse_;
    submitRequest("/create/user/internal", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by GPUdb).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserInternalResponse& GPUdb::createUserInternal( const CreateUserInternalRequest& request_,
                                                       CreateUserInternalResponse& response_ ) const
{
    submitRequest("/create/user/internal", request_, response_, false);
    return response_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by GPUdb).
 * 
 * @param name  Name of the user to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role in
 *              GPUdb.
 * @param password  Initial password of the user to be created. May be an empty
 *                  string for no password.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

CreateUserInternalResponse GPUdb::createUserInternal( const std::string& name,
                                                      const std::string& password,
                                                      const std::map<std::string, std::string>& options ) const
{
    CreateUserInternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.password = password;
    actualRequest_.options = options;
    CreateUserInternalResponse actualResponse_;
    submitRequest("/create/user/internal", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates a new internal user (a user whose credentials are managed by GPUdb).
 * 
 * @param name  Name of the user to be created. Must contain only lowercase
 *              letters, digits, and underscores, and cannot begin with a
 *              digit. Must not be the same name as an existing user or role in
 *              GPUdb.
 * @param password  Initial password of the user to be created. May be an empty
 *                  string for no password.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

CreateUserInternalResponse& GPUdb::createUserInternal( const std::string& name,
                                                       const std::string& password,
                                                       const std::map<std::string, std::string>& options,
                                                       CreateUserInternalResponse& response_ ) const
{
    CreateUserInternalRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.password = password;
    actualRequest_.options = options;
    submitRequest("/create/user/internal", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteProcResponse GPUdb::deleteProc( const DeleteProcRequest& request_ ) const
{
    DeleteProcResponse actualResponse_;
    submitRequest("/delete/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteProcResponse& GPUdb::deleteProc( const DeleteProcRequest& request_,
                                       DeleteProcResponse& response_ ) const
{
    submitRequest("/delete/proc", request_, response_, false);
    return response_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param procName  Name of the proc to be deleted. Must be the name of a
 *                  currently existing proc.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteProcResponse GPUdb::deleteProc( const std::string& procName,
                                      const std::map<std::string, std::string>& options ) const
{
    DeleteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    DeleteProcResponse actualResponse_;
    submitRequest("/delete/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 * 
 * @param procName  Name of the proc to be deleted. Must be the name of a
 *                  currently existing proc.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteProcResponse& GPUdb::deleteProc( const std::string& procName,
                                       const std::map<std::string, std::string>& options,
                                       DeleteProcResponse& response_ ) const
{
    DeleteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/delete/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * options.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse GPUdb::deleteRecords( const DeleteRecordsRequest& request_ ) const
{
    DeleteRecordsResponse actualResponse_;
    submitRequest("/delete/records", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * options.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& GPUdb::deleteRecords( const DeleteRecordsRequest& request_,
                                             DeleteRecordsResponse& response_ ) const
{
    submitRequest("/delete/records", request_, response_, false);
    return response_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * options.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records. The set
 *                   must be a currently existing table and not a collection or
 *                   a view.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided /filter.
 *                     Specifying one or more @a expressions is mutually
 *                     exclusive to specifying @a record_id in the @a options.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> global_expression: An optional global
 *                 expression to reduce the search space of the @a expressions.
 *                         <li> record_id: A record id identifying a single
 *                 record, obtained at the time of /insert/records or by
 *                 calling /get/records/fromcollection with the
 *                 *return_record_ids* option.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRecordsResponse GPUdb::deleteRecords( const std::string& tableName,
                                            const std::vector<std::string>& expressions,
                                            const std::map<std::string, std::string>& options ) const
{
    DeleteRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    DeleteRecordsResponse actualResponse_;
    submitRequest("/delete/records", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  @a expressions
 * (matching multiple records) or a single record identified by @a record_id
 * options.  Note that the two selection criteria are mutually exclusive.  This
 * operation cannot be run on a collection or a view.  The operation is
 * synchronous meaning that a response will not be available until the request
 * is completely processed and all the matching records are deleted.
 * 
 * @param tableName  Name of the table from which to delete records. The set
 *                   must be a currently existing table and not a collection or
 *                   a view.
 * @param expressions  A list of the actual predicates, one for each select;
 *                     format should follow the guidelines provided /filter.
 *                     Specifying one or more @a expressions is mutually
 *                     exclusive to specifying @a record_id in the @a options.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> global_expression: An optional global
 *                 expression to reduce the search space of the @a expressions.
 *                         <li> record_id: A record id identifying a single
 *                 record, obtained at the time of /insert/records or by
 *                 calling /get/records/fromcollection with the
 *                 *return_record_ids* option.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRecordsResponse& GPUdb::deleteRecords( const std::string& tableName,
                                             const std::vector<std::string>& expressions,
                                             const std::map<std::string, std::string>& options,
                                             DeleteRecordsResponse& response_ ) const
{
    DeleteRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.expressions = expressions;
    actualRequest_.options = options;
    submitRequest("/delete/records", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes an existing role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRoleResponse GPUdb::deleteRole( const DeleteRoleRequest& request_ ) const
{
    DeleteRoleResponse actualResponse_;
    submitRequest("/delete/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRoleResponse& GPUdb::deleteRole( const DeleteRoleRequest& request_,
                                       DeleteRoleResponse& response_ ) const
{
    submitRequest("/delete/role", request_, response_, false);
    return response_;
}


/**
 * Deletes an existing role.
 * 
 * @param name  Name of the role to be deleted. Must be an existing role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteRoleResponse GPUdb::deleteRole( const std::string& name,
                                      const std::map<std::string, std::string>& options ) const
{
    DeleteRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    DeleteRoleResponse actualResponse_;
    submitRequest("/delete/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing role.
 * 
 * @param name  Name of the role to be deleted. Must be an existing role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteRoleResponse& GPUdb::deleteRole( const std::string& name,
                                       const std::map<std::string, std::string>& options,
                                       DeleteRoleResponse& response_ ) const
{
    DeleteRoleRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/delete/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Deletes an existing user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteUserResponse GPUdb::deleteUser( const DeleteUserRequest& request_ ) const
{
    DeleteUserResponse actualResponse_;
    submitRequest("/delete/user", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteUserResponse& GPUdb::deleteUser( const DeleteUserRequest& request_,
                                       DeleteUserResponse& response_ ) const
{
    submitRequest("/delete/user", request_, response_, false);
    return response_;
}


/**
 * Deletes an existing user.
 * 
 * @param name  Name of the user to be deleted. Must be an existing user.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

DeleteUserResponse GPUdb::deleteUser( const std::string& name,
                                      const std::map<std::string, std::string>& options ) const
{
    DeleteUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    DeleteUserResponse actualResponse_;
    submitRequest("/delete/user", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Deletes an existing user.
 * 
 * @param name  Name of the user to be deleted. Must be an existing user.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

DeleteUserResponse& GPUdb::deleteUser( const std::string& name,
                                       const std::map<std::string, std::string>& options,
                                       DeleteUserResponse& response_ ) const
{
    DeleteUserRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.options = options;
    submitRequest("/delete/user", actualRequest_, response_, false);
    return response_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse GPUdb::executeProc( const ExecuteProcRequest& request_ ) const
{
    ExecuteProcResponse actualResponse_;
    submitRequest("/execute/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& GPUdb::executeProc( const ExecuteProcRequest& request_,
                                         ExecuteProcResponse& response_ ) const
{
    submitRequest("/execute/proc", request_, response_, false);
    return response_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param procName  Name of the proc to execute. Must be the name of a
 *                  currently existing proc.
 * @param params  A map containing named parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.  Default value is an empty std::map.
 * @param binParams  A map containing named binary parameters to pass to the
 *                   proc. Each key/value pair specifies the name of a
 *                   parameter and its value.  Default value is an empty
 *                   std::map.
 * @param inputTableNames  Names of the tables containing data to be passed to
 *                         the proc. Each name specified must be the name of a
 *                         currently existing table. If no table names are
 *                         specified, no data will be passed to the proc.
 *                         Default value is an empty std::vector.
 * @param inputColumnNames  Map of table names from @a inputTableNames to lists
 *                          of names of columns from those tables that will be
 *                          passed to the proc. Each column name specified must
 *                          be the name of an existing column in the
 *                          corresponding table. If a table name from @a
 *                          inputTableNames is not included, all columns from
 *                          that table will be passed to the proc.  Default
 *                          value is an empty std::map.
 * @param outputTableNames  Names of the tables to which output data from the
 *                          proc will be written. If a specified table does not
 *                          exist, it will automatically be created with the
 *                          same schema as the corresponding table (by order)
 *                          from @a inputTableNames, excluding any primary and
 *                          shard keys. If no table names are specified, no
 *                          output data can be returned from the proc.  Default
 *                          value is an empty std::vector.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> cache_input: A comma-delimited list of table
 *                 names from @a inputTableNames from which input data will be
 *                 cached for use in subsequent calls to /execute/proc with the
 *                 @a use_cached_input option. Cached input data will be
 *                 retained until the proc status is cleared with the
 *                 /show/proc/status option of /show/proc/status and all proc
 *                 instances using the cached data have completed.
 *                         <li> use_cached_input: A comma-delimited list of run
 *                 IDs (as returned from prior calls to /execute/proc) of
 *                 running or completed proc instances from which input data
 *                 cached using the @a cache_input option will be used. Cached
 *                 input data will not be used for any tables specified in @a
 *                 inputTableNames, but data from all other tables cached for
 *                 the specified run IDs will be passed to the proc. If the
 *                 same table was cached for multiple specified run IDs, the
 *                 cached data from the first run ID specified in the list that
 *                 includes that table will be used.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ExecuteProcResponse GPUdb::executeProc( const std::string& procName,
                                        const std::map<std::string, std::string>& params,
                                        const std::map<std::string, std::vector<uint8_t> >& binParams,
                                        const std::vector<std::string>& inputTableNames,
                                        const std::map<std::string, std::vector<std::string> >& inputColumnNames,
                                        const std::vector<std::string>& outputTableNames,
                                        const std::map<std::string, std::string>& options ) const
{
    ExecuteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.params = params;
    actualRequest_.binParams = binParams;
    actualRequest_.inputTableNames = inputTableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputTableNames = outputTableNames;
    actualRequest_.options = options;
    ExecuteProcResponse actualResponse_;
    submitRequest("/execute/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Executes a proc. This endpoint is asynchronous and does not wait for the
 * proc to complete before returning.
 * 
 * @param procName  Name of the proc to execute. Must be the name of a
 *                  currently existing proc.
 * @param params  A map containing named parameters to pass to the proc. Each
 *                key/value pair specifies the name of a parameter and its
 *                value.  Default value is an empty std::map.
 * @param binParams  A map containing named binary parameters to pass to the
 *                   proc. Each key/value pair specifies the name of a
 *                   parameter and its value.  Default value is an empty
 *                   std::map.
 * @param inputTableNames  Names of the tables containing data to be passed to
 *                         the proc. Each name specified must be the name of a
 *                         currently existing table. If no table names are
 *                         specified, no data will be passed to the proc.
 *                         Default value is an empty std::vector.
 * @param inputColumnNames  Map of table names from @a inputTableNames to lists
 *                          of names of columns from those tables that will be
 *                          passed to the proc. Each column name specified must
 *                          be the name of an existing column in the
 *                          corresponding table. If a table name from @a
 *                          inputTableNames is not included, all columns from
 *                          that table will be passed to the proc.  Default
 *                          value is an empty std::map.
 * @param outputTableNames  Names of the tables to which output data from the
 *                          proc will be written. If a specified table does not
 *                          exist, it will automatically be created with the
 *                          same schema as the corresponding table (by order)
 *                          from @a inputTableNames, excluding any primary and
 *                          shard keys. If no table names are specified, no
 *                          output data can be returned from the proc.  Default
 *                          value is an empty std::vector.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> cache_input: A comma-delimited list of table
 *                 names from @a inputTableNames from which input data will be
 *                 cached for use in subsequent calls to /execute/proc with the
 *                 @a use_cached_input option. Cached input data will be
 *                 retained until the proc status is cleared with the
 *                 /show/proc/status option of /show/proc/status and all proc
 *                 instances using the cached data have completed.
 *                         <li> use_cached_input: A comma-delimited list of run
 *                 IDs (as returned from prior calls to /execute/proc) of
 *                 running or completed proc instances from which input data
 *                 cached using the @a cache_input option will be used. Cached
 *                 input data will not be used for any tables specified in @a
 *                 inputTableNames, but data from all other tables cached for
 *                 the specified run IDs will be passed to the proc. If the
 *                 same table was cached for multiple specified run IDs, the
 *                 cached data from the first run ID specified in the list that
 *                 includes that table will be used.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ExecuteProcResponse& GPUdb::executeProc( const std::string& procName,
                                         const std::map<std::string, std::string>& params,
                                         const std::map<std::string, std::vector<uint8_t> >& binParams,
                                         const std::vector<std::string>& inputTableNames,
                                         const std::map<std::string, std::vector<std::string> >& inputColumnNames,
                                         const std::vector<std::string>& outputTableNames,
                                         const std::map<std::string, std::string>& options,
                                         ExecuteProcResponse& response_ ) const
{
    ExecuteProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.params = params;
    actualRequest_.binParams = binParams;
    actualRequest_.inputTableNames = inputTableNames;
    actualRequest_.inputColumnNames = inputColumnNames;
    actualRequest_.outputTableNames = outputTableNames;
    actualRequest_.options = options;
    submitRequest("/execute/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse GPUdb::filter( const FilterRequest& request_ ) const
{
    FilterResponse actualResponse_;
    submitRequest("/filter", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& GPUdb::filter( const FilterRequest& request_,
                               FilterResponse& response_ ) const
{
    submitRequest("/filter", request_, response_, false);
    return response_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view .  Default value is an empty
 *                  string.
 * @param expression  The select expression GPUdb uses to filter the specified
 *                    table.  For details see <a
 *                    href="../../concepts/index.html#expressions"
 *                    target="_top">concepts</a>.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterResponse GPUdb::filter( const std::string& tableName,
                              const std::string& viewName,
                              const std::string& expression,
                              const std::map<std::string, std::string>& options ) const
{
    FilterRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.options = options;
    FilterResponse actualResponse_;
    submitRequest("/filter", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given @a viewName.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view .  Default value is an empty
 *                  string.
 * @param expression  The select expression GPUdb uses to filter the specified
 *                    table.  For details see <a
 *                    href="../../concepts/index.html#expressions"
 *                    target="_top">concepts</a>.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterResponse& GPUdb::filter( const std::string& tableName,
                               const std::string& viewName,
                               const std::string& expression,
                               const std::map<std::string, std::string>& options,
                               FilterResponse& response_ ) const
{
    FilterRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.options = options;
    submitRequest("/filter", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse GPUdb::filterByArea( const FilterByAreaRequest& request_ ) const
{
    FilterByAreaResponse actualResponse_;
    submitRequest("/filter/byarea", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& GPUdb::filterByArea( const FilterByAreaRequest& request_,
                                           FilterByAreaResponse& response_ ) const
{
    submitRequest("/filter/byarea", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table or a view (when chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByAreaResponse GPUdb::filterByArea( const std::string& tableName,
                                          const std::string& viewName,
                                          const std::string& xColumnName,
                                          const std::vector<double>& xVector,
                                          const std::string& yColumnName,
                                          const std::vector<double>& yVector,
                                          const std::map<std::string, std::string>& options ) const
{
    FilterByAreaRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    FilterByAreaResponse actualResponse_;
    submitRequest("/filter/byarea", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name @a viewName passed in as part of the input.
 * 
 * @param tableName  Name of the table to filter.  This may be the name of a
 *                   collection, a table or a view (when chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column containing the x values to be
 *                     filtered.
 * @param xVector  List of x coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param yColumnName  Name of the column containing the y values to be
 *                     filtered.
 * @param yVector  List of y coordinates of the vertices of the polygon
 *                 representing the area to be filtered.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByAreaResponse& GPUdb::filterByArea( const std::string& tableName,
                                           const std::string& viewName,
                                           const std::string& xColumnName,
                                           const std::vector<double>& xVector,
                                           const std::string& yColumnName,
                                           const std::vector<double>& yVector,
                                           const std::map<std::string, std::string>& options,
                                           FilterByAreaResponse& response_ ) const
{
    FilterByAreaRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xVector = xVector;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yVector = yVector;
    actualRequest_.options = options;
    submitRequest("/filter/byarea", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse GPUdb::filterByBox( const FilterByBoxRequest& request_ ) const
{
    FilterByBoxResponse actualResponse_;
    submitRequest("/filter/bybox", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& GPUdb::filterByBox( const FilterByBoxRequest& request_,
                                         FilterByBoxResponse& response_ ) const
{
    submitRequest("/filter/bybox", request_, response_, false);
    return response_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be a valid table in GPUdb.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Must not be an already
 *                  existing collection, table or view in GPUdb.  Default value
 *                  is an empty string.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByBoxResponse GPUdb::filterByBox( const std::string& tableName,
                                        const std::string& viewName,
                                        const std::string& xColumnName,
                                        const double minX,
                                        const double maxX,
                                        const std::string& yColumnName,
                                        const double minY,
                                        const double maxY,
                                        const std::map<std::string, std::string>& options ) const
{
    FilterByBoxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.options = options;
    FilterByBoxResponse actualResponse_;
    submitRequest("/filter/bybox", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a @a viewName is passed
 * in as part of the input payload.
 * 
 * @param tableName  Name of the table on which the bounding box operation will
 *                   be performed. Must be a valid table in GPUdb.
 * @param viewName  Optional name of the result view that will be created
 *                  containing the results of the query. Must not be an already
 *                  existing collection, table or view in GPUdb.  Default value
 *                  is an empty string.
 * @param xColumnName  Name of the column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minX  Lower bound for the column chosen by @a xColumnName.  Must be
 *              less than or equal to @a maxX.
 * @param maxX  Upper bound for @a xColumnName.  Must be greater than or equal
 *              to @a minX.
 * @param yColumnName  Name of a column on which to perform the bounding box
 *                     query. If the table's data type is not a shape type,
 *                     must be a valid numeric column.
 * @param minY  Lower bound for @a yColumnName. Must be less than or equal to
 *              @a maxY.
 * @param maxY  Upper bound for @a yColumnName. Must be greater than or equal
 *              to @a minY.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByBoxResponse& GPUdb::filterByBox( const std::string& tableName,
                                         const std::string& viewName,
                                         const std::string& xColumnName,
                                         const double minX,
                                         const double maxX,
                                         const std::string& yColumnName,
                                         const double minY,
                                         const double maxY,
                                         const std::map<std::string, std::string>& options,
                                         FilterByBoxResponse& response_ ) const
{
    FilterByBoxRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.options = options;
    submitRequest("/filter/bybox", actualRequest_, response_, false);
    return response_;
}


/**
 * Applies a geometry filter against a spatial column named WKT in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse GPUdb::filterByGeometry( const FilterByGeometryRequest& request_ ) const
{
    FilterByGeometryResponse actualResponse_;
    submitRequest("/filter/bygeometry", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Applies a geometry filter against a spatial column named WKT in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& GPUdb::filterByGeometry( const FilterByGeometryRequest& request_,
                                                   FilterByGeometryResponse& response_ ) const
{
    submitRequest("/filter/bygeometry", request_, response_, false);
    return response_;
}


/**
 * Applies a geometry filter against a spatial column named WKT in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by geometry will be
 *                   performed.  Must be an existing table, collection or view
 *                   containing a column named WKT.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column to be used in the filter. Must be
 *                    'WKT'
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName.  Default value is an empty string.
 * @param operation  The geometric filtering operation to perform Values:
 *                   'contains', 'crosses', 'disjoint', 'equals', 'intersects',
 *                   'overlaps', 'touches', 'within'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByGeometryResponse GPUdb::filterByGeometry( const std::string& tableName,
                                                  const std::string& viewName,
                                                  const std::string& columnName,
                                                  const std::string& inputWkt,
                                                  const std::string& operation,
                                                  const std::map<std::string, std::string>& options ) const
{
    FilterByGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.inputWkt = inputWkt;
    actualRequest_.operation = operation;
    actualRequest_.options = options;
    FilterByGeometryResponse actualResponse_;
    submitRequest("/filter/bygeometry", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Applies a geometry filter against a spatial column named WKT in a given
 * table, collection or view. The filtering geometry is provided by @a
 * inputWkt.
 * 
 * @param tableName  Name of the table on which the filter by geometry will be
 *                   performed.  Must be an existing table, collection or view
 *                   containing a column named WKT.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column to be used in the filter. Must be
 *                    'WKT'
 * @param inputWkt  A geometry in WKT format that will be used to filter the
 *                  objects in @a tableName.  Default value is an empty string.
 * @param operation  The geometric filtering operation to perform Values:
 *                   'contains', 'crosses', 'disjoint', 'equals', 'intersects',
 *                   'overlaps', 'touches', 'within'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByGeometryResponse& GPUdb::filterByGeometry( const std::string& tableName,
                                                   const std::string& viewName,
                                                   const std::string& columnName,
                                                   const std::string& inputWkt,
                                                   const std::string& operation,
                                                   const std::map<std::string, std::string>& options,
                                                   FilterByGeometryResponse& response_ ) const
{
    FilterByGeometryRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.inputWkt = inputWkt;
    actualRequest_.operation = operation;
    actualRequest_.options = options;
    submitRequest("/filter/bygeometry", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse GPUdb::filterByList( const FilterByListRequest& request_ ) const
{
    FilterByListResponse actualResponse_;
    submitRequest("/filter/bylist", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& GPUdb::filterByList( const FilterByListRequest& request_,
                                           FilterByListResponse& response_ ) const
{
    submitRequest("/filter/bylist", request_, response_, false);
    return response_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> filter_mode: String indicating the filter mode,
 *                 either 'in_list' or 'not_in_list'. Values: 'in_list',
 *                 'not_in_list'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByListResponse GPUdb::filterByList( const std::string& tableName,
                                          const std::string& viewName,
                                          const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                          const std::map<std::string, std::string>& options ) const
{
    FilterByListRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnValuesMap = columnValuesMap;
    actualRequest_.options = options;
    FilterByListResponse actualResponse_;
    submitRequest("/filter/bylist", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a @a viewName is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 * 
 * @param tableName  Name of the table to filter.  This may be the ID of a
 *                   collection, table or a result set (for chaining queries).
 *                   Collections may be filtered only if all tables within the
 *                   collection have the same type ID.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnValuesMap  List of values for the corresponding column in the
 *                         table
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> filter_mode: String indicating the filter mode,
 *                 either 'in_list' or 'not_in_list'. Values: 'in_list',
 *                 'not_in_list'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByListResponse& GPUdb::filterByList( const std::string& tableName,
                                           const std::string& viewName,
                                           const std::map<std::string, std::vector<std::string> >& columnValuesMap,
                                           const std::map<std::string, std::string>& options,
                                           FilterByListResponse& response_ ) const
{
    FilterByListRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnValuesMap = columnValuesMap;
    actualRequest_.options = options;
    submitRequest("/filter/bylist", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse GPUdb::filterByRadius( const FilterByRadiusRequest& request_ ) const
{
    FilterByRadiusResponse actualResponse_;
    submitRequest("/filter/byradius", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& GPUdb::filterByRadius( const FilterByRadiusRequest& request_,
                                               FilterByRadiusResponse& response_ ) const
{
    submitRequest("/filter/byradius", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRadiusResponse GPUdb::filterByRadius( const std::string& tableName,
                                              const std::string& viewName,
                                              const std::string& xColumnName,
                                              const double xCenter,
                                              const std::string& yColumnName,
                                              const double yCenter,
                                              const double radius,
                                              const std::map<std::string, std::string>& options ) const
{
    FilterByRadiusRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xCenter = xCenter;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yCenter = yCenter;
    actualRequest_.radius = radius;
    actualRequest_.options = options;
    FilterByRadiusResponse actualResponse_;
    submitRequest("/filter/byradius", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a @a viewName is passed in as
 * part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 * 
 * @param tableName  Name of the table on which the filter by radius operation
 *                   will be performed.  Must be an existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param xColumnName  Name of the column to be used for the x-coordinate (the
 *                     longitude) of the center.
 * @param xCenter  Value of the longitude of the center. Must be within
 *                 [-180.0, 180.0].  The minimum allowed value is -180. The
 *                 maximum allowed value is 180.
 * @param yColumnName  Name of the column to be used for the y-coordinate-the
 *                     latitude-of the center.
 * @param yCenter  Value of the latitude of the center. Must be within [-90.0,
 *                 90.0].  The minimum allowed value is -90. The maximum
 *                 allowed value is 90.
 * @param radius  The radius of the circle within which the search will be
 *                performed. Must be a non-zero positive value. It is in
 *                meters; so, for example, a value of '42000' means 42 km.  The
 *                minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRadiusResponse& GPUdb::filterByRadius( const std::string& tableName,
                                               const std::string& viewName,
                                               const std::string& xColumnName,
                                               const double xCenter,
                                               const std::string& yColumnName,
                                               const double yCenter,
                                               const double radius,
                                               const std::map<std::string, std::string>& options,
                                               FilterByRadiusResponse& response_ ) const
{
    FilterByRadiusRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.xCenter = xCenter;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.yCenter = yCenter;
    actualRequest_.radius = radius;
    actualRequest_.options = options;
    submitRequest("/filter/byradius", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse GPUdb::filterByRange( const FilterByRangeRequest& request_ ) const
{
    FilterByRangeResponse actualResponse_;
    submitRequest("/filter/byrange", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& GPUdb::filterByRange( const FilterByRangeRequest& request_,
                                             FilterByRangeResponse& response_ ) const
{
    submitRequest("/filter/byrange", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed.  Must be a valid GPUdb table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByRangeResponse GPUdb::filterByRange( const std::string& tableName,
                                            const std::string& viewName,
                                            const std::string& columnName,
                                            const double lowerBound,
                                            const double upperBound,
                                            const std::map<std::string, std::string>& options ) const
{
    FilterByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.lowerBound = lowerBound;
    actualRequest_.upperBound = upperBound;
    actualRequest_.options = options;
    FilterByRangeResponse actualResponse_;
    submitRequest("/filter/byrange", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by @a tableName is added to the
 * view @a viewName if its column is within [@a lowerBound, @a upperBound]
 * (inclusive). The operation is synchronous. The response provides a count of
 * the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 * 
 * @param tableName  Name of the table on which the filter by range operation
 *                   will be performed.  Must be a valid GPUdb table.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the operation would be applied.
 * @param lowerBound  Value of the lower bound (inclusive).
 * @param upperBound  Value of the upper bound (inclusive).
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByRangeResponse& GPUdb::filterByRange( const std::string& tableName,
                                             const std::string& viewName,
                                             const std::string& columnName,
                                             const double lowerBound,
                                             const double upperBound,
                                             const std::map<std::string, std::string>& options,
                                             FilterByRangeResponse& response_ ) const
{
    FilterByRangeRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.lowerBound = lowerBound;
    actualRequest_.upperBound = upperBound;
    actualRequest_.options = options;
    submitRequest("/filter/byrange", actualRequest_, response_, false);
    return response_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse GPUdb::filterBySeries( const FilterBySeriesRequest& request_ ) const
{
    FilterBySeriesResponse actualResponse_;
    submitRequest("/filter/byseries", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& GPUdb::filterBySeries( const FilterBySeriesRequest& request_,
                                               FilterBySeriesResponse& response_ ) const
{
    submitRequest("/filter/byseries", request_, response_, false);
    return response_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed. Must be a currently existing table with
 *                   track semantic type.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> spatial_radius: A positive number passed as a
 *                 string representing the radius of the search area centered
 *                 around each track point's geospatial coordinates. The value
 *                 is interpreted in meters. Required parameter.
 *                         <li> time_radius: A positive number passed as a
 *                 string representing the maximum allowable time difference
 *                 between the timestamps of a filtered object and the given
 *                 track's points. The value is interpreted in seconds.
 *                 Required parameter.
 *                         <li> spatial_distance_metric: A string representing
 *                 the coordinate system to use for the spatial search
 *                 criteria. Acceptable values are 'euclidean' and
 *                 'great_circle'. Optional parameter; default is 'euclidean'.
 *                 Values: 'euclidean', 'great_circle'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterBySeriesResponse GPUdb::filterBySeries( const std::string& tableName,
                                              const std::string& viewName,
                                              const std::string& trackId,
                                              const std::vector<std::string>& targetTrackIds,
                                              const std::map<std::string, std::string>& options ) const
{
    FilterBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.trackId = trackId;
    actualRequest_.targetTrackIds = targetTrackIds;
    actualRequest_.options = options;
    FilterBySeriesResponse actualResponse_;
    submitRequest("/filter/byseries", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and
 * temporal-of all points of the given track. Additionally, the user can
 * specify another track to see if the two intersect (or go close to each other
 * within the specified ranges). The user also has the flexibility of using
 * different metrics for the spatial distance calculation: Euclidean (flat
 * geometry) or Great Circle (spherical geometry to approximate the Earth's
 * surface distances). The filtered points are stored in a newly created result
 * set. The return value of the function is the number of points in the
 * resultant set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 * 
 * @param tableName  Name of the table on which the filter by track operation
 *                   will be performed. Must be a currently existing table with
 *                   track semantic type.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param trackId  The ID of the track which will act as the filtering points.
 *                 Must be an existing track within the given table.
 * @param targetTrackIds  Up to one track ID to intersect with the "filter"
 *                        track. If any provided, it must be an valid track ID
 *                        within the given set.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> spatial_radius: A positive number passed as a
 *                 string representing the radius of the search area centered
 *                 around each track point's geospatial coordinates. The value
 *                 is interpreted in meters. Required parameter.
 *                         <li> time_radius: A positive number passed as a
 *                 string representing the maximum allowable time difference
 *                 between the timestamps of a filtered object and the given
 *                 track's points. The value is interpreted in seconds.
 *                 Required parameter.
 *                         <li> spatial_distance_metric: A string representing
 *                 the coordinate system to use for the spatial search
 *                 criteria. Acceptable values are 'euclidean' and
 *                 'great_circle'. Optional parameter; default is 'euclidean'.
 *                 Values: 'euclidean', 'great_circle'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterBySeriesResponse& GPUdb::filterBySeries( const std::string& tableName,
                                               const std::string& viewName,
                                               const std::string& trackId,
                                               const std::vector<std::string>& targetTrackIds,
                                               const std::map<std::string, std::string>& options,
                                               FilterBySeriesResponse& response_ ) const
{
    FilterBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.trackId = trackId;
    actualRequest_.targetTrackIds = targetTrackIds;
    actualRequest_.options = options;
    submitRequest("/filter/byseries", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The 'mode' may be:

 * * search : full text search query with wildcards and boolean operators, e.g.
 * '(bob* OR sue) AND NOT jane'. Note that for this mode, no column can be
 * specified in @a columnNames; GPUdb will search through all string columns of
 * the table that have text search enabled. Also, the first character of a
 * search term cannot be a wildcard (* or ?), and search terms cannot be any of
 * the following:  "a", "an", "and", "are", "as", "at", "be", "but", "by",
 * "for", "if", "in", "into", "is", "it", "no", "not", "of", "on", "or",
 * "such", "that", "the", "their", "then", "there", "these", "they", "this",
 * "to", "was", "will", "with".
 *     Search query types:
 *         * Multiple search terms
 *             ex. perfect union - will match any record containing "perfect",
 * "union", or both.
 *         * Exact phrases
 *             ex. "Perfect Union" - will only match the exact phrase "Perfect
 * Union"
 *         * Boolean (NOT, AND, OR, parentheses. OR assumed if no operator
 * specified)
 *             ex. justice AND tranquility - will match only those records
 * containing both justice and tranquility
 *         * XOR (specified with -)
 *             ex. justice - peace - will match records containing "justice" or
 * "peace", but not both
 *         * Zero or more char wildcard - (specified with *)
 *             ex, est*is* - will match any records containing a word that
 * starts with "est" and ends with "sh", such as "establish", "establishable",
 * and "establishment"
 *         * Exactly one char wildcard - (specified with ?)
 *             ex. est???is* - will only match strings that start with "est",
 * followed by exactly three letters, followed by "is", followed by one more
 * letter.  This would only match "establish"
 *         * Fuzzy search (term~)
 *             ex. rear~ will match rear,fear,bear,read,etc.
 *         * Proximity - match two words within a specified distance of
 * eachother
 *             ex. "Union Tranquility"~10 will match any record that has the
 * words Union and Tranquility within 10 words of eachother
 *         * Range - inclusive [<term1> TO <term2>] and exclusive {<term1> TO
 * <term2>}.  Note: This is a string search, so numbers will be seen as a
 * string of numeric characters, not as a number.  Ex. 2 > 123
 *             ex. [100 TO 200] will find all strings between 100 and 200
 * inclusive.
 *             ex. {alpha to beta} will find all strings between alpha and
 * beta, but not the words alpha or beta
 *         * escaping special characters - Special characters are escaped with
 * a backslash(\), special characters are: + - && || ! ( ) { } [ ] ^ " ~ * ? :
 * \
 * <p>
 * * equals: exact whole-string match (accelerated)
 * * contains: partial substring match (not accelerated).  If the column is a
 * string type (non-charN) and the number of records is too large, it will
 * return 0.
 * * starts_with: strings that start with the given expression (not
 * accelerated), If the column is a string type (non-charN) and the number of
 * records is too large, it will return 0.
 * * regex: full regular expression search (not accelerated). If the column is
 * a string type (non-charN) and the number of records is too large, it will
 * return 0.
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse GPUdb::filterByString( const FilterByStringRequest& request_ ) const
{
    FilterByStringResponse actualResponse_;
    submitRequest("/filter/bystring", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The 'mode' may be:

 * * search : full text search query with wildcards and boolean operators, e.g.
 * '(bob* OR sue) AND NOT jane'. Note that for this mode, no column can be
 * specified in @a columnNames; GPUdb will search through all string columns of
 * the table that have text search enabled. Also, the first character of a
 * search term cannot be a wildcard (* or ?), and search terms cannot be any of
 * the following:  "a", "an", "and", "are", "as", "at", "be", "but", "by",
 * "for", "if", "in", "into", "is", "it", "no", "not", "of", "on", "or",
 * "such", "that", "the", "their", "then", "there", "these", "they", "this",
 * "to", "was", "will", "with".
 *     Search query types:
 *         * Multiple search terms
 *             ex. perfect union - will match any record containing "perfect",
 * "union", or both.
 *         * Exact phrases
 *             ex. "Perfect Union" - will only match the exact phrase "Perfect
 * Union"
 *         * Boolean (NOT, AND, OR, parentheses. OR assumed if no operator
 * specified)
 *             ex. justice AND tranquility - will match only those records
 * containing both justice and tranquility
 *         * XOR (specified with -)
 *             ex. justice - peace - will match records containing "justice" or
 * "peace", but not both
 *         * Zero or more char wildcard - (specified with *)
 *             ex, est*is* - will match any records containing a word that
 * starts with "est" and ends with "sh", such as "establish", "establishable",
 * and "establishment"
 *         * Exactly one char wildcard - (specified with ?)
 *             ex. est???is* - will only match strings that start with "est",
 * followed by exactly three letters, followed by "is", followed by one more
 * letter.  This would only match "establish"
 *         * Fuzzy search (term~)
 *             ex. rear~ will match rear,fear,bear,read,etc.
 *         * Proximity - match two words within a specified distance of
 * eachother
 *             ex. "Union Tranquility"~10 will match any record that has the
 * words Union and Tranquility within 10 words of eachother
 *         * Range - inclusive [<term1> TO <term2>] and exclusive {<term1> TO
 * <term2>}.  Note: This is a string search, so numbers will be seen as a
 * string of numeric characters, not as a number.  Ex. 2 > 123
 *             ex. [100 TO 200] will find all strings between 100 and 200
 * inclusive.
 *             ex. {alpha to beta} will find all strings between alpha and
 * beta, but not the words alpha or beta
 *         * escaping special characters - Special characters are escaped with
 * a backslash(\), special characters are: + - && || ! ( ) { } [ ] ^ " ~ * ? :
 * \
 * <p>
 * * equals: exact whole-string match (accelerated)
 * * contains: partial substring match (not accelerated).  If the column is a
 * string type (non-charN) and the number of records is too large, it will
 * return 0.
 * * starts_with: strings that start with the given expression (not
 * accelerated), If the column is a string type (non-charN) and the number of
 * records is too large, it will return 0.
 * * regex: full regular expression search (not accelerated). If the column is
 * a string type (non-charN) and the number of records is too large, it will
 * return 0.
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& GPUdb::filterByString( const FilterByStringRequest& request_,
                                               FilterByStringResponse& response_ ) const
{
    submitRequest("/filter/bystring", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The 'mode' may be:

 * * search : full text search query with wildcards and boolean operators, e.g.
 * '(bob* OR sue) AND NOT jane'. Note that for this mode, no column can be
 * specified in @a columnNames; GPUdb will search through all string columns of
 * the table that have text search enabled. Also, the first character of a
 * search term cannot be a wildcard (* or ?), and search terms cannot be any of
 * the following:  "a", "an", "and", "are", "as", "at", "be", "but", "by",
 * "for", "if", "in", "into", "is", "it", "no", "not", "of", "on", "or",
 * "such", "that", "the", "their", "then", "there", "these", "they", "this",
 * "to", "was", "will", "with".
 *     Search query types:
 *         * Multiple search terms
 *             ex. perfect union - will match any record containing "perfect",
 * "union", or both.
 *         * Exact phrases
 *             ex. "Perfect Union" - will only match the exact phrase "Perfect
 * Union"
 *         * Boolean (NOT, AND, OR, parentheses. OR assumed if no operator
 * specified)
 *             ex. justice AND tranquility - will match only those records
 * containing both justice and tranquility
 *         * XOR (specified with -)
 *             ex. justice - peace - will match records containing "justice" or
 * "peace", but not both
 *         * Zero or more char wildcard - (specified with *)
 *             ex, est*is* - will match any records containing a word that
 * starts with "est" and ends with "sh", such as "establish", "establishable",
 * and "establishment"
 *         * Exactly one char wildcard - (specified with ?)
 *             ex. est???is* - will only match strings that start with "est",
 * followed by exactly three letters, followed by "is", followed by one more
 * letter.  This would only match "establish"
 *         * Fuzzy search (term~)
 *             ex. rear~ will match rear,fear,bear,read,etc.
 *         * Proximity - match two words within a specified distance of
 * eachother
 *             ex. "Union Tranquility"~10 will match any record that has the
 * words Union and Tranquility within 10 words of eachother
 *         * Range - inclusive [<term1> TO <term2>] and exclusive {<term1> TO
 * <term2>}.  Note: This is a string search, so numbers will be seen as a
 * string of numeric characters, not as a number.  Ex. 2 > 123
 *             ex. [100 TO 200] will find all strings between 100 and 200
 * inclusive.
 *             ex. {alpha to beta} will find all strings between alpha and
 * beta, but not the words alpha or beta
 *         * escaping special characters - Special characters are escaped with
 * a backslash(\), special characters are: + - && || ! ( ) { } [ ] ^ " ~ * ? :
 * \
 * <p>
 * * equals: exact whole-string match (accelerated)
 * * contains: partial substring match (not accelerated).  If the column is a
 * string type (non-charN) and the number of records is too large, it will
 * return 0.
 * * starts_with: strings that start with the given expression (not
 * accelerated), If the column is a string type (non-charN) and the number of
 * records is too large, it will return 0.
 * * regex: full regular expression search (not accelerated). If the column is
 * a string type (non-charN) and the number of records is too large, it will
 * return 0.
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed.  Must be a valid GPUdb table, collection or
 *                   view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See above for details.
 *              Values: 'search', 'equals', 'contains', 'starts_with', 'regex'.
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for 'search' mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> case_sensitive: If 'false' then string
 *                 filtering will ignore case. Does not apply to 'search' mode.
 *                 Values: 'true', 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByStringResponse GPUdb::filterByString( const std::string& tableName,
                                              const std::string& viewName,
                                              const std::string& expression,
                                              const std::string& mode,
                                              const std::vector<std::string>& columnNames,
                                              const std::map<std::string, std::string>& options ) const
{
    FilterByStringRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.mode = mode;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    FilterByStringResponse actualResponse_;
    submitRequest("/filter/bystring", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table, collection, or view match a string
 * expression for the given string columns. The 'mode' may be:

 * * search : full text search query with wildcards and boolean operators, e.g.
 * '(bob* OR sue) AND NOT jane'. Note that for this mode, no column can be
 * specified in @a columnNames; GPUdb will search through all string columns of
 * the table that have text search enabled. Also, the first character of a
 * search term cannot be a wildcard (* or ?), and search terms cannot be any of
 * the following:  "a", "an", "and", "are", "as", "at", "be", "but", "by",
 * "for", "if", "in", "into", "is", "it", "no", "not", "of", "on", "or",
 * "such", "that", "the", "their", "then", "there", "these", "they", "this",
 * "to", "was", "will", "with".
 *     Search query types:
 *         * Multiple search terms
 *             ex. perfect union - will match any record containing "perfect",
 * "union", or both.
 *         * Exact phrases
 *             ex. "Perfect Union" - will only match the exact phrase "Perfect
 * Union"
 *         * Boolean (NOT, AND, OR, parentheses. OR assumed if no operator
 * specified)
 *             ex. justice AND tranquility - will match only those records
 * containing both justice and tranquility
 *         * XOR (specified with -)
 *             ex. justice - peace - will match records containing "justice" or
 * "peace", but not both
 *         * Zero or more char wildcard - (specified with *)
 *             ex, est*is* - will match any records containing a word that
 * starts with "est" and ends with "sh", such as "establish", "establishable",
 * and "establishment"
 *         * Exactly one char wildcard - (specified with ?)
 *             ex. est???is* - will only match strings that start with "est",
 * followed by exactly three letters, followed by "is", followed by one more
 * letter.  This would only match "establish"
 *         * Fuzzy search (term~)
 *             ex. rear~ will match rear,fear,bear,read,etc.
 *         * Proximity - match two words within a specified distance of
 * eachother
 *             ex. "Union Tranquility"~10 will match any record that has the
 * words Union and Tranquility within 10 words of eachother
 *         * Range - inclusive [<term1> TO <term2>] and exclusive {<term1> TO
 * <term2>}.  Note: This is a string search, so numbers will be seen as a
 * string of numeric characters, not as a number.  Ex. 2 > 123
 *             ex. [100 TO 200] will find all strings between 100 and 200
 * inclusive.
 *             ex. {alpha to beta} will find all strings between alpha and
 * beta, but not the words alpha or beta
 *         * escaping special characters - Special characters are escaped with
 * a backslash(\), special characters are: + - && || ! ( ) { } [ ] ^ " ~ * ? :
 * \
 * <p>
 * * equals: exact whole-string match (accelerated)
 * * contains: partial substring match (not accelerated).  If the column is a
 * string type (non-charN) and the number of records is too large, it will
 * return 0.
 * * starts_with: strings that start with the given expression (not
 * accelerated), If the column is a string type (non-charN) and the number of
 * records is too large, it will return 0.
 * * regex: full regular expression search (not accelerated). If the column is
 * a string type (non-charN) and the number of records is too large, it will
 * return 0.
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 * 
 * @param tableName  Name of the table on which the filter operation will be
 *                   performed.  Must be a valid GPUdb table, collection or
 *                   view.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param expression  The expression with which to filter the table.
 * @param mode  The string filtering mode to apply. See above for details.
 *              Values: 'search', 'equals', 'contains', 'starts_with', 'regex'.
 * @param columnNames  List of columns on which to apply the filter. Ignored
 *                     for 'search' mode.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> case_sensitive: If 'false' then string
 *                 filtering will ignore case. Does not apply to 'search' mode.
 *                 Values: 'true', 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByStringResponse& GPUdb::filterByString( const std::string& tableName,
                                               const std::string& viewName,
                                               const std::string& expression,
                                               const std::string& mode,
                                               const std::vector<std::string>& columnNames,
                                               const std::map<std::string, std::string>& options,
                                               FilterByStringResponse& response_ ) const
{
    FilterByStringRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.expression = expression;
    actualRequest_.mode = mode;
    actualRequest_.columnNames = columnNames;
    actualRequest_.options = options;
    submitRequest("/filter/bystring", actualRequest_, response_, false);
    return response_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse GPUdb::filterByTable( const FilterByTableRequest& request_ ) const
{
    FilterByTableResponse actualResponse_;
    submitRequest("/filter/bytable", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& GPUdb::filterByTable( const FilterByTableRequest& request_,
                                             FilterByTableResponse& response_ ) const
{
    submitRequest("/filter/bytable", request_, response_, false);
    return response_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param tableName  Name of the table whose data will be filtered. Must be an
 *                   existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName. Must be an
 *                         existing table in GPUdb.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must match the type of the
 *                               @a columnName.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> filter_mode: String indicating the filter mode,
 *                 either 'in_table' or 'not_in_table'. Values: 'in_table',
 *                 'not_in_table'.
 *                         <li> mode: Mode - should be either 'spatial' or
 *                 'normal'. Values: 'normal', 'spatial'.
 *                         <li> buffer: Buffer size, in meters. Only relevant
 *                 for 'spatial' mode.
 *                         <li> buffer_method: Method used to buffer polygons.
 *                 Only relevant for 'spatial' mode. Values: 'normal', 'geos'.
 *                         <li> max_partition_size: Maximum number of points in
 *                 a partition. Only relevant for 'spatial' mode.
 *                         <li> max_partition_score: Maximum number of points *
 *                 edges in a partition. Only relevant for 'spatial' mode.
 *                         <li> x_column_name: Name of column containing x
 *                 value of point being filtered in spatial mode.
 *                         <li> y_column_name: Name of column containing x
 *                 value of point being filtered in spatial mode.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByTableResponse GPUdb::filterByTable( const std::string& tableName,
                                            const std::string& viewName,
                                            const std::string& columnName,
                                            const std::string& sourceTableName,
                                            const std::string& sourceTableColumnName,
                                            const std::map<std::string, std::string>& options ) const
{
    FilterByTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.sourceTableName = sourceTableName;
    actualRequest_.sourceTableColumnName = sourceTableColumnName;
    actualRequest_.options = options;
    FilterByTableResponse actualResponse_;
    submitRequest("/filter/bytable", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a @a viewName is specified, then the filtered objects will then be put in a
 * newly created view. The operation is synchronous, meaning that GPUdb will
 * not return until all objects are fully available in the result view. The
 * return value contains the count (i.e. the size) of the resulting view.
 * 
 * @param tableName  Name of the table whose data will be filtered. Must be an
 *                   existing table in GPUdb.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param columnName  Name of the column by whose value the data will be
 *                    filtered from the table designated by @a tableName.
 * @param sourceTableName  Name of the table whose data will be compared
 *                         against in the table called @a tableName. Must be an
 *                         existing table in GPUdb.
 * @param sourceTableColumnName  Name of the column in the @a sourceTableName
 *                               whose values will be used as the filter for
 *                               table @a tableName. Must match the type of the
 *                               @a columnName.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> filter_mode: String indicating the filter mode,
 *                 either 'in_table' or 'not_in_table'. Values: 'in_table',
 *                 'not_in_table'.
 *                         <li> mode: Mode - should be either 'spatial' or
 *                 'normal'. Values: 'normal', 'spatial'.
 *                         <li> buffer: Buffer size, in meters. Only relevant
 *                 for 'spatial' mode.
 *                         <li> buffer_method: Method used to buffer polygons.
 *                 Only relevant for 'spatial' mode. Values: 'normal', 'geos'.
 *                         <li> max_partition_size: Maximum number of points in
 *                 a partition. Only relevant for 'spatial' mode.
 *                         <li> max_partition_score: Maximum number of points *
 *                 edges in a partition. Only relevant for 'spatial' mode.
 *                         <li> x_column_name: Name of column containing x
 *                 value of point being filtered in spatial mode.
 *                         <li> y_column_name: Name of column containing x
 *                 value of point being filtered in spatial mode.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByTableResponse& GPUdb::filterByTable( const std::string& tableName,
                                             const std::string& viewName,
                                             const std::string& columnName,
                                             const std::string& sourceTableName,
                                             const std::string& sourceTableColumnName,
                                             const std::map<std::string, std::string>& options,
                                             FilterByTableResponse& response_ ) const
{
    FilterByTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.columnName = columnName;
    actualRequest_.sourceTableName = sourceTableName;
    actualRequest_.sourceTableColumnName = sourceTableColumnName;
    actualRequest_.options = options;
    submitRequest("/filter/bytable", actualRequest_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse GPUdb::filterByValue( const FilterByValueRequest& request_ ) const
{
    FilterByValueResponse actualResponse_;
    submitRequest("/filter/byvalue", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& GPUdb::filterByValue( const FilterByValueRequest& request_,
                                             FilterByValueResponse& response_ ) const
{
    submitRequest("/filter/byvalue", request_, response_, false);
    return response_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param tableName  Name of an existing GPUdb table on which to perform the
 *                   calculation.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.  Default value is 0.
 * @param valueStr  The string value to search for.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the filter by value would be applied.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

FilterByValueResponse GPUdb::filterByValue( const std::string& tableName,
                                            const std::string& viewName,
                                            const bool isString,
                                            const double value,
                                            const std::string& valueStr,
                                            const std::string& columnName,
                                            const std::map<std::string, std::string>& options ) const
{
    FilterByValueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.isString = isString;
    actualRequest_.value = value;
    actualRequest_.valueStr = valueStr;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    FilterByValueResponse actualResponse_;
    submitRequest("/filter/byvalue", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 * 
 * @param tableName  Name of an existing GPUdb table on which to perform the
 *                   calculation.
 * @param viewName  If provided, then this will be the name of the view
 *                  containing the results. Must not be an already existing
 *                  collection, table or view.  Default value is an empty
 *                  string.
 * @param isString  Indicates whether the value being searched for is string or
 *                  numeric.
 * @param value  The value to search for.  Default value is 0.
 * @param valueStr  The string value to search for.  Default value is an empty
 *                  string.
 * @param columnName  Name of a column or an expression of one or more columns
 *                    on which the filter by value would be applied.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

FilterByValueResponse& GPUdb::filterByValue( const std::string& tableName,
                                             const std::string& viewName,
                                             const bool isString,
                                             const double value,
                                             const std::string& valueStr,
                                             const std::string& columnName,
                                             const std::map<std::string, std::string>& options,
                                             FilterByValueResponse& response_ ) const
{
    FilterByValueRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.viewName = viewName;
    actualRequest_.isString = isString;
    actualRequest_.value = value;
    actualRequest_.valueStr = valueStr;
    actualRequest_.columnName = columnName;
    actualRequest_.options = options;
    submitRequest("/filter/byvalue", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsResponse GPUdb::getRecordsRaw( const GetRecordsRequest& request_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsResponse& GPUdb::getRecordsRaw( const GetRecordsRequest& request_,
                                             RawGetRecordsResponse& response_ ) const
{
    submitRequest("/get/records", request_, response_, false);
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsResponse<boost::any> GPUdb::getRecords( const GetRecordsRequest& request_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    GetRecordsResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsResponse<boost::any>& GPUdb::getRecords( const GetRecordsRequest& request_,
                                                   GetRecordsResponse<boost::any>& response_ ) const
{
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options
 *                 <ul>
 *                         <li> expression: Optional filter expression to apply
 *                 to the table.
 *                         <li> sort_by: Optional column that the data should
 *                 be sorted by. Empty by default (i.e. no sorting is applied).
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted - ascending or descending. Ignored
 *                 if 'sort_by' option is not specified. Values: 'ascending',
 *                 'descending'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsResponse<boost::any> GPUdb::getRecords( const std::string& tableName,
                                                  const int64_t offset,
                                                  const int64_t limit,
                                                  const std::map<std::string, std::string>& options ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    GetRecordsResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters. Note that when paging through a table, if the table (or
 * the underlying table in case of a view) is updated (records are inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param tableName  Name of the table from which the records will be fetched.
 *                   Must be a table, view or homogeneous collection.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned. Or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options
 *                 <ul>
 *                         <li> expression: Optional filter expression to apply
 *                 to the table.
 *                         <li> sort_by: Optional column that the data should
 *                 be sorted by. Empty by default (i.e. no sorting is applied).
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted - ascending or descending. Ignored
 *                 if 'sort_by' option is not specified. Values: 'ascending',
 *                 'descending'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsResponse<boost::any>& GPUdb::getRecords( const std::string& tableName,
                                                   const int64_t offset,
                                                   const int64_t limit,
                                                   const std::map<std::string, std::string>& options,
                                                   GetRecordsResponse<boost::any>& response_ ) const
{
    GetRecordsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsResponse actualResponse_;
    submitRequest("/get/records", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeName = actualResponse_.typeName;
    response_.typeSchema = actualResponse_.typeSchema;
    avro::DecoderPtr dataDecoder_ = getDecoder(actualResponse_.typeName);
    dataDecoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
    dataDecoder_->decode(&response_.data[0], &actualResponse_.recordsBinary[0], actualResponse_.recordsBinary.size(), this->threadCount, this->executor);
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsByColumnResponse GPUdb::getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_ ) const
{
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsByColumnResponse& GPUdb::getRecordsByColumnRaw( const GetRecordsByColumnRequest& request_,
                                                             RawGetRecordsByColumnResponse& response_ ) const
{
    submitRequest("/get/records/bycolumn", request_, response_, false);
    return response_;
}


/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse GPUdb::getRecordsByColumn( const GetRecordsByColumnRequest& request_ ) const
{
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", request_, actualResponse_, false);
    GetRecordsByColumnResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& GPUdb::getRecordsByColumn( const GetRecordsByColumnRequest& request_,
                                                       GetRecordsByColumnResponse& response_ ) const
{
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which this operation will be
 *                   performed. The table cannot be a parent set.
 * @param columnNames  The list of column values to retrieve. Columns annotated
 *                     as store only cannot be retrieved.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000), or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be returned.
 * @param options
 *                 <ul>
 *                         <li> expression: Optional filter expression to apply
 *                 to the table.
 *                         <li> sort_by: Optional column that the data should
 *                 be sorted by. Empty by default (i.e. no sorting is applied).
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted - ascending or descending. Default
 *                 is 'ascending'. Ignored if 'sort_by' option is not
 *                 specified. Values: 'ascending', 'descending'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GetRecordsByColumnResponse GPUdb::getRecordsByColumn( const std::string& tableName,
                                                      const std::vector<std::string>& columnNames,
                                                      const int64_t offset,
                                                      const int64_t limit,
                                                      const std::map<std::string, std::string>& options ) const
{
    GetRecordsByColumnRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", actualRequest_, actualResponse_, false);
    GetRecordsByColumnResponse response_;
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * 
 * @param tableName  Name of the table on which this operation will be
 *                   performed. The table cannot be a parent set.
 * @param columnNames  The list of column values to retrieve. Columns annotated
 *                     as store only cannot be retrieved.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                The minimum allowed value is 0. The maximum allowed value is
 *                MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned (if not provided the default is 10000), or
 *               END_OF_SET (-9999) to indicate that the maximum number of
 *               results allowed by the server should be returned.
 * @param options
 *                 <ul>
 *                         <li> expression: Optional filter expression to apply
 *                 to the table.
 *                         <li> sort_by: Optional column that the data should
 *                 be sorted by. Empty by default (i.e. no sorting is applied).
 *                         <li> sort_order: String indicating how the returned
 *                 values should be sorted - ascending or descending. Default
 *                 is 'ascending'. Ignored if 'sort_by' option is not
 *                 specified. Values: 'ascending', 'descending'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GetRecordsByColumnResponse& GPUdb::getRecordsByColumn( const std::string& tableName,
                                                       const std::vector<std::string>& columnNames,
                                                       const int64_t offset,
                                                       const int64_t limit,
                                                       const std::map<std::string, std::string>& options,
                                                       GetRecordsByColumnResponse& response_ ) const
{
    GetRecordsByColumnRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.columnNames = columnNames;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsByColumnResponse actualResponse_;
    submitRequest("/get/records/bycolumn", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.responseSchemaStr = actualResponse_.responseSchemaStr;
    gpudb::GenericRecord::transpose( actualResponse_.responseSchemaStr, actualResponse_.binaryEncodedResponse, response_.data );
    response_.totalNumberOfRecords = actualResponse_.totalNumberOfRecords;
    response_.hasMoreRecords = actualResponse_.hasMoreRecords;
    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link #getRecordsRaw(const GetRecordsRequest&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsBySeriesResponse GPUdb::getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecordsRaw(const GetRecordsRequest&,RawGetRecordsResponse&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsBySeriesResponse& GPUdb::getRecordsBySeriesRaw( const GetRecordsBySeriesRequest& request_,
                                                             RawGetRecordsBySeriesResponse& response_ ) const
{
    submitRequest("/get/records/byseries", request_, response_, false);
    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link #getRecords(const GetRecordsRequest&) const} this
 * returns records grouped by series/track. So if @a offset is 0 and @a limit
 * is 5 this operation would return the first 5 series/tracks in @a tableName.
 * Each series/track will be returned sorted by their TIMESTAMP column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any> GPUdb::getRecordsBySeries( const GetRecordsBySeriesRequest& request_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    GetRecordsBySeriesResponse<boost::any> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const GetRecordsRequest&,GetRecordsResponse<boost::any>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any>& GPUdb::getRecordsBySeries( const GetRecordsBySeriesRequest& request_,
                                                                   GetRecordsBySeriesResponse<boost::any>& response_ ) const
{
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", request_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  Default value is 0. The minimum allowed value is
 *                0. The maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 *               Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any> GPUdb::getRecordsBySeries( const std::string& tableName,
                                                                  const std::string& worldTableName,
                                                                  const int32_t offset,
                                                                  const int32_t limit,
                                                                  const std::map<std::string, std::string>& options ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    GetRecordsBySeriesResponse<boost::any> response_;
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves the complete series/track records from the given @a worldTableName
 * based on the partial track information contained in the @a tableName.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * In contrast to {@link
 * #getRecords(const std::string&,const int64_t,const int64_t,const std::map<std::string, std::string>&,GetRecordsResponse<boost::any>&) const}
 * this returns records grouped by series/track. So if @a offset is 0 and @a
 * limit is 5 this operation would return the first 5 series/tracks in @a
 * tableName. Each series/track will be returned sorted by their TIMESTAMP
 * column.
 * 
 * @param tableName  Name of the collection/table/view for which series/tracks
 *                   will be fetched.
 * @param worldTableName  Name of the table containing the complete
 *                        series/track information to be returned for the
 *                        tracks present in the @a tableName. Typically this is
 *                        used when retrieving series/tracks from a view (which
 *                        contains partial series/tracks) but the user wants to
 *                        retrieve the entire original series/tracks. Can be
 *                        blank.
 * @param offset  A positive integer indicating the number of initial
 *                series/tracks to skip (useful for paging through the
 *                results).  Default value is 0. The minimum allowed value is
 *                0. The maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of
 *               series/tracks to be returned. Or END_OF_SET (-9999) to
 *               indicate that the max number of results should be returned.
 *               Default value is 10000.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsBySeriesResponse<boost::any>& GPUdb::getRecordsBySeries( const std::string& tableName,
                                                                   const std::string& worldTableName,
                                                                   const int32_t offset,
                                                                   const int32_t limit,
                                                                   const std::map<std::string, std::string>& options,
                                                                   GetRecordsBySeriesResponse<boost::any>& response_ ) const
{
    GetRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsBySeriesResponse actualResponse_;
    submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
    response_.tableNames = actualResponse_.tableNames;
    response_.typeNames = actualResponse_.typeNames;
    response_.typeSchemas = actualResponse_.typeSchemas;
    response_.data.resize(actualResponse_.listRecordsBinary.size(), std::vector<boost::any>());

    for (std::vector<std::vector<std::vector<uint8_t> > >::size_type i_ = 0; i_ < actualResponse_.listRecordsBinary.size(); ++i_)
    {
        avro::DecoderPtr decoder_ = getDecoder(actualResponse_.typeNames[i_]);
        decoder_->resizeVector(response_.data[i_], actualResponse_.listRecordsBinary[i_].size());
        decoder_->decode(&response_.data[i_][0], &actualResponse_.listRecordsBinary[i_][0], actualResponse_.listRecordsBinary[i_].size(), this->threadCount, this->executor);
    }

    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RawGetRecordsFromCollectionResponse GPUdb::getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RawGetRecordsFromCollectionResponse& GPUdb::getRecordsFromCollectionRaw( const GetRecordsFromCollectionRequest& request_,
                                                                         RawGetRecordsFromCollectionResponse& response_ ) const
{
    submitRequest("/get/records/fromcollection", request_, response_, false);
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any> GPUdb::getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    GetRecordsFromCollectionResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->threadCount, this->executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->threadCount, this->executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const DeleteRecordsRequest&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any>& GPUdb::getRecordsFromCollection( const GetRecordsFromCollectionRequest& request_,
                                                                               GetRecordsFromCollectionResponse<boost::any>& response_ ) const
{
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", request_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->threadCount, this->executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->threadCount, this->executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options
 *                 <ul>
 *                         <li> return_record_ids: If 'true' then return
 *                 GPUdb's internal record id along with each returned record.
 *                 Default is 'false'. Values: 'true', 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any> GPUdb::getRecordsFromCollection( const std::string& tableName,
                                                                              const int64_t offset,
                                                                              const int64_t limit,
                                                                              const std::map<std::string, std::string>& options ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    GetRecordsFromCollectionResponse<boost::any> response_;
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->threadCount, this->executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->threadCount, this->executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as {@link
 * #deleteRecords(const std::string&,const std::vector<std::string>&,const std::map<std::string, std::string>&,DeleteRecordsResponse&) const}.
 * <p>
 * This operation supports paging through the data via the @a offset and @a
 * limit parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 * 
 * @param tableName  Name of the collection or table from which records are to
 *                   be retrieved. Must be an existing collection or table.
 * @param offset  A positive integer indicating the number of initial results
 *                to skip (this can be useful for paging through the results).
 *                Default value is 0. The minimum allowed value is 0. The
 *                maximum allowed value is MAX_INT.
 * @param limit  A positive integer indicating the maximum number of results to
 *               be returned, or END_OF_SET (-9999) to indicate that the max
 *               number of results should be returned.  Default value is 10000.
 * @param options
 *                 <ul>
 *                         <li> return_record_ids: If 'true' then return
 *                 GPUdb's internal record id along with each returned record.
 *                 Default is 'false'. Values: 'true', 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */
template<> 
GetRecordsFromCollectionResponse<boost::any>& GPUdb::getRecordsFromCollection( const std::string& tableName,
                                                                               const int64_t offset,
                                                                               const int64_t limit,
                                                                               const std::map<std::string, std::string>& options,
                                                                               GetRecordsFromCollectionResponse<boost::any>& response_ ) const
{
    GetRecordsFromCollectionRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.offset = offset;
    actualRequest_.limit = limit;
    actualRequest_.options = options;
    RawGetRecordsFromCollectionResponse actualResponse_;
    submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
    response_.tableName = actualResponse_.tableName;
    response_.typeNames = actualResponse_.typeNames;

    if (actualResponse_.recordsBinary.size() > 0)
    {
        response_.data.reserve(actualResponse_.recordsBinary.size());
        std::string& lastTypeId_ = actualResponse_.typeNames[0];
        size_t start_ = 0;

        for (std::vector<std::vector<uint8_t> >::size_type i_ = 1; i_ < actualResponse_.recordsBinary.size(); ++i_)
        {
            std::string& typeId_ = actualResponse_.typeNames[i_];

            if (typeId_ != lastTypeId_)
            {
                avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
                decoder_->resizeVector(response_.data, i_);
                decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], i_ - start_, this->threadCount, this->executor);
                lastTypeId_ = typeId_;
                start_ = i_;
            }
        }

        avro::DecoderPtr decoder_ = getDecoder(lastTypeId_);
        decoder_->resizeVector(response_.data, actualResponse_.recordsBinary.size());
        decoder_->decode(&response_.data[start_], &actualResponse_.recordsBinary[start_], actualResponse_.recordsBinary.size() - start_, this->threadCount, this->executor);
    }
    else
    {
        response_.data.clear();
    }

    response_.recordIds = actualResponse_.recordIds;
    return response_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionSystemResponse GPUdb::grantPermissionSystem( const GrantPermissionSystemRequest& request_ ) const
{
    GrantPermissionSystemResponse actualResponse_;
    submitRequest("/grant/permission/system", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionSystemResponse& GPUdb::grantPermissionSystem( const GrantPermissionSystemRequest& request_,
                                                             GrantPermissionSystemResponse& response_ ) const
{
    submitRequest("/grant/permission/system", request_, response_, false);
    return response_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role. Values:
 *                    'system_admin', 'system_write', 'system_read'.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionSystemResponse GPUdb::grantPermissionSystem( const std::string& name,
                                                            const std::string& permission,
                                                            const std::map<std::string, std::string>& options ) const
{
    GrantPermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    GrantPermissionSystemResponse actualResponse_;
    submitRequest("/grant/permission/system", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a system-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role. Values:
 *                    'system_admin', 'system_write', 'system_read'.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionSystemResponse& GPUdb::grantPermissionSystem( const std::string& name,
                                                             const std::string& permission,
                                                             const std::map<std::string, std::string>& options,
                                                             GrantPermissionSystemResponse& response_ ) const
{
    GrantPermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    submitRequest("/grant/permission/system", actualRequest_, response_, false);
    return response_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionTableResponse GPUdb::grantPermissionTable( const GrantPermissionTableRequest& request_ ) const
{
    GrantPermissionTableResponse actualResponse_;
    submitRequest("/grant/permission/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionTableResponse& GPUdb::grantPermissionTable( const GrantPermissionTableRequest& request_,
                                                           GrantPermissionTableResponse& response_ ) const
{
    submitRequest("/grant/permission/table", request_, response_, false);
    return response_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role. Values:
 *                    'table_admin', 'table_insert', 'table_update',
 *                    'table_delete', 'table_read'.
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view. If a
 *                   collection, the permission also applies to tables and
 *                   views in the collection.
 * @param filterExpression  Reserved for future use.  Default value is an empty
 *                          string.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantPermissionTableResponse GPUdb::grantPermissionTable( const std::string& name,
                                                          const std::string& permission,
                                                          const std::string& tableName,
                                                          const std::string& filterExpression,
                                                          const std::map<std::string, std::string>& options ) const
{
    GrantPermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.filterExpression = filterExpression;
    actualRequest_.options = options;
    GrantPermissionTableResponse actualResponse_;
    submitRequest("/grant/permission/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants a table-level permission to a user or role.
 * 
 * @param name  Name of the user or role to which the permission will be
 *              granted. Must be an existing user or role.
 * @param permission  Permission to grant to the user or role. Values:
 *                    'table_admin', 'table_insert', 'table_update',
 *                    'table_delete', 'table_read'.
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view. If a
 *                   collection, the permission also applies to tables and
 *                   views in the collection.
 * @param filterExpression  Reserved for future use.  Default value is an empty
 *                          string.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantPermissionTableResponse& GPUdb::grantPermissionTable( const std::string& name,
                                                           const std::string& permission,
                                                           const std::string& tableName,
                                                           const std::string& filterExpression,
                                                           const std::map<std::string, std::string>& options,
                                                           GrantPermissionTableResponse& response_ ) const
{
    GrantPermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.filterExpression = filterExpression;
    actualRequest_.options = options;
    submitRequest("/grant/permission/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantRoleResponse GPUdb::grantRole( const GrantRoleRequest& request_ ) const
{
    GrantRoleResponse actualResponse_;
    submitRequest("/grant/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantRoleResponse& GPUdb::grantRole( const GrantRoleRequest& request_,
                                     GrantRoleResponse& response_ ) const
{
    submitRequest("/grant/role", request_, response_, false);
    return response_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param role  Name of the role in which membership will be granted. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be granted membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

GrantRoleResponse GPUdb::grantRole( const std::string& role,
                                    const std::string& member,
                                    const std::map<std::string, std::string>& options ) const
{
    GrantRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    GrantRoleResponse actualResponse_;
    submitRequest("/grant/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Grants membership in a role to a user or role.
 * 
 * @param role  Name of the role in which membership will be granted. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be granted membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

GrantRoleResponse& GPUdb::grantRole( const std::string& role,
                                     const std::string& member,
                                     const std::map<std::string, std::string>& options,
                                     GrantRoleResponse& response_ ) const
{
    GrantRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    submitRequest("/grant/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasProcResponse GPUdb::hasProc( const HasProcRequest& request_ ) const
{
    HasProcResponse actualResponse_;
    submitRequest("/has/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasProcResponse& GPUdb::hasProc( const HasProcRequest& request_,
                                 HasProcResponse& response_ ) const
{
    submitRequest("/has/proc", request_, response_, false);
    return response_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param procName  Name of the proc to check for existence.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasProcResponse GPUdb::hasProc( const std::string& procName,
                                const std::map<std::string, std::string>& options ) const
{
    HasProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    HasProcResponse actualResponse_;
    submitRequest("/has/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks the existence of a proc with the given name.
 * 
 * @param procName  Name of the proc to check for existence.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasProcResponse& GPUdb::hasProc( const std::string& procName,
                                 const std::map<std::string, std::string>& options,
                                 HasProcResponse& response_ ) const
{
    HasProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/has/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse GPUdb::hasTable( const HasTableRequest& request_ ) const
{
    HasTableResponse actualResponse_;
    submitRequest("/has/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& GPUdb::hasTable( const HasTableRequest& request_,
                                   HasTableResponse& response_ ) const
{
    submitRequest("/has/table", request_, response_, false);
    return response_;
}


/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param tableName  Name of the table to check for existence.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTableResponse GPUdb::hasTable( const std::string& tableName,
                                  const std::map<std::string, std::string>& options ) const
{
    HasTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    HasTableResponse actualResponse_;
    submitRequest("/has/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Checks the existence of a table with the given name in GPUdb.
 * 
 * @param tableName  Name of the table to check for existence.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTableResponse& GPUdb::hasTable( const std::string& tableName,
                                   const std::map<std::string, std::string>& options,
                                   HasTableResponse& response_ ) const
{
    HasTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/has/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Check the existence of a type in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse GPUdb::hasType( const HasTypeRequest& request_ ) const
{
    HasTypeResponse actualResponse_;
    submitRequest("/has/type", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Check the existence of a type in GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& GPUdb::hasType( const HasTypeRequest& request_,
                                 HasTypeResponse& response_ ) const
{
    submitRequest("/has/type", request_, response_, false);
    return response_;
}


/**
 * Check the existence of a type in GPUdb.
 * 
 * @param typeId  Id of the type returned by GPUdb in response to /create/type
 *                request.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

HasTypeResponse GPUdb::hasType( const std::string& typeId,
                                const std::map<std::string, std::string>& options ) const
{
    HasTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    HasTypeResponse actualResponse_;
    submitRequest("/has/type", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Check the existence of a type in GPUdb.
 * 
 * @param typeId  Id of the type returned by GPUdb in response to /create/type
 *                request.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

HasTypeResponse& GPUdb::hasType( const std::string& typeId,
                                 const std::map<std::string, std::string>& options,
                                 HasTypeResponse& response_ ) const
{
    HasTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.options = options;
    submitRequest("/has/type", actualRequest_, response_, false);
    return response_;
}


/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides the counts of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's behavior.
 * The @a update_on_existing_pk option specifies the primary-key collision
 * policy.  If the table has a {@link
 * #createType(const CreateTypeRequest&) const primary key} and if @a
 * update_on_existing_pk is @a true, then if any of the records being added
 * have the same primary key as existing records, the existing records are
 * replaced (i.e. updated) with the given records.  If @a update_on_existing_pk
 * is @a false and if the records being added have the same primary key as
 * existing records, they are ignored (the existing records are left
 * unchanged).  It is quite possible that in this case some of the given
 * records will be inserted and some (those having existing primary keys) will
 * be ignored (or updated).  If the specified table does not have a primary key
 * column, then the @a update_on_existing_pk option is ignored.
 * <p>
 * The @a return_record_ids option indicates that the database should return
 * the unique identifiers of inserted records.
 * <p>
 * The @a route_to_address option directs that inserted records should be
 * targeted for a particular database node.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsResponse GPUdb::insertRecordsRaw( const RawInsertRecordsRequest& request_ ) const
{
    InsertRecordsResponse actualResponse_;
    submitRequest("/insert/records", request_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides the counts of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The @a options parameter can be used to customize this function's behavior.
 * The @a update_on_existing_pk option specifies the primary-key collision
 * policy.  If the table has a {@link
 * #createType(const CreateTypeRequest&,CreateTypeResponse&) const primary
 * key} and if @a update_on_existing_pk is @a true, then if any of the records
 * being added have the same primary key as existing records, the existing
 * records are replaced (i.e. updated) with the given records.  If @a
 * update_on_existing_pk is @a false and if the records being added have the
 * same primary key as existing records, they are ignored (the existing records
 * are left unchanged).  It is quite possible that in this case some of the
 * given records will be inserted and some (those having existing primary keys)
 * will be ignored (or updated).  If the specified table does not have a
 * primary key column, then the @a update_on_existing_pk option is ignored.
 * <p>
 * The @a return_record_ids option indicates that the database should return
 * the unique identifiers of inserted records.
 * <p>
 * The @a route_to_address option directs that inserted records should be
 * targeted for a particular database node.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsResponse& GPUdb::insertRecordsRaw( const RawInsertRecordsRequest& request_,
                                                InsertRecordsResponse& response_ ) const
{
    submitRequest("/insert/records", request_, response_, true);
    return response_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse GPUdb::insertRecordsRandom( const InsertRecordsRandomRequest& request_ ) const
{
    InsertRecordsRandomResponse actualResponse_;
    submitRequest("/insert/records/random", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& GPUdb::insertRecordsRandom( const InsertRecordsRandomRequest& request_,
                                                         InsertRecordsRandomResponse& response_ ) const
{
    submitRequest("/insert/records/random", request_, response_, false);
    return response_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param tableName  Table to which random records will be added. Must be an
 *                   existing table.  Also, must be an individual table, not a
 *                   collection of tables, nor a view of a table.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  The parameters that can be
 *                 specified are: *min*, *max*, and *interval*.  These
 *                 parameters take on different meanings depending on the type
 *                 of the column.  Below follows a more detailed description of
 *                 the map:
 *                 <ul>
 *                         <li> all: This key indicates that the specifications
 *                 relayed in the internal map are to be applied to all columns
 *                 of the records.
 *                 <ul>
 *                         <li> min: For numerical columns, the minimum of the
 *                 generated values is set to this value.  Default is -99999.
 *                 For point, shape, and track semantic types, min for numeric
 *                 'x' and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are -180.0 and -90.0. For the
 *                 'TIMESTAMP' column, the default minimum corresponds to Jan
 *                 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 1). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [1, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> max: For numerical columns, the maximum of the
 *                 generated values is set to this value. Default is 99999. For
 *                 point, shape, and track semantic types, max for numeric 'x'
 *                 and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [1, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> interval: If specified, then generate values
 *                 for all columns linearly and evenly spaced with the given
 *                 interval value starting at the minimum value (instead of
 *                 generating random data). *Any provided max value is
 *                 disregarded.*  For string-type columns, the interval value
 *                 is ignored but the string values would be generated
 *                 following the pattern: 'attrname_creationIndex#', i.e. the
 *                 column name suffixed with an underscore and a running
 *                 counter (starting at 0).
 *                 </ul>
 *                         <li> attr_name: Set the following parameters for the
 *                 column specified by the key. This overrides any parameter
 *                 set by @a all.
 *                 <ul>
 *                         <li> min: For numerical columns, the minimum of the
 *                 generated values is set to this value.  Default is -99999.
 *                 For point, shape, and track semantic types, min for numeric
 *                 'x' and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are -180.0 and -90.0. For the
 *                 'TIMESTAMP' column, the default minimum corresponds to Jan
 *                 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 1). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [1, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> max: For numerical columns, the maximum of the
 *                 generated values is set to this value. Default is 99999. For
 *                 point, shape, and track semantic types, max for numeric 'x'
 *                 and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [1, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> interval: If specified, then generate values
 *                 for all columns linearly and evenly spaced with the given
 *                 interval value starting at the minimum value (instead of
 *                 generating random data). *Any provided max value is
 *                 disregarded.*  For string-type columns, the interval value
 *                 is ignored but the string values would be generated
 *                 following the pattern: 'attrname_creationIndex#', i.e. the
 *                 column name suffixed with an underscore and a running
 *                 counter (starting at 0).
 *                 </ul>
 *                         <li> track_length: This key-map pair is only valid
 *                 for track type data sets (GPUdb throws an error otherwise).
 *                 <ul>
 *                         <li> min: Minimum possible length for generated
 *                 series; default is 100 records per series. Must be an
 *                 integral value within the range [1, 500]. If both min and
 *                 max are specified, min must be less than or equal to max.
 *                         <li> max: Maximum possible length for generated
 *                 series; default is 500 records per series. Must be an
 *                 integral value within the range [1, 500]. If both min and
 *                 max are specified, max must be greater than or equal to min.
 *                 </ul>
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertRecordsRandomResponse GPUdb::insertRecordsRandom( const std::string& tableName,
                                                        const int64_t count,
                                                        const std::map<std::string, std::map<std::string, double> >& options ) const
{
    InsertRecordsRandomRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.count = count;
    actualRequest_.options = options;
    InsertRecordsRandomResponse actualResponse_;
    submitRequest("/insert/records/random", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 * 
 * @param tableName  Table to which random records will be added. Must be an
 *                   existing table.  Also, must be an individual table, not a
 *                   collection of tables, nor a view of a table.
 * @param count  Number of records to generate.
 * @param options  Optional parameter to pass in specifications for the
 *                 randomness of the values.  This map is different from the
 *                 *options* parameter of most other endpoints in that it is a
 *                 map of string to map of string to doubles, while most others
 *                 are maps of string to string.  In this map, the top level
 *                 keys represent which column's parameters are being
 *                 specified, while the internal keys represents which
 *                 parameter is being specified.  The parameters that can be
 *                 specified are: *min*, *max*, and *interval*.  These
 *                 parameters take on different meanings depending on the type
 *                 of the column.  Below follows a more detailed description of
 *                 the map:
 *                 <ul>
 *                         <li> all: This key indicates that the specifications
 *                 relayed in the internal map are to be applied to all columns
 *                 of the records.
 *                 <ul>
 *                         <li> min: For numerical columns, the minimum of the
 *                 generated values is set to this value.  Default is -99999.
 *                 For point, shape, and track semantic types, min for numeric
 *                 'x' and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are -180.0 and -90.0. For the
 *                 'TIMESTAMP' column, the default minimum corresponds to Jan
 *                 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 1). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [1, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> max: For numerical columns, the maximum of the
 *                 generated values is set to this value. Default is 99999. For
 *                 point, shape, and track semantic types, max for numeric 'x'
 *                 and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [1, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> interval: If specified, then generate values
 *                 for all columns linearly and evenly spaced with the given
 *                 interval value starting at the minimum value (instead of
 *                 generating random data). *Any provided max value is
 *                 disregarded.*  For string-type columns, the interval value
 *                 is ignored but the string values would be generated
 *                 following the pattern: 'attrname_creationIndex#', i.e. the
 *                 column name suffixed with an underscore and a running
 *                 counter (starting at 0).
 *                 </ul>
 *                         <li> attr_name: Set the following parameters for the
 *                 column specified by the key. This overrides any parameter
 *                 set by @a all.
 *                 <ul>
 *                         <li> min: For numerical columns, the minimum of the
 *                 generated values is set to this value.  Default is -99999.
 *                 For point, shape, and track semantic types, min for numeric
 *                 'x' and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are -180.0 and -90.0. For the
 *                 'TIMESTAMP' column, the default minimum corresponds to Jan
 *                 1, 2010.
 *                 For string columns, the minimum length of the randomly
 *                 generated strings is set to this value (default is 1). If
 *                 both minimum and maximum are provided, minimum must be less
 *                 than or equal to max. Value needs to be within [1, 200].
 *                 If the min is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> max: For numerical columns, the maximum of the
 *                 generated values is set to this value. Default is 99999. For
 *                 point, shape, and track semantic types, max for numeric 'x'
 *                 and 'y' columns needs to be within [-180, 180] and [-90,
 *                 90], respectively. The default minimum possible values for
 *                 these columns in such cases are 180.0 and 90.0.
 *                 For string columns, the maximum length of the randomly
 *                 generated strings is set to this value (default is 200). If
 *                 both minimum and maximum are provided, *max* must be greater
 *                 than or equal to *min*. Value needs to be within [1, 200].
 *                 If the *max* is outside the accepted ranges for strings
 *                 columns and 'x' and 'y' columns for point/shape/track types,
 *                 then those parameters will not be set; however, GPUdb will
 *                 not throw an error in such a case. It is the responsibility
 *                 of the user to use the @a all parameter judiciously.
 *                         <li> interval: If specified, then generate values
 *                 for all columns linearly and evenly spaced with the given
 *                 interval value starting at the minimum value (instead of
 *                 generating random data). *Any provided max value is
 *                 disregarded.*  For string-type columns, the interval value
 *                 is ignored but the string values would be generated
 *                 following the pattern: 'attrname_creationIndex#', i.e. the
 *                 column name suffixed with an underscore and a running
 *                 counter (starting at 0).
 *                 </ul>
 *                         <li> track_length: This key-map pair is only valid
 *                 for track type data sets (GPUdb throws an error otherwise).
 *                 <ul>
 *                         <li> min: Minimum possible length for generated
 *                 series; default is 100 records per series. Must be an
 *                 integral value within the range [1, 500]. If both min and
 *                 max are specified, min must be less than or equal to max.
 *                         <li> max: Maximum possible length for generated
 *                 series; default is 500 records per series. Must be an
 *                 integral value within the range [1, 500]. If both min and
 *                 max are specified, max must be greater than or equal to min.
 *                 </ul>
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertRecordsRandomResponse& GPUdb::insertRecordsRandom( const std::string& tableName,
                                                         const int64_t count,
                                                         const std::map<std::string, std::map<std::string, double> >& options,
                                                         InsertRecordsRandomResponse& response_ ) const
{
    InsertRecordsRandomRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.count = count;
    actualRequest_.options = options;
    submitRequest("/insert/records/random", actualRequest_, response_, false);
    return response_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const VisualizeImageRequest&) const}) if the
 * 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse GPUdb::insertSymbol( const InsertSymbolRequest& request_ ) const
{
    InsertSymbolResponse actualResponse_;
    submitRequest("/insert/symbol", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const VisualizeImageRequest&,VisualizeImageResponse&) const})
 * if the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& GPUdb::insertSymbol( const InsertSymbolRequest& request_,
                                           InsertSymbolResponse& response_ ) const
{
    submitRequest("/insert/symbol", request_, response_, false);
    return response_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const std::vector<std::string>&,const std::vector<std::string>&,const std::string&,const std::string&,const std::vector<std::vector<std::string> >&,const double,const double,const double,const double,const int32_t,const int32_t,const std::string&,const int64_t,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&) const})
 * if the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'. Values: 'svg', 'svg_path'.
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> color: If @a symbolFormat is 'svg' this is
 *                 ignored. If @a symbolFormat is 'svg_path' then this option
 *                 specifies the color (in RRGGBB hex format) of the path. For
 *                 example, to have the path rendered in red, used 'FF0000'. If
 *                 'color' is not provided then '00FF00' (i.e. green) is used
 *                 by default.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

InsertSymbolResponse GPUdb::insertSymbol( const std::string& symbolId,
                                          const std::string& symbolFormat,
                                          const std::vector<uint8_t>& symbolData,
                                          const std::map<std::string, std::string>& options ) const
{
    InsertSymbolRequest actualRequest_;
    actualRequest_.symbolId = symbolId;
    actualRequest_.symbolFormat = symbolFormat;
    actualRequest_.symbolData = symbolData;
    actualRequest_.options = options;
    InsertSymbolResponse actualResponse_;
    submitRequest("/insert/symbol", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or {@link
 * #visualizeImage(const std::vector<std::string>&,const std::vector<std::string>&,const std::string&,const std::string&,const std::vector<std::vector<std::string> >&,const double,const double,const double,const double,const int32_t,const int32_t,const std::string&,const int64_t,const std::map<std::string, std::vector<std::string> >&,const std::map<std::string, std::string>&,VisualizeImageResponse&) const})
 * if the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 * 
 * @param symbolId  The id of the symbol being added. This is the same id that
 *                  should be in the 'SYMBOLCODE' column for objects using this
 *                  symbol
 * @param symbolFormat  Specifies the symbol format. Must be either 'svg' or
 *                      'svg_path'. Values: 'svg', 'svg_path'.
 * @param symbolData  The actual symbol data. If @a symbolFormat is 'svg' then
 *                    this should be the raw bytes representing an svg file. If
 *                    @a symbolFormat is svg path then this should be an svg
 *                    path string, for example:
 *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> color: If @a symbolFormat is 'svg' this is
 *                 ignored. If @a symbolFormat is 'svg_path' then this option
 *                 specifies the color (in RRGGBB hex format) of the path. For
 *                 example, to have the path rendered in red, used 'FF0000'. If
 *                 'color' is not provided then '00FF00' (i.e. green) is used
 *                 by default.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

InsertSymbolResponse& GPUdb::insertSymbol( const std::string& symbolId,
                                           const std::string& symbolFormat,
                                           const std::vector<uint8_t>& symbolData,
                                           const std::map<std::string, std::string>& options,
                                           InsertSymbolResponse& response_ ) const
{
    InsertSymbolRequest actualRequest_;
    actualRequest_.symbolId = symbolId;
    actualRequest_.symbolFormat = symbolFormat;
    actualRequest_.symbolData = symbolData;
    actualRequest_.options = options;
    submitRequest("/insert/symbol", actualRequest_, response_, false);
    return response_;
}


/**
 * Kills a running proc instance.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

KillProcResponse GPUdb::killProc( const KillProcRequest& request_ ) const
{
    KillProcResponse actualResponse_;
    submitRequest("/kill/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Kills a running proc instance.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

KillProcResponse& GPUdb::killProc( const KillProcRequest& request_,
                                   KillProcResponse& response_ ) const
{
    submitRequest("/kill/proc", request_, response_, false);
    return response_;
}


/**
 * Kills a running proc instance.
 * 
 * @param runId  The run ID of the running proc instance. If the run ID is not
 *               found or the proc instance has already completed, this does
 *               nothing. If not specified, all running proc instances will be
 *               killed.  Default value is an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

KillProcResponse GPUdb::killProc( const std::string& runId,
                                  const std::map<std::string, std::string>& options ) const
{
    KillProcRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    KillProcResponse actualResponse_;
    submitRequest("/kill/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Kills a running proc instance.
 * 
 * @param runId  The run ID of the running proc instance. If the run ID is not
 *               found or the proc instance has already completed, this does
 *               nothing. If not specified, all running proc instances will be
 *               killed.  Default value is an empty string.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

KillProcResponse& GPUdb::killProc( const std::string& runId,
                                   const std::map<std::string, std::string>& options,
                                   KillProcResponse& response_ ) const
{
    KillProcRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    submitRequest("/kill/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a unlock, indicating all operations are permitted.  A user may
 * request a @a read-only or a @a write-only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a disable then no operations are permitted on
 * the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse GPUdb::lockTable( const LockTableRequest& request_ ) const
{
    LockTableResponse actualResponse_;
    submitRequest("/lock/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a unlock, indicating all operations are permitted.  A user may
 * request a @a read-only or a @a write-only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a disable then no operations are permitted on
 * the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& GPUdb::lockTable( const LockTableRequest& request_,
                                     LockTableResponse& response_ ) const
{
    submitRequest("/lock/table", request_, response_, false);
    return response_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a unlock, indicating all operations are permitted.  A user may
 * request a @a read-only or a @a write-only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a disable then no operations are permitted on
 * the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param tableName  Name of the table to be locked. It must be a currently
 *                   existing table, collection, or view.
 * @param lockType  The type of lock being applied to the table. Setting it to
 *                  @a status will return the current lock status of the table
 *                  without changing it. Values: 'status', 'disable',
 *                  'read-only', 'write-only', 'unlock'.
 *                    Default value is 'status'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

LockTableResponse GPUdb::lockTable( const std::string& tableName,
                                    const std::string& lockType,
                                    const std::map<std::string, std::string>& options ) const
{
    LockTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.lockType = lockType;
    actualRequest_.options = options;
    LockTableResponse actualResponse_;
    submitRequest("/lock/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Manages global access to a table's data.  By default a table has a @a
 * lockType of @a unlock, indicating all operations are permitted.  A user may
 * request a @a read-only or a @a write-only lock, after which only read or
 * write operations, respectively, are permitted on the table until the lock is
 * removed.  When @a lockType is @a disable then no operations are permitted on
 * the table.  The lock status can be queried by setting @a lockType to @a
 * status.
 * 
 * @param tableName  Name of the table to be locked. It must be a currently
 *                   existing table, collection, or view.
 * @param lockType  The type of lock being applied to the table. Setting it to
 *                  @a status will return the current lock status of the table
 *                  without changing it. Values: 'status', 'disable',
 *                  'read-only', 'write-only', 'unlock'.
 *                    Default value is 'status'.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

LockTableResponse& GPUdb::lockTable( const std::string& tableName,
                                     const std::string& lockType,
                                     const std::map<std::string, std::string>& options,
                                     LockTableResponse& response_ ) const
{
    LockTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.lockType = lockType;
    actualRequest_.options = options;
    submitRequest("/lock/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionSystemResponse GPUdb::revokePermissionSystem( const RevokePermissionSystemRequest& request_ ) const
{
    RevokePermissionSystemResponse actualResponse_;
    submitRequest("/revoke/permission/system", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionSystemResponse& GPUdb::revokePermissionSystem( const RevokePermissionSystemRequest& request_,
                                                               RevokePermissionSystemResponse& response_ ) const
{
    submitRequest("/revoke/permission/system", request_, response_, false);
    return response_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role. Values:
 *                    'system_admin', 'system_write', 'system_read'.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionSystemResponse GPUdb::revokePermissionSystem( const std::string& name,
                                                              const std::string& permission,
                                                              const std::map<std::string, std::string>& options ) const
{
    RevokePermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    RevokePermissionSystemResponse actualResponse_;
    submitRequest("/revoke/permission/system", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a system-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role. Values:
 *                    'system_admin', 'system_write', 'system_read'.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionSystemResponse& GPUdb::revokePermissionSystem( const std::string& name,
                                                               const std::string& permission,
                                                               const std::map<std::string, std::string>& options,
                                                               RevokePermissionSystemResponse& response_ ) const
{
    RevokePermissionSystemRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.options = options;
    submitRequest("/revoke/permission/system", actualRequest_, response_, false);
    return response_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionTableResponse GPUdb::revokePermissionTable( const RevokePermissionTableRequest& request_ ) const
{
    RevokePermissionTableResponse actualResponse_;
    submitRequest("/revoke/permission/table", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionTableResponse& GPUdb::revokePermissionTable( const RevokePermissionTableRequest& request_,
                                                             RevokePermissionTableResponse& response_ ) const
{
    submitRequest("/revoke/permission/table", request_, response_, false);
    return response_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role. Values:
 *                    'table_admin', 'table_insert', 'table_update',
 *                    'table_delete', 'table_read'.
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokePermissionTableResponse GPUdb::revokePermissionTable( const std::string& name,
                                                            const std::string& permission,
                                                            const std::string& tableName,
                                                            const std::map<std::string, std::string>& options ) const
{
    RevokePermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    RevokePermissionTableResponse actualResponse_;
    submitRequest("/revoke/permission/table", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes a table-level permission from a user or role.
 * 
 * @param name  Name of the user or role from which the permission will be
 *              revoked. Must be an existing user or role.
 * @param permission  Permission to revoke from the user or role. Values:
 *                    'table_admin', 'table_insert', 'table_update',
 *                    'table_delete', 'table_read'.
 * @param tableName  Name of the table to which the permission grants access.
 *                   Must be an existing table, collection, or view.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokePermissionTableResponse& GPUdb::revokePermissionTable( const std::string& name,
                                                             const std::string& permission,
                                                             const std::string& tableName,
                                                             const std::map<std::string, std::string>& options,
                                                             RevokePermissionTableResponse& response_ ) const
{
    RevokePermissionTableRequest actualRequest_;
    actualRequest_.name = name;
    actualRequest_.permission = permission;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/revoke/permission/table", actualRequest_, response_, false);
    return response_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokeRoleResponse GPUdb::revokeRole( const RevokeRoleRequest& request_ ) const
{
    RevokeRoleResponse actualResponse_;
    submitRequest("/revoke/role", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokeRoleResponse& GPUdb::revokeRole( const RevokeRoleRequest& request_,
                                       RevokeRoleResponse& response_ ) const
{
    submitRequest("/revoke/role", request_, response_, false);
    return response_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param role  Name of the role in which membership will be revoked. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be revoked membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

RevokeRoleResponse GPUdb::revokeRole( const std::string& role,
                                      const std::string& member,
                                      const std::map<std::string, std::string>& options ) const
{
    RevokeRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    RevokeRoleResponse actualResponse_;
    submitRequest("/revoke/role", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Revokes membership in a role from a user or role.
 * 
 * @param role  Name of the role in which membership will be revoked. Must be
 *              an existing role.
 * @param member  Name of the user or role that will be revoked membership in
 *                @a role. Must be an existing user or role.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

RevokeRoleResponse& GPUdb::revokeRole( const std::string& role,
                                       const std::string& member,
                                       const std::map<std::string, std::string>& options,
                                       RevokeRoleResponse& response_ ) const
{
    RevokeRoleRequest actualRequest_;
    actualRequest_.role = role;
    actualRequest_.member = member;
    actualRequest_.options = options;
    submitRequest("/revoke/role", actualRequest_, response_, false);
    return response_;
}


/**
 * Shows information about a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcResponse GPUdb::showProc( const ShowProcRequest& request_ ) const
{
    ShowProcResponse actualResponse_;
    submitRequest("/show/proc", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows information about a proc.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcResponse& GPUdb::showProc( const ShowProcRequest& request_,
                                   ShowProcResponse& response_ ) const
{
    submitRequest("/show/proc", request_, response_, false);
    return response_;
}


/**
 * Shows information about a proc.
 * 
 * @param procName  Name of the proc to show information about. If specified,
 *                  must be the name of a currently existing proc. If not
 *                  specified, information about all procs will be returned.
 *                  Default value is an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> include_files: If set to @a true, the files
 *                 that make up the proc will be returned. If set to @a false,
 *                 the files will not be returned. Values: 'true', 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcResponse GPUdb::showProc( const std::string& procName,
                                  const std::map<std::string, std::string>& options ) const
{
    ShowProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    ShowProcResponse actualResponse_;
    submitRequest("/show/proc", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows information about a proc.
 * 
 * @param procName  Name of the proc to show information about. If specified,
 *                  must be the name of a currently existing proc. If not
 *                  specified, information about all procs will be returned.
 *                  Default value is an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> include_files: If set to @a true, the files
 *                 that make up the proc will be returned. If set to @a false,
 *                 the files will not be returned. Values: 'true', 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcResponse& GPUdb::showProc( const std::string& procName,
                                   const std::map<std::string, std::string>& options,
                                   ShowProcResponse& response_ ) const
{
    ShowProcRequest actualRequest_;
    actualRequest_.procName = procName;
    actualRequest_.options = options;
    submitRequest("/show/proc", actualRequest_, response_, false);
    return response_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const ExecuteProcRequest&) const}) and data segment ID
 * (each invocation of the proc command on a data segment is assigned a data
 * segment ID).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcStatusResponse GPUdb::showProcStatus( const ShowProcStatusRequest& request_ ) const
{
    ShowProcStatusResponse actualResponse_;
    submitRequest("/show/proc/status", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const ExecuteProcRequest&,ExecuteProcResponse&) const}) and
 * data segment ID (each invocation of the proc command on a data segment is
 * assigned a data segment ID).
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcStatusResponse& GPUdb::showProcStatus( const ShowProcStatusRequest& request_,
                                               ShowProcStatusResponse& response_ ) const
{
    submitRequest("/show/proc/status", request_, response_, false);
    return response_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const std::string&,const std::map<std::string, std::string>&,const std::map<std::string, std::vector<uint8_t> >&,const std::vector<std::string>&,const std::map<std::string, std::vector<std::string> >&,const std::vector<std::string>&,const std::map<std::string, std::string>&) const})
 * and data segment ID (each invocation of the proc command on a data segment
 * is assigned a data segment ID).
 * 
 * @param runId  The run ID of a specific running or completed proc instance
 *               for which the status will be returned. If the run ID is not
 *               found, nothing will be returned. If not specified, the
 *               statuses of all running and completed proc instances will be
 *               returned.  Default value is an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> clear_complete: If set to @a true, if a proc
 *                 instance has completed (either successfully or
 *                 unsuccessfully) then its status will be cleared and no
 *                 longer returned in subsequent calls. Values: 'true',
 *                 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowProcStatusResponse GPUdb::showProcStatus( const std::string& runId,
                                              const std::map<std::string, std::string>& options ) const
{
    ShowProcStatusRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    ShowProcStatusResponse actualResponse_;
    submitRequest("/show/proc/status", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@link
 * #executeProc(const std::string&,const std::map<std::string, std::string>&,const std::map<std::string, std::vector<uint8_t> >&,const std::vector<std::string>&,const std::map<std::string, std::vector<std::string> >&,const std::vector<std::string>&,const std::map<std::string, std::string>&,ExecuteProcResponse&) const})
 * and data segment ID (each invocation of the proc command on a data segment
 * is assigned a data segment ID).
 * 
 * @param runId  The run ID of a specific running or completed proc instance
 *               for which the status will be returned. If the run ID is not
 *               found, nothing will be returned. If not specified, the
 *               statuses of all running and completed proc instances will be
 *               returned.  Default value is an empty string.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> clear_complete: If set to @a true, if a proc
 *                 instance has completed (either successfully or
 *                 unsuccessfully) then its status will be cleared and no
 *                 longer returned in subsequent calls. Values: 'true',
 *                 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowProcStatusResponse& GPUdb::showProcStatus( const std::string& runId,
                                               const std::map<std::string, std::string>& options,
                                               ShowProcStatusResponse& response_ ) const
{
    ShowProcStatusRequest actualRequest_;
    actualRequest_.runId = runId;
    actualRequest_.options = options;
    submitRequest("/show/proc/status", actualRequest_, response_, false);
    return response_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSecurityResponse GPUdb::showSecurity( const ShowSecurityRequest& request_ ) const
{
    ShowSecurityResponse actualResponse_;
    submitRequest("/show/security", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSecurityResponse& GPUdb::showSecurity( const ShowSecurityRequest& request_,
                                           ShowSecurityResponse& response_ ) const
{
    submitRequest("/show/security", request_, response_, false);
    return response_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param names  A list of names of users and/or roles about which security
 *               information is requested. If none are provided, information
 *               about all users and roles will be returned.
 * @param options  Optional parameters.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSecurityResponse GPUdb::showSecurity( const std::vector<std::string>& names,
                                          const std::map<std::string, std::string>& options ) const
{
    ShowSecurityRequest actualRequest_;
    actualRequest_.names = names;
    actualRequest_.options = options;
    ShowSecurityResponse actualResponse_;
    submitRequest("/show/security", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 * 
 * @param names  A list of names of users and/or roles about which security
 *               information is requested. If none are provided, information
 *               about all users and roles will be returned.
 * @param options  Optional parameters.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSecurityResponse& GPUdb::showSecurity( const std::vector<std::string>& names,
                                           const std::map<std::string, std::string>& options,
                                           ShowSecurityResponse& response_ ) const
{
    ShowSecurityRequest actualRequest_;
    actualRequest_.names = names;
    actualRequest_.options = options;
    submitRequest("/show/security", actualRequest_, response_, false);
    return response_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse GPUdb::showSystemProperties( const ShowSystemPropertiesRequest& request_ ) const
{
    ShowSystemPropertiesResponse actualResponse_;
    submitRequest("/show/system/properties", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& GPUdb::showSystemProperties( const ShowSystemPropertiesRequest& request_,
                                                           ShowSystemPropertiesResponse& response_ ) const
{
    submitRequest("/show/system/properties", request_, response_, false);
    return response_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> properties: A list of comma separated names of
 *                 properties requested. If not specified, all properties will
 *                 be returned.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemPropertiesResponse GPUdb::showSystemProperties( const std::map<std::string, std::string>& options ) const
{
    ShowSystemPropertiesRequest actualRequest_;
    actualRequest_.options = options;
    ShowSystemPropertiesResponse actualResponse_;
    submitRequest("/show/system/properties", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 * 
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> properties: A list of comma separated names of
 *                 properties requested. If not specified, all properties will
 *                 be returned.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemPropertiesResponse& GPUdb::showSystemProperties( const std::map<std::string, std::string>& options,
                                                           ShowSystemPropertiesResponse& response_ ) const
{
    ShowSystemPropertiesRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/show/system/properties", actualRequest_, response_, false);
    return response_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse GPUdb::showSystemStatus( const ShowSystemStatusRequest& request_ ) const
{
    ShowSystemStatusResponse actualResponse_;
    submitRequest("/show/system/status", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& GPUdb::showSystemStatus( const ShowSystemStatusRequest& request_,
                                                   ShowSystemStatusResponse& response_ ) const
{
    submitRequest("/show/system/status", request_, response_, false);
    return response_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemStatusResponse GPUdb::showSystemStatus( const std::map<std::string, std::string>& options ) const
{
    ShowSystemStatusRequest actualRequest_;
    actualRequest_.options = options;
    ShowSystemStatusResponse actualResponse_;
    submitRequest("/show/system/status", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemStatusResponse& GPUdb::showSystemStatus( const std::map<std::string, std::string>& options,
                                                   ShowSystemStatusResponse& response_ ) const
{
    ShowSystemStatusRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/show/system/status", actualRequest_, response_, false);
    return response_;
}


/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse GPUdb::showSystemTiming( const ShowSystemTimingRequest& request_ ) const
{
    ShowSystemTimingResponse actualResponse_;
    submitRequest("/show/system/timing", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& GPUdb::showSystemTiming( const ShowSystemTimingRequest& request_,
                                                   ShowSystemTimingResponse& response_ ) const
{
    submitRequest("/show/system/timing", request_, response_, false);
    return response_;
}


/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowSystemTimingResponse GPUdb::showSystemTiming( const std::map<std::string, std::string>& options ) const
{
    ShowSystemTimingRequest actualRequest_;
    actualRequest_.options = options;
    ShowSystemTimingResponse actualResponse_;
    submitRequest("/show/system/timing", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 * 
 * @param options  Optional parameters, currently unused.  Default value is an
 *                 empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowSystemTimingResponse& GPUdb::showSystemTiming( const std::map<std::string, std::string>& options,
                                                   ShowSystemTimingResponse& response_ ) const
{
    ShowSystemTimingRequest actualRequest_;
    actualRequest_.options = options;
    submitRequest("/show/system/timing", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their description, type id, schema, type label, type properties, and
 * additional information including TTL.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse GPUdb::showTable( const ShowTableRequest& request_ ) const
{
    ShowTableResponse actualResponse_;
    submitRequest("/show/table", request_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.typeLabels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their description, type id, schema, type label, type properties, and
 * additional information including TTL.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& GPUdb::showTable( const ShowTableRequest& request_,
                                     ShowTableResponse& response_ ) const
{
    submitRequest("/show/table", request_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.typeLabels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their description, type id, schema, type label, type properties, and
 * additional information including TTL.
 * 
 * @param tableName  Name of the table for which to retrieve the information.
 *                   If blank, then information about all collections and
 *                   top-level tables and views is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> get_sizes: If @a true then the table sizes will
 *                 be returned; blank, otherwise. Values: 'true', 'false'.
 *                         <li> show_children: If @a tableName is a collection,
 *                 then @a true will return information about the children of
 *                 the collection, and @a false will return information about
 *                 the collection itself. If @a tableName is a table or view,
 *                 @a show_children must be @a false. If @a tableName is empty,
 *                 then @a show_children must be @a true. Values: 'true',
 *                 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableResponse GPUdb::showTable( const std::string& tableName,
                                    const std::map<std::string, std::string>& options ) const
{
    ShowTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    ShowTableResponse actualResponse_;
    submitRequest("/show/table", actualRequest_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.typeLabels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves detailed information about a table, view, or collection, specified
 * in @a tableName. If the supplied @a tableName is a collection, the call can
 * return information about either the collection itself or the tables and
 * views it contains. If @a tableName is empty, information about all
 * collections and top-level tables and views can be returned.
 * <p>
 * If the option @a get_sizes is set to @a true, then the sizes (objects and
 * elements) of each table are returned (in @a sizes and @a fullSizes), along
 * with the total number of objects in the requested table (in @a totalSize and
 * @a totalFullSize).
 * <p>
 * For a collection, setting the @a show_children option to @a false returns
 * only information about the collection itself; setting @a show_children to @a
 * true returns a list of tables and views contained in the collection, along
 * with their description, type id, schema, type label, type properties, and
 * additional information including TTL.
 * 
 * @param tableName  Name of the table for which to retrieve the information.
 *                   If blank, then information about all collections and
 *                   top-level tables and views is returned.
 * @param options  Optional parameters.
 *                 <ul>
 *                         <li> get_sizes: If @a true then the table sizes will
 *                 be returned; blank, otherwise. Values: 'true', 'false'.
 *                         <li> show_children: If @a tableName is a collection,
 *                 then @a true will return information about the children of
 *                 the collection, and @a false will return information about
 *                 the collection itself. If @a tableName is a table or view,
 *                 @a show_children must be @a false. If @a tableName is empty,
 *                 then @a show_children must be @a true. Values: 'true',
 *                 'false'.
 *                 </ul>
 *                   Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableResponse& GPUdb::showTable( const std::string& tableName,
                                     const std::map<std::string, std::string>& options,
                                     ShowTableResponse& response_ ) const
{
    ShowTableRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.options = options;
    submitRequest("/show/table", actualRequest_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.typeLabels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse GPUdb::showTableMetadata( const ShowTableMetadataRequest& request_ ) const
{
    ShowTableMetadataResponse actualResponse_;
    submitRequest("/show/table/metadata", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& GPUdb::showTableMetadata( const ShowTableMetadataRequest& request_,
                                                     ShowTableMetadataResponse& response_ ) const
{
    submitRequest("/show/table/metadata", request_, response_, false);
    return response_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist in GPUdb, or GPUdb returns an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTableMetadataResponse GPUdb::showTableMetadata( const std::vector<std::string>& tableNames,
                                                    const std::map<std::string, std::string>& options ) const
{
    ShowTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    ShowTableMetadataResponse actualResponse_;
    submitRequest("/show/table/metadata", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves the user provided metadata for the specified tables.
 * 
 * @param tableNames  Tables whose metadata will be fetched. All provided
 *                    tables must exist in GPUdb, or GPUdb returns an error.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTableMetadataResponse& GPUdb::showTableMetadata( const std::vector<std::string>& tableNames,
                                                     const std::map<std::string, std::string>& options,
                                                     ShowTableMetadataResponse& response_ ) const
{
    ShowTableMetadataRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.options = options;
    submitRequest("/show/table/metadata", actualRequest_, response_, false);
    return response_;
}


/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse GPUdb::showTablesByType( const ShowTablesByTypeRequest& request_ ) const
{
    ShowTablesByTypeResponse actualResponse_;
    submitRequest("/show/tables/bytype", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& GPUdb::showTablesByType( const ShowTablesByTypeRequest& request_,
                                                   ShowTablesByTypeResponse& response_ ) const
{
    submitRequest("/show/tables/bytype", request_, response_, false);
    return response_;
}


/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTablesByTypeResponse GPUdb::showTablesByType( const std::string& typeId,
                                                  const std::string& label,
                                                  const std::map<std::string, std::string>& options ) const
{
    ShowTablesByTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    ShowTablesByTypeResponse actualResponse_;
    submitRequest("/show/tables/bytype", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 * 
 * @param typeId  Type id returned by a call to /create/type.
 * @param label  Optional user supplied label which can be used instead of the
 *               type_id to retrieve all tables with the given label.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTablesByTypeResponse& GPUdb::showTablesByType( const std::string& typeId,
                                                   const std::string& label,
                                                   const std::map<std::string, std::string>& options,
                                                   ShowTablesByTypeResponse& response_ ) const
{
    ShowTablesByTypeRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    submitRequest("/show/tables/bytype", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse GPUdb::showTriggers( const ShowTriggersRequest& request_ ) const
{
    ShowTriggersResponse actualResponse_;
    submitRequest("/show/triggers", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& GPUdb::showTriggers( const ShowTriggersRequest& request_,
                                           ShowTriggersResponse& response_ ) const
{
    submitRequest("/show/triggers", request_, response_, false);
    return response_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param triggerIds  List of IDs of the triggers whose information to be
 *                    retrieved. Empty list means retrieve information on all
 *                    active triggers.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTriggersResponse GPUdb::showTriggers( const std::vector<std::string>& triggerIds,
                                          const std::map<std::string, std::string>& options ) const
{
    ShowTriggersRequest actualRequest_;
    actualRequest_.triggerIds = triggerIds;
    actualRequest_.options = options;
    ShowTriggersResponse actualResponse_;
    submitRequest("/show/triggers", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 * 
 * @param triggerIds  List of IDs of the triggers whose information to be
 *                    retrieved. Empty list means retrieve information on all
 *                    active triggers.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTriggersResponse& GPUdb::showTriggers( const std::vector<std::string>& triggerIds,
                                           const std::map<std::string, std::string>& options,
                                           ShowTriggersResponse& response_ ) const
{
    ShowTriggersRequest actualRequest_;
    actualRequest_.triggerIds = triggerIds;
    actualRequest_.options = options;
    submitRequest("/show/triggers", actualRequest_, response_, false);
    return response_;
}


/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse GPUdb::showTypes( const ShowTypesRequest& request_ ) const
{
    ShowTypesResponse actualResponse_;
    submitRequest("/show/types", request_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.labels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& GPUdb::showTypes( const ShowTypesRequest& request_,
                                     ShowTypesResponse& response_ ) const
{
    submitRequest("/show/types", request_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.labels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

ShowTypesResponse GPUdb::showTypes( const std::string& typeId,
                                    const std::string& label,
                                    const std::map<std::string, std::string>& options ) const
{
    ShowTypesRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    ShowTypesResponse actualResponse_;
    submitRequest("/show/types", actualRequest_, actualResponse_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < actualResponse_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( actualResponse_.typeIds[i_],
                             actualResponse_.labels[i_],
                             actualResponse_.typeSchemas[i_],
                             actualResponse_.properties[i_] );
    }

    return actualResponse_;
}


/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 * 
 * @param typeId  Type Id returned in response to a call to /create/type.
 * @param label  Option string that was supplied by user in a call to
 *               /create/type.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

ShowTypesResponse& GPUdb::showTypes( const std::string& typeId,
                                     const std::string& label,
                                     const std::map<std::string, std::string>& options,
                                     ShowTypesResponse& response_ ) const
{
    ShowTypesRequest actualRequest_;
    actualRequest_.typeId = typeId;
    actualRequest_.label = label;
    actualRequest_.options = options;
    submitRequest("/show/types", actualRequest_, response_, false);

    std::vector<std::string>::size_type i_;
    for ( i_ = 0; i_ < response_.typeIds.size(); ++i_)
    {
        setDecoderIfMissing( response_.typeIds[i_],
                             response_.labels[i_],
                             response_.typeSchemas[i_],
                             response_.properties[i_] );
    }

    return response_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsResponse GPUdb::updateRecordsRaw( const RawUpdateRecordsRequest& request_ ) const
{
    UpdateRecordsResponse actualResponse_;
    submitRequest("/update/records", request_, actualResponse_, true);
    return actualResponse_;
}


/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in @a newValuesMaps.  There is also an optional 'upsert' capability
 * where if a particular predicate doesn't match any existing record, then a
 * new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through @a options.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsResponse& GPUdb::updateRecordsRaw( const RawUpdateRecordsRequest& request_,
                                                UpdateRecordsResponse& response_ ) const
{
    submitRequest("/update/records", request_, response_, true);
    return response_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse GPUdb::updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_ ) const
{
    UpdateRecordsBySeriesResponse actualResponse_;
    submitRequest("/update/records/byseries", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& GPUdb::updateRecordsBySeries( const UpdateRecordsBySeriesRequest& request_,
                                                             UpdateRecordsBySeriesResponse& response_ ) const
{
    submitRequest("/update/records/byseries", request_, response_, false);
    return response_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed. Must be a valid view in GPUdb.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information.
 * @param viewName  Optional name of the view containing the series (tracks)
 *                  which have to be updated.  Default value is an empty
 *                  string.
 * @param reserved  Default value is an empty std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

UpdateRecordsBySeriesResponse GPUdb::updateRecordsBySeries( const std::string& tableName,
                                                            const std::string& worldTableName,
                                                            const std::string& viewName,
                                                            const std::vector<std::string>& reserved,
                                                            const std::map<std::string, std::string>& options ) const
{
    UpdateRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.viewName = viewName;
    actualRequest_.reserved = reserved;
    actualRequest_.options = options;
    UpdateRecordsBySeriesResponse actualResponse_;
    submitRequest("/update/records/byseries", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Updates the view specified by @a tableName to include full series (track)
 * information from the @a worldTableName for the series (tracks) present in
 * the @a viewName.
 * 
 * @param tableName  Name of the view on which the update operation will be
 *                   performed. Must be a valid view in GPUdb.
 * @param worldTableName  Name of the table containing the complete series
 *                        (track) information.
 * @param viewName  Optional name of the view containing the series (tracks)
 *                  which have to be updated.  Default value is an empty
 *                  string.
 * @param reserved  Default value is an empty std::vector.
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

UpdateRecordsBySeriesResponse& GPUdb::updateRecordsBySeries( const std::string& tableName,
                                                             const std::string& worldTableName,
                                                             const std::string& viewName,
                                                             const std::vector<std::string>& reserved,
                                                             const std::map<std::string, std::string>& options,
                                                             UpdateRecordsBySeriesResponse& response_ ) const
{
    UpdateRecordsBySeriesRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.worldTableName = worldTableName;
    actualRequest_.viewName = viewName;
    actualRequest_.reserved = reserved;
    actualRequest_.options = options;
    submitRequest("/update/records/byseries", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse GPUdb::visualizeImage( const VisualizeImageRequest& request_ ) const
{
    VisualizeImageResponse actualResponse_;
    submitRequest("/visualize/image", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& GPUdb::visualizeImage( const VisualizeImageRequest& request_,
                                               VisualizeImageResponse& response_ ) const
{
    submitRequest("/visualize/image", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param trackIds
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> do_points: Values: 'true', 'false'.
 *                              <li> do_shapes: Values: 'true', 'false'.
 *                              <li> do_tracks: Values: 'true', 'false'.
 *                              <li> do_symbology: Values: 'true', 'false'.
 *                              <li> pointcolors:
 *                              <li> pointsizes:
 *                              <li> pointshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> shapelinewidths:
 *                              <li> shapelinecolors:
 *                              <li> shapefillcolors:
 *                              <li> tracklinewidths:
 *                              <li> tracklinecolors:
 *                              <li> trackmarkersizes:
 *                              <li> trackmarkercolors:
 *                              <li> trackmarkershapes: Values: 'none',
 *                      'circle', 'square', 'diamond', 'hollowcircle',
 *                      'hollowsquare', 'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> trackheadcolors:
 *                              <li> trackheadsizes:
 *                              <li> trackheadshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageResponse GPUdb::visualizeImage( const std::vector<std::string>& tableNames,
                                              const std::vector<std::string>& worldTableNames,
                                              const std::string& xColumnName,
                                              const std::string& yColumnName,
                                              const std::vector<std::vector<std::string> >& trackIds,
                                              const double minX,
                                              const double maxX,
                                              const double minY,
                                              const double maxY,
                                              const int32_t width,
                                              const int32_t height,
                                              const std::string& projection,
                                              const int64_t bgColor,
                                              const std::map<std::string, std::vector<std::string> >& styleOptions,
                                              const std::map<std::string, std::string>& options ) const
{
    VisualizeImageRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageResponse actualResponse_;
    submitRequest("/visualize/image", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param trackIds
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> do_points: Values: 'true', 'false'.
 *                              <li> do_shapes: Values: 'true', 'false'.
 *                              <li> do_tracks: Values: 'true', 'false'.
 *                              <li> do_symbology: Values: 'true', 'false'.
 *                              <li> pointcolors:
 *                              <li> pointsizes:
 *                              <li> pointshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> shapelinewidths:
 *                              <li> shapelinecolors:
 *                              <li> shapefillcolors:
 *                              <li> tracklinewidths:
 *                              <li> tracklinecolors:
 *                              <li> trackmarkersizes:
 *                              <li> trackmarkercolors:
 *                              <li> trackmarkershapes: Values: 'none',
 *                      'circle', 'square', 'diamond', 'hollowcircle',
 *                      'hollowsquare', 'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> trackheadcolors:
 *                              <li> trackheadsizes:
 *                              <li> trackheadshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageResponse& GPUdb::visualizeImage( const std::vector<std::string>& tableNames,
                                               const std::vector<std::string>& worldTableNames,
                                               const std::string& xColumnName,
                                               const std::string& yColumnName,
                                               const std::vector<std::vector<std::string> >& trackIds,
                                               const double minX,
                                               const double maxX,
                                               const double minY,
                                               const double maxY,
                                               const int32_t width,
                                               const int32_t height,
                                               const std::string& projection,
                                               const int64_t bgColor,
                                               const std::map<std::string, std::vector<std::string> >& styleOptions,
                                               const std::map<std::string, std::string>& options,
                                               VisualizeImageResponse& response_ ) const
{
    VisualizeImageRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse GPUdb::visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_ ) const
{
    VisualizeImageClassbreakResponse actualResponse_;
    submitRequest("/visualize/image/classbreak", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& GPUdb::visualizeImageClassbreak( const VisualizeImageClassbreakRequest& request_,
                                                                   VisualizeImageClassbreakResponse& response_ ) const
{
    submitRequest("/visualize/image/classbreak", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param trackIds
 * @param cbColumnName1
 * @param cbVals1
 * @param cbColumnName2
 * @param cbVals2
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> do_points: Values: 'true', 'false'.
 *                              <li> do_shapes: Values: 'true', 'false'.
 *                              <li> do_tracks: Values: 'true', 'false'.
 *                              <li> do_symbology: Values: 'true', 'false'.
 *                              <li> pointcolors:
 *                              <li> pointsizes:
 *                              <li> pointshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> shapelinewidths:
 *                              <li> shapelinecolors:
 *                              <li> shapefillcolors:
 *                              <li> tracklinewidths:
 *                              <li> tracklinecolors:
 *                              <li> trackmarkersizes:
 *                              <li> trackmarkercolors:
 *                              <li> trackmarkershapes: Values: 'none',
 *                      'circle', 'square', 'diamond', 'hollowcircle',
 *                      'hollowsquare', 'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> trackheadcolors:
 *                              <li> trackheadsizes:
 *                              <li> trackheadshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageClassbreakResponse GPUdb::visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                                  const std::vector<std::string>& worldTableNames,
                                                                  const std::string& xColumnName,
                                                                  const std::string& yColumnName,
                                                                  const std::vector<std::vector<std::string> >& trackIds,
                                                                  const std::string& cbColumnName1,
                                                                  const std::vector<std::string>& cbVals1,
                                                                  const std::vector<std::string>& cbColumnName2,
                                                                  const std::vector<std::vector<std::string> >& cbVals2,
                                                                  const double minX,
                                                                  const double maxX,
                                                                  const double minY,
                                                                  const double maxY,
                                                                  const int32_t width,
                                                                  const int32_t height,
                                                                  const std::string& projection,
                                                                  const int64_t bgColor,
                                                                  const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                                  const std::map<std::string, std::string>& options ) const
{
    VisualizeImageClassbreakRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.cbColumnName1 = cbColumnName1;
    actualRequest_.cbVals1 = cbVals1;
    actualRequest_.cbColumnName2 = cbColumnName2;
    actualRequest_.cbVals2 = cbVals2;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageClassbreakResponse actualResponse_;
    submitRequest("/visualize/image/classbreak", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param worldTableNames
 * @param xColumnName
 * @param yColumnName
 * @param trackIds
 * @param cbColumnName1
 * @param cbVals1
 * @param cbColumnName2
 * @param cbVals2
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param bgColor
 * @param styleOptions
 *                      <ul>
 *                              <li> do_points: Values: 'true', 'false'.
 *                              <li> do_shapes: Values: 'true', 'false'.
 *                              <li> do_tracks: Values: 'true', 'false'.
 *                              <li> do_symbology: Values: 'true', 'false'.
 *                              <li> pointcolors:
 *                              <li> pointsizes:
 *                              <li> pointshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> shapelinewidths:
 *                              <li> shapelinecolors:
 *                              <li> shapefillcolors:
 *                              <li> tracklinewidths:
 *                              <li> tracklinecolors:
 *                              <li> trackmarkersizes:
 *                              <li> trackmarkercolors:
 *                              <li> trackmarkershapes: Values: 'none',
 *                      'circle', 'square', 'diamond', 'hollowcircle',
 *                      'hollowsquare', 'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> trackheadcolors:
 *                              <li> trackheadsizes:
 *                              <li> trackheadshapes: Values: 'none', 'circle',
 *                      'square', 'diamond', 'hollowcircle', 'hollowsquare',
 *                      'hollowdiamond', 'SYMBOLCODE'.
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageClassbreakResponse& GPUdb::visualizeImageClassbreak( const std::vector<std::string>& tableNames,
                                                                   const std::vector<std::string>& worldTableNames,
                                                                   const std::string& xColumnName,
                                                                   const std::string& yColumnName,
                                                                   const std::vector<std::vector<std::string> >& trackIds,
                                                                   const std::string& cbColumnName1,
                                                                   const std::vector<std::string>& cbVals1,
                                                                   const std::vector<std::string>& cbColumnName2,
                                                                   const std::vector<std::vector<std::string> >& cbVals2,
                                                                   const double minX,
                                                                   const double maxX,
                                                                   const double minY,
                                                                   const double maxY,
                                                                   const int32_t width,
                                                                   const int32_t height,
                                                                   const std::string& projection,
                                                                   const int64_t bgColor,
                                                                   const std::map<std::string, std::vector<std::string> >& styleOptions,
                                                                   const std::map<std::string, std::string>& options,
                                                                   VisualizeImageClassbreakResponse& response_ ) const
{
    VisualizeImageClassbreakRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.trackIds = trackIds;
    actualRequest_.cbColumnName1 = cbColumnName1;
    actualRequest_.cbVals1 = cbVals1;
    actualRequest_.cbColumnName2 = cbColumnName2;
    actualRequest_.cbVals2 = cbVals2;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image/classbreak", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse GPUdb::visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_ ) const
{
    VisualizeImageHeatmapResponse actualResponse_;
    submitRequest("/visualize/image/heatmap", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& GPUdb::visualizeImageHeatmap( const VisualizeImageHeatmapRequest& request_,
                                                             VisualizeImageHeatmapResponse& response_ ) const
{
    submitRequest("/visualize/image/heatmap", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param styleOptions
 *                      <ul>
 *                              <li> colormap: Values: 'jet', 'hot', 'hsv',
 *                      'gray', 'blues', 'greens', 'greys', 'oranges',
 *                      'purples', 'reds', 'viridis'.
 *                              <li> blur_radius:
 *                              <li> bg_color:
 *                              <li> gradient_start_color:
 *                              <li> gradient_end_color:
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageHeatmapResponse GPUdb::visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                            const std::string& xColumnName,
                                                            const std::string& yColumnName,
                                                            const std::string& valueColumnName,
                                                            const double minX,
                                                            const double maxX,
                                                            const double minY,
                                                            const double maxY,
                                                            const int32_t width,
                                                            const int32_t height,
                                                            const std::string& projection,
                                                            const std::map<std::string, std::string>& styleOptions,
                                                            const std::map<std::string, std::string>& options ) const
{
    VisualizeImageHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeImageHeatmapResponse actualResponse_;
    submitRequest("/visualize/image/heatmap", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param valueColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param styleOptions
 *                      <ul>
 *                              <li> colormap: Values: 'jet', 'hot', 'hsv',
 *                      'gray', 'blues', 'greens', 'greys', 'oranges',
 *                      'purples', 'reds', 'viridis'.
 *                              <li> blur_radius:
 *                              <li> bg_color:
 *                              <li> gradient_start_color:
 *                              <li> gradient_end_color:
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageHeatmapResponse& GPUdb::visualizeImageHeatmap( const std::vector<std::string>& tableNames,
                                                             const std::string& xColumnName,
                                                             const std::string& yColumnName,
                                                             const std::string& valueColumnName,
                                                             const double minX,
                                                             const double maxX,
                                                             const double minY,
                                                             const double maxY,
                                                             const int32_t width,
                                                             const int32_t height,
                                                             const std::string& projection,
                                                             const std::map<std::string, std::string>& styleOptions,
                                                             const std::map<std::string, std::string>& options,
                                                             VisualizeImageHeatmapResponse& response_ ) const
{
    VisualizeImageHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.valueColumnName = valueColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/image/heatmap", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse GPUdb::visualizeImageLabels( const VisualizeImageLabelsRequest& request_ ) const
{
    VisualizeImageLabelsResponse actualResponse_;
    submitRequest("/visualize/image/labels", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& GPUdb::visualizeImageLabels( const VisualizeImageLabelsRequest& request_,
                                                           VisualizeImageLabelsResponse& response_ ) const
{
    submitRequest("/visualize/image/labels", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableName
 * @param xColumnName
 * @param yColumnName
 * @param xOffset
 * @param yOffset
 * @param textString
 * @param font
 * @param textColor
 * @param textAngle
 * @param textScale
 * @param drawBox
 * @param drawLeader
 * @param lineWidth
 * @param lineColor
 * @param fillColor
 * @param leaderXColumnName
 * @param leaderYColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeImageLabelsResponse GPUdb::visualizeImageLabels( const std::string& tableName,
                                                          const std::string& xColumnName,
                                                          const std::string& yColumnName,
                                                          const std::string& xOffset,
                                                          const std::string& yOffset,
                                                          const std::string& textString,
                                                          const std::string& font,
                                                          const std::string& textColor,
                                                          const std::string& textAngle,
                                                          const std::string& textScale,
                                                          const std::string& drawBox,
                                                          const std::string& drawLeader,
                                                          const std::string& lineWidth,
                                                          const std::string& lineColor,
                                                          const std::string& fillColor,
                                                          const std::string& leaderXColumnName,
                                                          const std::string& leaderYColumnName,
                                                          const double minX,
                                                          const double maxX,
                                                          const double minY,
                                                          const double maxY,
                                                          const int32_t width,
                                                          const int32_t height,
                                                          const std::string& projection,
                                                          const std::map<std::string, std::string>& options ) const
{
    VisualizeImageLabelsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.xOffset = xOffset;
    actualRequest_.yOffset = yOffset;
    actualRequest_.textString = textString;
    actualRequest_.font = font;
    actualRequest_.textColor = textColor;
    actualRequest_.textAngle = textAngle;
    actualRequest_.textScale = textScale;
    actualRequest_.drawBox = drawBox;
    actualRequest_.drawLeader = drawLeader;
    actualRequest_.lineWidth = lineWidth;
    actualRequest_.lineColor = lineColor;
    actualRequest_.fillColor = fillColor;
    actualRequest_.leaderXColumnName = leaderXColumnName;
    actualRequest_.leaderYColumnName = leaderYColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.options = options;
    VisualizeImageLabelsResponse actualResponse_;
    submitRequest("/visualize/image/labels", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableName
 * @param xColumnName
 * @param yColumnName
 * @param xOffset
 * @param yOffset
 * @param textString
 * @param font
 * @param textColor
 * @param textAngle
 * @param textScale
 * @param drawBox
 * @param drawLeader
 * @param lineWidth
 * @param lineColor
 * @param fillColor
 * @param leaderXColumnName
 * @param leaderYColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeImageLabelsResponse& GPUdb::visualizeImageLabels( const std::string& tableName,
                                                           const std::string& xColumnName,
                                                           const std::string& yColumnName,
                                                           const std::string& xOffset,
                                                           const std::string& yOffset,
                                                           const std::string& textString,
                                                           const std::string& font,
                                                           const std::string& textColor,
                                                           const std::string& textAngle,
                                                           const std::string& textScale,
                                                           const std::string& drawBox,
                                                           const std::string& drawLeader,
                                                           const std::string& lineWidth,
                                                           const std::string& lineColor,
                                                           const std::string& fillColor,
                                                           const std::string& leaderXColumnName,
                                                           const std::string& leaderYColumnName,
                                                           const double minX,
                                                           const double maxX,
                                                           const double minY,
                                                           const double maxY,
                                                           const int32_t width,
                                                           const int32_t height,
                                                           const std::string& projection,
                                                           const std::map<std::string, std::string>& options,
                                                           VisualizeImageLabelsResponse& response_ ) const
{
    VisualizeImageLabelsRequest actualRequest_;
    actualRequest_.tableName = tableName;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.xOffset = xOffset;
    actualRequest_.yOffset = yOffset;
    actualRequest_.textString = textString;
    actualRequest_.font = font;
    actualRequest_.textColor = textColor;
    actualRequest_.textAngle = textAngle;
    actualRequest_.textScale = textScale;
    actualRequest_.drawBox = drawBox;
    actualRequest_.drawLeader = drawLeader;
    actualRequest_.lineWidth = lineWidth;
    actualRequest_.lineColor = lineColor;
    actualRequest_.fillColor = fillColor;
    actualRequest_.leaderXColumnName = leaderXColumnName;
    actualRequest_.leaderYColumnName = leaderYColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.options = options;
    submitRequest("/visualize/image/labels", actualRequest_, response_, false);
    return response_;
}


/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 * http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 * http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoResponse GPUdb::visualizeVideo( const VisualizeVideoRequest& request_ ) const
{
    VisualizeVideoResponse actualResponse_;
    submitRequest("/visualize/video", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 * http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 * http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoResponse& GPUdb::visualizeVideo( const VisualizeVideoRequest& request_,
                                               VisualizeVideoResponse& response_ ) const
{
    submitRequest("/visualize/video", request_, response_, false);
    return response_;
}


/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 * http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 * http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param tableNames  Names of the tables containing the data for various
 *                    layers of the resulting video.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered. The number of tables should
 *                         match the number of tables in the @a tableNames
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code). Values:
 *                    'EPSG:4326', 'PLATE_CARREE', '900913', 'EPSG:900913',
 *                    '102100', 'EPSG:102100', '3857', 'EPSG:3857',
 *                    'WEB_MERCATOR'.
 *                      Default value is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image.
 * @param timeIntervals
 * @param videoStyle
 * @param sessionKey  User Provided session key that is later used to retrieve
 *                    the generated video from the WMS.
 * @param styleOptions  Styling options for the image.
 *                      <ul>
 *                              <li> do_points: Rasterize point data toggle.
 *                      Values: 'true', 'false'.
 *                              <li> do_shapes: Rasterize shapes toggle.
 *                      Values: 'true', 'false'.
 *                              <li> do_tracks: Rasterize tracks toggle.
 *                      Values: 'true', 'false'.
 *                              <li> pointcolors: RGB color value in hex for
 *                      the points.
 *                              <li> pointsizes: Size of points.
 *                              <li> pointshapes: Shape of the point. Values:
 *                      'none', 'circle', 'square', 'diamond', 'hollowcircle',
 *                      'hollowsquare', 'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> shapelinewidths: Width of the lines.
 *                              <li> shapelinecolors: RGB color values in hex
 *                      for the line.
 *                              <li> shapefillcolors: RGB color values in hex
 *                      for the fill color of the shapes. Use '-1' for no fill.
 *                              <li> tracklinewidths: Width of the track lines.
 *                      '0' implies do not draw track lines.
 *                              <li> tracklinecolors: RGB color values for the
 *                      track lines.
 *                              <li> trackmarkersizes: Size of the track point
 *                      markers.
 *                              <li> trackmarkercolors: Color of the track
 *                      point markers.
 *                              <li> trackmarkershapes: Shape of track point
 *                      markers. Values: 'none', 'circle', 'square', 'diamond',
 *                      'hollowcircle', 'hollowsquare', 'hollowdiamond',
 *                      'SYMBOLCODE'.
 *                              <li> trackheadcolors: Color of track head
 *                      markers.
 *                              <li> trackheadsizes: Size of track head
 *                      markers.
 *                              <li> trackheadshapes: Shape of track head
 *                      markers. Values: 'none', 'circle', 'square', 'diamond',
 *                      'hollowcircle', 'hollowsquare', 'hollowdiamond',
 *                      'SYMBOLCODE'.
 *                      </ul>
 * @param options  Optional parameters.  Default value is an empty std::map.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoResponse GPUdb::visualizeVideo( const std::vector<std::string>& tableNames,
                                              const std::vector<std::string>& worldTableNames,
                                              const std::vector<std::vector<std::string> >& trackIds,
                                              const std::string& xColumnName,
                                              const std::string& yColumnName,
                                              const double minX,
                                              const double maxX,
                                              const double minY,
                                              const double maxY,
                                              const int32_t width,
                                              const int32_t height,
                                              const std::string& projection,
                                              const int64_t bgColor,
                                              const std::vector<std::vector<double> >& timeIntervals,
                                              const std::string& videoStyle,
                                              const std::string& sessionKey,
                                              const std::map<std::string, std::vector<std::string> >& styleOptions,
                                              const std::map<std::string, std::string>& options ) const
{
    VisualizeVideoRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.trackIds = trackIds;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeVideoResponse actualResponse_;
    submitRequest("/visualize/video", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images (@a
 * bgColor, @a width, @a height), the collection of GPUdb table names on which
 * this function is to be applied, for which shapes (point, polygon, tracks)
 * the images are to be created and a user specified session key. This session
 * key is later used to fetch the generated images stored by GPUdb. The
 * operation is synchronous meaning that GPUdb will not return the request
 * until the images for all the frames of the video are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in @a
 * sessionKey of the visualize video request and the FRAME parameter indicates
 * which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 * http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 * http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 * 
 * @param tableNames  Names of the tables containing the data for various
 *                    layers of the resulting video.
 * @param worldTableNames  Optional name of the tables containing the data for
 *                         the entire track when the @a tableNames contains
 *                         only part of the track data, but the entire track
 *                         has to be rendered. The number of tables should
 *                         match the number of tables in the @a tableNames
 * @param trackIds  Tracks from the @a tableNames to be rendered.
 * @param xColumnName  Name of the column containing the x coordinates.
 * @param yColumnName  Name of the column containing the y coordinates.
 * @param minX  Lower bound for the x values.
 * @param maxX  Upper bound for the x values.
 * @param minY  Lower bound for the y values.
 * @param maxY  Upper bound for the y values.
 * @param width  Width of the generated image.
 * @param height  Height of the generated image.
 * @param projection  Spatial Reference System (i.e. EPSG Code). Values:
 *                    'EPSG:4326', 'PLATE_CARREE', '900913', 'EPSG:900913',
 *                    '102100', 'EPSG:102100', '3857', 'EPSG:3857',
 *                    'WEB_MERCATOR'.
 *                      Default value is 'PLATE_CARREE'.
 * @param bgColor  Background color of the generated image.
 * @param timeIntervals
 * @param videoStyle
 * @param sessionKey  User Provided session key that is later used to retrieve
 *                    the generated video from the WMS.
 * @param styleOptions  Styling options for the image.
 *                      <ul>
 *                              <li> do_points: Rasterize point data toggle.
 *                      Values: 'true', 'false'.
 *                              <li> do_shapes: Rasterize shapes toggle.
 *                      Values: 'true', 'false'.
 *                              <li> do_tracks: Rasterize tracks toggle.
 *                      Values: 'true', 'false'.
 *                              <li> pointcolors: RGB color value in hex for
 *                      the points.
 *                              <li> pointsizes: Size of points.
 *                              <li> pointshapes: Shape of the point. Values:
 *                      'none', 'circle', 'square', 'diamond', 'hollowcircle',
 *                      'hollowsquare', 'hollowdiamond', 'SYMBOLCODE'.
 *                              <li> shapelinewidths: Width of the lines.
 *                              <li> shapelinecolors: RGB color values in hex
 *                      for the line.
 *                              <li> shapefillcolors: RGB color values in hex
 *                      for the fill color of the shapes. Use '-1' for no fill.
 *                              <li> tracklinewidths: Width of the track lines.
 *                      '0' implies do not draw track lines.
 *                              <li> tracklinecolors: RGB color values for the
 *                      track lines.
 *                              <li> trackmarkersizes: Size of the track point
 *                      markers.
 *                              <li> trackmarkercolors: Color of the track
 *                      point markers.
 *                              <li> trackmarkershapes: Shape of track point
 *                      markers. Values: 'none', 'circle', 'square', 'diamond',
 *                      'hollowcircle', 'hollowsquare', 'hollowdiamond',
 *                      'SYMBOLCODE'.
 *                              <li> trackheadcolors: Color of track head
 *                      markers.
 *                              <li> trackheadsizes: Size of track head
 *                      markers.
 *                              <li> trackheadshapes: Shape of track head
 *                      markers. Values: 'none', 'circle', 'square', 'diamond',
 *                      'hollowcircle', 'hollowsquare', 'hollowdiamond',
 *                      'SYMBOLCODE'.
 *                      </ul>
 * @param options  Optional parameters.  Default value is an empty std::map.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoResponse& GPUdb::visualizeVideo( const std::vector<std::string>& tableNames,
                                               const std::vector<std::string>& worldTableNames,
                                               const std::vector<std::vector<std::string> >& trackIds,
                                               const std::string& xColumnName,
                                               const std::string& yColumnName,
                                               const double minX,
                                               const double maxX,
                                               const double minY,
                                               const double maxY,
                                               const int32_t width,
                                               const int32_t height,
                                               const std::string& projection,
                                               const int64_t bgColor,
                                               const std::vector<std::vector<double> >& timeIntervals,
                                               const std::string& videoStyle,
                                               const std::string& sessionKey,
                                               const std::map<std::string, std::vector<std::string> >& styleOptions,
                                               const std::map<std::string, std::string>& options,
                                               VisualizeVideoResponse& response_ ) const
{
    VisualizeVideoRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.worldTableNames = worldTableNames;
    actualRequest_.trackIds = trackIds;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.bgColor = bgColor;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/video", actualRequest_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoHeatmapResponse GPUdb::visualizeVideoHeatmap( const VisualizeVideoHeatmapRequest& request_ ) const
{
    VisualizeVideoHeatmapResponse actualResponse_;
    submitRequest("/visualize/video/heatmap", request_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param[in] request_  Request object containing the parameters for the
 *                      operation.
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoHeatmapResponse& GPUdb::visualizeVideoHeatmap( const VisualizeVideoHeatmapRequest& request_,
                                                             VisualizeVideoHeatmapResponse& response_ ) const
{
    submitRequest("/visualize/video/heatmap", request_, response_, false);
    return response_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param timeIntervals
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param videoStyle
 * @param sessionKey
 * @param styleOptions
 *                      <ul>
 *                              <li> colormap: Values: 'jet', 'hot', 'hsv',
 *                      'gray', 'blues', 'greens', 'greys', 'oranges',
 *                      'purples', 'reds'.
 *                              <li> blur_radius:
 *                              <li> bg_color:
 *                              <li> gradient_start_color:
 *                              <li> gradient_end_color:
 *                      </ul>
 * @param options
 * 
 * @return Response object containing the result of the operation.
 * 
 */

VisualizeVideoHeatmapResponse GPUdb::visualizeVideoHeatmap( const std::vector<std::string>& tableNames,
                                                            const std::string& xColumnName,
                                                            const std::string& yColumnName,
                                                            const double minX,
                                                            const double maxX,
                                                            const double minY,
                                                            const double maxY,
                                                            const std::vector<std::vector<double> >& timeIntervals,
                                                            const int32_t width,
                                                            const int32_t height,
                                                            const std::string& projection,
                                                            const std::string& videoStyle,
                                                            const std::string& sessionKey,
                                                            const std::map<std::string, std::string>& styleOptions,
                                                            const std::map<std::string, std::string>& options ) const
{
    VisualizeVideoHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    VisualizeVideoHeatmapResponse actualResponse_;
    submitRequest("/visualize/video/heatmap", actualRequest_, actualResponse_, false);
    return actualResponse_;
}


/**
 * @private
 * 
 * @param tableNames
 * @param xColumnName
 * @param yColumnName
 * @param minX
 * @param maxX
 * @param minY
 * @param maxY
 * @param timeIntervals
 * @param width
 * @param height
 * @param projection  Values: 'EPSG:4326', 'PLATE_CARREE', '900913',
 *                    'EPSG:900913', '102100', 'EPSG:102100', '3857',
 *                    'EPSG:3857', 'WEB_MERCATOR'.
 * @param videoStyle
 * @param sessionKey
 * @param styleOptions
 *                      <ul>
 *                              <li> colormap: Values: 'jet', 'hot', 'hsv',
 *                      'gray', 'blues', 'greens', 'greys', 'oranges',
 *                      'purples', 'reds'.
 *                              <li> blur_radius:
 *                              <li> bg_color:
 *                              <li> gradient_start_color:
 *                              <li> gradient_end_color:
 *                      </ul>
 * @param options
 * @param[out] response_  Response object containing the results of the
 *                        operation.
 * 
 * @return Response object containing the result of the operation (initially
 *         passed in by reference).
 * 
 */

VisualizeVideoHeatmapResponse& GPUdb::visualizeVideoHeatmap( const std::vector<std::string>& tableNames,
                                                             const std::string& xColumnName,
                                                             const std::string& yColumnName,
                                                             const double minX,
                                                             const double maxX,
                                                             const double minY,
                                                             const double maxY,
                                                             const std::vector<std::vector<double> >& timeIntervals,
                                                             const int32_t width,
                                                             const int32_t height,
                                                             const std::string& projection,
                                                             const std::string& videoStyle,
                                                             const std::string& sessionKey,
                                                             const std::map<std::string, std::string>& styleOptions,
                                                             const std::map<std::string, std::string>& options,
                                                             VisualizeVideoHeatmapResponse& response_ ) const
{
    VisualizeVideoHeatmapRequest actualRequest_;
    actualRequest_.tableNames = tableNames;
    actualRequest_.xColumnName = xColumnName;
    actualRequest_.yColumnName = yColumnName;
    actualRequest_.minX = minX;
    actualRequest_.maxX = maxX;
    actualRequest_.minY = minY;
    actualRequest_.maxY = maxY;
    actualRequest_.timeIntervals = timeIntervals;
    actualRequest_.width = width;
    actualRequest_.height = height;
    actualRequest_.projection = projection;
    actualRequest_.videoStyle = videoStyle;
    actualRequest_.sessionKey = sessionKey;
    actualRequest_.styleOptions = styleOptions;
    actualRequest_.options = options;
    submitRequest("/visualize/video/heatmap", actualRequest_, response_, false);
    return response_;
}

