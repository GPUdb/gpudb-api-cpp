/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __DELETE_RECORDS_H__
#define __DELETE_RECORDS_H__

namespace gpudb
{

    /**
     * A set of input parameters for {@link
     * #deleteRecords(const DeleteRecordsRequest&) const}.
     * <p>
     * Deletes record(s) matching the provided criteria from the given table.
     * The record selection criteria can either be one or more  @a expressions
     * (matching multiple records) or a single record identified by @a
     * record_id options.  Note that the two selection criteria are mutually
     * exclusive.  This operation cannot be run on a collection or a view.  The
     * operation is synchronous meaning that a response will not be available
     * until the request is completely processed and all the matching records
     * are deleted.
     */
    struct DeleteRecordsRequest
    {

        /**
         * Constructs a DeleteRecordsRequest object with default parameter
         * values.
         */
        DeleteRecordsRequest() :
            tableName(std::string()),
            expressions(std::vector<std::string>()),
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs a DeleteRecordsRequest object with the specified
         * parameters.
         * 
         * @param[in] tableName  Name of the table from which to delete
         *                       records. The set must be a currently existing
         *                       table and not a collection or a view.
         * @param[in] expressions  A list of the actual predicates, one for
         *                         each select; format should follow the
         *                         guidelines provided /filter. Specifying one
         *                         or more @a expressions is mutually exclusive
         *                         to specifying @a record_id in the @a
         *                         options.
         * @param[in] options  Optional parameters.
         *                     <ul>
         *                             <li> global_expression: An optional
         *                     global expression to reduce the search space of
         *                     the @a expressions.
         *                             <li> record_id: A record id identifying
         *                     a single record, obtained at the time of
         *                     /insert/records or by calling
         *                     /get/records/fromcollection with the
         *                     *return_record_ids* option.
         *                     </ul>
         *                       Default value is an empty std::map.
         * 
         */
        DeleteRecordsRequest(const std::string& tableName, const std::vector<std::string>& expressions, const std::map<std::string, std::string>& options):
            tableName(tableName),
            expressions(expressions),
            options(options)
        {
        }

        std::string tableName;
        std::vector<std::string> expressions;
        std::map<std::string, std::string> options;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::DeleteRecordsRequest>
    {
        static void encode(Encoder& e, const gpudb::DeleteRecordsRequest& v)
        {
            ::avro::encode(e, v.tableName);
            ::avro::encode(e, v.expressions);
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::DeleteRecordsRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.tableName);
                            break;

                        case 1:
                            ::avro::decode(d, v.expressions);
                            break;

                        case 2:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.tableName);
                ::avro::decode(d, v.expressions);
                ::avro::decode(d, v.options);
            }
        }
    };
}

namespace gpudb
{

    /**
     * A set of output parameters for {@link
     * #deleteRecords(const DeleteRecordsRequest&) const}.
     * <p>
     * Deletes record(s) matching the provided criteria from the given table.
     * The record selection criteria can either be one or more  @a expressions
     * (matching multiple records) or a single record identified by @a
     * record_id options.  Note that the two selection criteria are mutually
     * exclusive.  This operation cannot be run on a collection or a view.  The
     * operation is synchronous meaning that a response will not be available
     * until the request is completely processed and all the matching records
     * are deleted.
     */
    struct DeleteRecordsResponse
    {

        /**
         * Constructs a DeleteRecordsResponse object with default parameter
         * values.
         */
        DeleteRecordsResponse() :
            countDeleted(int64_t()),
            countsDeleted(std::vector<int64_t>())
        {
        }

        int64_t countDeleted;
        std::vector<int64_t> countsDeleted;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::DeleteRecordsResponse>
    {
        static void encode(Encoder& e, const gpudb::DeleteRecordsResponse& v)
        {
            ::avro::encode(e, v.countDeleted);
            ::avro::encode(e, v.countsDeleted);
        }

        static void decode(Decoder& d, gpudb::DeleteRecordsResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.countDeleted);
                            break;

                        case 1:
                            ::avro::decode(d, v.countsDeleted);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.countDeleted);
                ::avro::decode(d, v.countsDeleted);
            }
        }
    };
}

#endif
