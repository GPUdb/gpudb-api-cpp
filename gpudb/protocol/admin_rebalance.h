/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __ADMIN_REBALANCE_H__
#define __ADMIN_REBALANCE_H__

namespace gpudb
{

    /**
     * A set of input parameters for {@link
     * #adminRebalance(const AdminRebalanceRequest&) const}.
     * <p>
     * Rebalance the cluster so that all the nodes contain approximately an
     * equal number of records.  The rebalance will also cause the shards to be
     * equally distributed (as much as possible) across all the ranks.
     * <p>
     * This endpoint may take a long time to run, depending on the amount of
     * data in the system. The API call may time out if run directly.  It is
     * recommended to run this endpoint asynchronously via {@link
     * #createJob(const CreateJobRequest&) const}.
     */
    struct AdminRebalanceRequest
    {

        /**
         * Constructs an AdminRebalanceRequest object with default parameter
         * values.
         */
        AdminRebalanceRequest() :
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs an AdminRebalanceRequest object with the specified
         * parameters.
         * 
         * @param[in] options_  Optional parameters.
         *                      <ul>
         *                              <li>
         *                      gpudb::admin_rebalance_rebalance_sharded_data:
         *                      If @a true, sharded data will be rebalanced
         *                      approximately equally across the cluster. Note
         *                      that for big clusters, this data transfer could
         *                      be time consuming and result in delayed query
         *                      responses.
         *                      <ul>
         *                              <li> gpudb::admin_rebalance_true
         *                              <li> gpudb::admin_rebalance_false
         *                      </ul>
         *                      The default value is
         *                      gpudb::admin_rebalance_true.
         *                              <li>
         *                      gpudb::admin_rebalance_rebalance_unsharded_data:
         *                      If @a true, unsharded data (data without
         *                      primary keys and without shard keys) will be
         *                      rebalanced approximately equally across the
         *                      cluster. Note that for big clusters, this data
         *                      transfer could be time consuming and result in
         *                      delayed query responses.
         *                      <ul>
         *                              <li> gpudb::admin_rebalance_true
         *                              <li> gpudb::admin_rebalance_false
         *                      </ul>
         *                      The default value is
         *                      gpudb::admin_rebalance_true.
         *                              <li>
         *                      gpudb::admin_rebalance_table_whitelist:
         *                      Comma-separated list of unsharded table names
         *                      to rebalance. Not applicable to sharded tables
         *                      because they are always balanced in accordance
         *                      with their primary key or shard key. Cannot be
         *                      used simultaneously with @a table_blacklist.
         *                              <li>
         *                      gpudb::admin_rebalance_table_blacklist:
         *                      Comma-separated list of unsharded table names
         *                      to not rebalance. Not applicable to sharded
         *                      tables because they are always balanced in
         *                      accordance with their primary key or shard key.
         *                      Cannot be used simultaneously with @a
         *                      table_whitelist.
         *                              <li>
         *                      gpudb::admin_rebalance_aggressiveness:
         *                      Influences how much data to send per rebalance
         *                      round.  A higher aggressiveness setting will
         *                      complete the rebalance faster.  A lower
         *                      aggressiveness setting will take longer, but
         *                      allow for better interleaving between the
         *                      rebalance and other queries. Allowed values are
         *                      1 through 10.  The default value is '1'.
         *                              <li>
         *                      gpudb::admin_rebalance_compact_after_rebalance:
         *                      Perform compaction of deleted records once the
         *                      rebalance completes, to reclaim memory and disk
         *                      space. Default is true.  The default value is
         *                      'true'.
         *                              <li>
         *                      gpudb::admin_rebalance_compact_only: Only
         *                      perform compaction, do not rebalance. Default
         *                      is false.  The default value is 'false'.
         *                      </ul>
         * 
         */
        AdminRebalanceRequest(const std::map<std::string, std::string>& options_):
            options( options_ )
        {
        }

        std::map<std::string, std::string> options;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::AdminRebalanceRequest>
    {
        static void encode(Encoder& e, const gpudb::AdminRebalanceRequest& v)
        {
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::AdminRebalanceRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.options);
            }
        }
    };
}

namespace gpudb
{

    /**
     * A set of output parameters for {@link
     * #adminRebalance(const AdminRebalanceRequest&) const}.
     * <p>
     * Rebalance the cluster so that all the nodes contain approximately an
     * equal number of records.  The rebalance will also cause the shards to be
     * equally distributed (as much as possible) across all the ranks.
     * <p>
     * This endpoint may take a long time to run, depending on the amount of
     * data in the system. The API call may time out if run directly.  It is
     * recommended to run this endpoint asynchronously via {@link
     * #createJob(const CreateJobRequest&) const}.
     */
    struct AdminRebalanceResponse
    {

        /**
         * Constructs an AdminRebalanceResponse object with default parameter
         * values.
         */
        AdminRebalanceResponse() :
            info(std::map<std::string, std::string>())
        {
        }

        std::map<std::string, std::string> info;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::AdminRebalanceResponse>
    {
        static void encode(Encoder& e, const gpudb::AdminRebalanceResponse& v)
        {
            ::avro::encode(e, v.info);
        }

        static void decode(Decoder& d, gpudb::AdminRebalanceResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.info);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.info);
            }
        }
    };
}

#endif
