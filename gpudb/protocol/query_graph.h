/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __QUERY_GRAPH_H__
#define __QUERY_GRAPH_H__

namespace gpudb
{

    /**
     * A set of input parameters for {@link
     * #queryGraph(const QueryGraphRequest&) const}.
     * <p>
     * Employs a topological query on a network graph generated a-priori by
     * {@link #createGraph(const CreateGraphRequest&) const} and returns a
     * list of adjacent edge(s) or node(s), also known as an adjacency list,
     * depending on what's been provided to the endpoint; providing edges will
     * return nodes and providing nodes will return edges. There are two ways
     * to provide edge(s) or node(s) to be queried: using column names and <a
     * href="../../graph_solver/network_graph_solver.html#query-identifiers"
     * target="_top">query identifiers</a> with the @a queries with or using a
     * list of specific IDs with one of the @a edgeOrNodeIntIds, @a
     * edgeOrNodeStringIds, and @a edgeOrNodeWktIds arrays and @a edgeToNode to
     * determine if the IDs are edges or nodes.
     * <p>
     * To determine the node(s) or edge(s) adjacent to a value from a given
     * column, provide a list of column names aliased as a particular query
     * identifier to @a queries. This field can be populated with column values
     * from any table as long as the type is supported by the given identifier.
     * See <a
     * href="../../graph_solver/network_graph_solver.html#query-identifiers"
     * target="_top">Query Identifiers</a> for more information.
     * <p>
     * To query for nodes that are adjacent to a given set of edges, set @a
     * edgeToNode to @a true and provide values to the @a edgeOrNodeIntIds, @a
     * edgeOrNodeStringIds, and @a edgeOrNodeWktIds arrays; it is assumed the
     * values in the arrays are edges and the corresponding adjacency list
     * array in the response will be populated with nodes.
     * <p>
     * To query for edges that are adjacent to a given set of nodes, set @a
     * edgeToNode to @a false and provide values to the @a edgeOrNodeIntIds, @a
     * edgeOrNodeStringIds, and @a edgeOrNodeWktIds arrays; it is assumed the
     * values in arrays are nodes and the given node(s) will be queried for
     * adjacent edges and the corresponding adjacency list array in the
     * response will be populated with edges.
     * <p>
     * To query for adjacencies relative to a given column and a given set of
     * edges/nodes, the @a queries and @a edgeOrNodeIntIds / @a
     * edgeOrNodeStringIds / @a edgeOrNodeWktIds parameters can be used in
     * conjuction with each other. If both @a queries and one of the arrays are
     * populated, values from @a queries will be prioritized over values in the
     * array and all values parsed from the @a queries array will be appended
     * to the corresponding arrays (depending on the type). If using both @a
     * queries and the edge_or_node arrays, the types must match, e.g., if @a
     * queries utilizes the 'QUERY_NODE_ID' identifier, only the @a
     * edgeOrNodeIntIds array should be used. Note that using @a queries will
     * override @a edgeToNode, so if @a queries contains a node-based query
     * identifier, e.g., 'table.column AS QUERY_NODE_ID', it is assumed that
     * the @a edgeOrNodeIntIds will contain node IDs.
     * <p>
     * To return the adjacency list in the response, leave @a adjacencyTable
     * empty. To return the adjacency list in a table and not in the response,
     * provide a value to @a adjacencyTable and set @a export_query_results to
     * @a false. To return the adjacency list both in a table and the response,
     * provide a value to @a adjacencyTable and set @a export_query_results to
     * @a true.
     * <p>
     * See <a href="../../graph_solver/network_graph_solver.html"
     * target="_top">Network Graph Solver</a> for more information.
     */
    struct QueryGraphRequest
    {

        /**
         * Constructs a QueryGraphRequest object with default parameter values.
         */
        QueryGraphRequest() :
            graphName(std::string()),
            queries(std::vector<std::string>()),
            edgeToNode(bool()),
            edgeOrNodeIntIds(std::vector<int64_t>()),
            edgeOrNodeStringIds(std::vector<std::string>()),
            edgeOrNodeWktIds(std::vector<std::string>()),
            restrictions(std::vector<std::string>()),
            adjacencyTable(std::string()),
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs a QueryGraphRequest object with the specified parameters.
         * 
         * @param[in] graphName_  Name of the graph resource to query.
         * @param[in] queries_  Nodes or edges to be queried specified using <a
         *                      href="../../graph_solver/network_graph_solver.html#query-identifiers"
         *                      target="_top">query identifiers</a>, e.g.,
         *                      'table.column AS QUERY_NODE_ID' or
         *                      'table.column AS QUERY_EDGE_WKTLINE'. Multiple
         *                      columns can be used as long as the same
         *                      identifier is used for all columns. Passing in
         *                      a query identifier will override the @a
         *                      edgeToNode parameter.
         * @param[in] edgeToNode_  If set to @a true, the given edge(s) will be
         *                         queried for adjacent nodes. If set to @a
         *                         false, the given node(s) will be queried for
         *                         adjacent edges.
         *                         <ul>
         *                                 <li> gpudb::query_graph_true
         *                                 <li> gpudb::query_graph_false
         *                         </ul>
         *                         The default value is
         *                         gpudb::query_graph_true.
         * @param[in] edgeOrNodeIntIds_  The unique list of edge or node
         *                               integer identifiers that will be
         *                               queried for adjacencies.
         * @param[in] edgeOrNodeStringIds_  The unique list of edge or node
         *                                  string identifiers that will be
         *                                  queried for adjacencies.
         * @param[in] edgeOrNodeWktIds_  The unique list of edge or node
         *                               WKTPOINT or WKTLINE string identifiers
         *                               that will be queried for adjacencies.
         * @param[in] restrictions_  Additional restrictions to apply to the
         *                           nodes/edges of an existing graph.
         *                           Restrictions must be specified using <a
         *                           href="../../graph_solver/network_graph_solver.html#identifiers"
         *                           target="_top">identifiers</a>; identifiers
         *                           are grouped as <a
         *                           href="../../graph_solver/network_graph_solver.html#id-combos"
         *                           target="_top">combinations</a>.
         *                           Identifiers can be used with existing
         *                           column names, e.g., 'table.column AS
         *                           RESTRICTIONS_EDGE_ID', or expressions,
         *                           e.g., 'column/2 AS
         *                           RESTRICTIONS_VALUECOMPARED'.
         * @param[in] adjacencyTable_  Name of the table to store the resulting
         *                             adjacencies. If left blank, the query
         *                             results are instead returned in the
         *                             response even if @a export_query_results
         *                             is set to @a false.
         * @param[in] options_  Additional parameters
         *                      <ul>
         *                              <li>
         *                      gpudb::query_graph_number_of_rings: Sets the
         *                      number of rings of edges around the node to
         *                      query for adjacency, with '1' being the edges
         *                      directly attached to the queried nodes. For
         *                      example, if @a number_of_rings is set to '2',
         *                      the edge(s) directly attached to the queried
         *                      nodes will be returned; in addition, the
         *                      edge(s) attached to the node(s) attached to the
         *                      initial ring of edge(s) surrounding the queried
         *                      node(s) will be returned. This setting is
         *                      ignored if @a edgeToNode is set to @a true.
         *                      This setting cannot be less than '1'.  The
         *                      default value is '1'.
         *                              <li>
         *                      gpudb::query_graph_include_all_edges: This
         *                      parameter is only applicable if the queried
         *                      graph is directed and @a edgeToNode is set to
         *                      @a false. If set to @a true, all inbound edges
         *                      and outbound edges relative to the node will be
         *                      returned. If set to @a false, only outbound
         *                      edges relative to the node will be returned.
         *                      <ul>
         *                              <li> gpudb::query_graph_true
         *                              <li> gpudb::query_graph_false
         *                      </ul>
         *                      The default value is gpudb::query_graph_false.
         *                              <li>
         *                      gpudb::query_graph_restriction_threshold_value:
         *                      Value-based restriction comparison. Any node or
         *                      edge with a RESTRICTIONS_VALUECOMPARED value
         *                      greater than the @a restriction_threshold_value
         *                      will not be included in the solution.
         *                              <li>
         *                      gpudb::query_graph_export_query_results:
         *                      Returns query results in the response if set to
         *                      @a true.
         *                      <ul>
         *                              <li> gpudb::query_graph_true
         *                              <li> gpudb::query_graph_false
         *                      </ul>
         *                      The default value is gpudb::query_graph_true.
         *                              <li>
         *                      gpudb::query_graph_enable_graph_draw: If set to
         *                      @a true, adds a WKT-type column named
         *                      'QUERY_EDGE_WKTLINE' to the given @a
         *                      adjacencyTable and inputs WKT values from the
         *                      source graph (if available) or auto-generated
         *                      WKT values (if there are no WKT values in the
         *                      source graph). A subsequent call to the <a
         *                      href="../../api/rest/wms_rest.html"
         *                      target="_top">/wms</a> endpoint can then be
         *                      made to display the query results on a map.
         *                      <ul>
         *                              <li> gpudb::query_graph_true
         *                              <li> gpudb::query_graph_false
         *                      </ul>
         *                      The default value is gpudb::query_graph_false.
         *                      </ul>
         * 
         */
        QueryGraphRequest(const std::string& graphName_, const std::vector<std::string>& queries_, const bool edgeToNode_, const std::vector<int64_t>& edgeOrNodeIntIds_, const std::vector<std::string>& edgeOrNodeStringIds_, const std::vector<std::string>& edgeOrNodeWktIds_, const std::vector<std::string>& restrictions_, const std::string& adjacencyTable_, const std::map<std::string, std::string>& options_):
            graphName( graphName_ ),
            queries( queries_ ),
            edgeToNode( edgeToNode_ ),
            edgeOrNodeIntIds( edgeOrNodeIntIds_ ),
            edgeOrNodeStringIds( edgeOrNodeStringIds_ ),
            edgeOrNodeWktIds( edgeOrNodeWktIds_ ),
            restrictions( restrictions_ ),
            adjacencyTable( adjacencyTable_ ),
            options( options_ )
        {
        }

        std::string graphName;
        std::vector<std::string> queries;
        bool edgeToNode;
        std::vector<int64_t> edgeOrNodeIntIds;
        std::vector<std::string> edgeOrNodeStringIds;
        std::vector<std::string> edgeOrNodeWktIds;
        std::vector<std::string> restrictions;
        std::string adjacencyTable;
        std::map<std::string, std::string> options;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::QueryGraphRequest>
    {
        static void encode(Encoder& e, const gpudb::QueryGraphRequest& v)
        {
            ::avro::encode(e, v.graphName);
            ::avro::encode(e, v.queries);
            ::avro::encode(e, v.edgeToNode);
            ::avro::encode(e, v.edgeOrNodeIntIds);
            ::avro::encode(e, v.edgeOrNodeStringIds);
            ::avro::encode(e, v.edgeOrNodeWktIds);
            ::avro::encode(e, v.restrictions);
            ::avro::encode(e, v.adjacencyTable);
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::QueryGraphRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.graphName);
                            break;

                        case 1:
                            ::avro::decode(d, v.queries);
                            break;

                        case 2:
                            ::avro::decode(d, v.edgeToNode);
                            break;

                        case 3:
                            ::avro::decode(d, v.edgeOrNodeIntIds);
                            break;

                        case 4:
                            ::avro::decode(d, v.edgeOrNodeStringIds);
                            break;

                        case 5:
                            ::avro::decode(d, v.edgeOrNodeWktIds);
                            break;

                        case 6:
                            ::avro::decode(d, v.restrictions);
                            break;

                        case 7:
                            ::avro::decode(d, v.adjacencyTable);
                            break;

                        case 8:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.graphName);
                ::avro::decode(d, v.queries);
                ::avro::decode(d, v.edgeToNode);
                ::avro::decode(d, v.edgeOrNodeIntIds);
                ::avro::decode(d, v.edgeOrNodeStringIds);
                ::avro::decode(d, v.edgeOrNodeWktIds);
                ::avro::decode(d, v.restrictions);
                ::avro::decode(d, v.adjacencyTable);
                ::avro::decode(d, v.options);
            }
        }
    };
}

namespace gpudb
{

    /**
     * A set of output parameters for {@link
     * #queryGraph(const QueryGraphRequest&) const}.
     * <p>
     * Employs a topological query on a network graph generated a-priori by
     * {@link #createGraph(const CreateGraphRequest&) const} and returns a
     * list of adjacent edge(s) or node(s), also known as an adjacency list,
     * depending on what's been provided to the endpoint; providing edges will
     * return nodes and providing nodes will return edges. There are two ways
     * to provide edge(s) or node(s) to be queried: using column names and <a
     * href="../../graph_solver/network_graph_solver.html#query-identifiers"
     * target="_top">query identifiers</a> with the @a queries with or using a
     * list of specific IDs with one of the @a edgeOrNodeIntIds, @a
     * edgeOrNodeStringIds, and @a edgeOrNodeWktIds arrays and @a edgeToNode to
     * determine if the IDs are edges or nodes.
     * <p>
     * To determine the node(s) or edge(s) adjacent to a value from a given
     * column, provide a list of column names aliased as a particular query
     * identifier to @a queries. This field can be populated with column values
     * from any table as long as the type is supported by the given identifier.
     * See <a
     * href="../../graph_solver/network_graph_solver.html#query-identifiers"
     * target="_top">Query Identifiers</a> for more information.
     * <p>
     * To query for nodes that are adjacent to a given set of edges, set @a
     * edgeToNode to @a true and provide values to the @a edgeOrNodeIntIds, @a
     * edgeOrNodeStringIds, and @a edgeOrNodeWktIds arrays; it is assumed the
     * values in the arrays are edges and the corresponding adjacency list
     * array in the response will be populated with nodes.
     * <p>
     * To query for edges that are adjacent to a given set of nodes, set @a
     * edgeToNode to @a false and provide values to the @a edgeOrNodeIntIds, @a
     * edgeOrNodeStringIds, and @a edgeOrNodeWktIds arrays; it is assumed the
     * values in arrays are nodes and the given node(s) will be queried for
     * adjacent edges and the corresponding adjacency list array in the
     * response will be populated with edges.
     * <p>
     * To query for adjacencies relative to a given column and a given set of
     * edges/nodes, the @a queries and @a edgeOrNodeIntIds / @a
     * edgeOrNodeStringIds / @a edgeOrNodeWktIds parameters can be used in
     * conjuction with each other. If both @a queries and one of the arrays are
     * populated, values from @a queries will be prioritized over values in the
     * array and all values parsed from the @a queries array will be appended
     * to the corresponding arrays (depending on the type). If using both @a
     * queries and the edge_or_node arrays, the types must match, e.g., if @a
     * queries utilizes the 'QUERY_NODE_ID' identifier, only the @a
     * edgeOrNodeIntIds array should be used. Note that using @a queries will
     * override @a edgeToNode, so if @a queries contains a node-based query
     * identifier, e.g., 'table.column AS QUERY_NODE_ID', it is assumed that
     * the @a edgeOrNodeIntIds will contain node IDs.
     * <p>
     * To return the adjacency list in the response, leave @a adjacencyTable
     * empty. To return the adjacency list in a table and not in the response,
     * provide a value to @a adjacencyTable and set @a export_query_results to
     * @a false. To return the adjacency list both in a table and the response,
     * provide a value to @a adjacencyTable and set @a export_query_results to
     * @a true.
     * <p>
     * See <a href="../../graph_solver/network_graph_solver.html"
     * target="_top">Network Graph Solver</a> for more information.
     */
    struct QueryGraphResponse
    {

        /**
         * Constructs a QueryGraphResponse object with default parameter
         * values.
         */
        QueryGraphResponse() :
            result(bool()),
            adjacencyListIntArray(std::vector<int64_t>()),
            adjacencyListStringArray(std::vector<std::string>()),
            adjacencyListWktArray(std::vector<std::string>()),
            info(std::map<std::string, std::string>())
        {
        }

        bool result;
        std::vector<int64_t> adjacencyListIntArray;
        std::vector<std::string> adjacencyListStringArray;
        std::vector<std::string> adjacencyListWktArray;
        std::map<std::string, std::string> info;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::QueryGraphResponse>
    {
        static void encode(Encoder& e, const gpudb::QueryGraphResponse& v)
        {
            ::avro::encode(e, v.result);
            ::avro::encode(e, v.adjacencyListIntArray);
            ::avro::encode(e, v.adjacencyListStringArray);
            ::avro::encode(e, v.adjacencyListWktArray);
            ::avro::encode(e, v.info);
        }

        static void decode(Decoder& d, gpudb::QueryGraphResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.result);
                            break;

                        case 1:
                            ::avro::decode(d, v.adjacencyListIntArray);
                            break;

                        case 2:
                            ::avro::decode(d, v.adjacencyListStringArray);
                            break;

                        case 3:
                            ::avro::decode(d, v.adjacencyListWktArray);
                            break;

                        case 4:
                            ::avro::decode(d, v.info);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.result);
                ::avro::decode(d, v.adjacencyListIntArray);
                ::avro::decode(d, v.adjacencyListStringArray);
                ::avro::decode(d, v.adjacencyListWktArray);
                ::avro::decode(d, v.info);
            }
        }
    };
}

#endif
